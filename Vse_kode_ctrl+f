UVOD V PYTHON:
# Osnovno o funkcijah
# =====================================================================@022145=
# 1. podnaloga
# Definirajte funkcijo z imenom `funkcija`, ki ne sprejme argumentov in vrne
# poljubno celo število (`int`).
# =============================================================================
def funkcija ():
    return 24
# =====================================================================@022146=
# 2. podnaloga
# Definirajte funkcijo z imenom `odmev`, ki sprejme en argument in ga vrne.
# =============================================================================
def odmev (uwu):
    return uwu
# =====================================================================@022147=
# 3. podnaloga
# Definirajte funkcijo z imenom `sestevek`, ki sprejme dva argumenta in vrne
# njuno vsoto.
# =============================================================================
def sestevek (a , b):
    return a + b
# =====================================================================@022148=
# 4. podnaloga
# Definirajte funkcijo z imenom `deljenje`, ki sprejme dve celi števili in vrne
# vrne dve vrednosti. Na prvem mestu vrne celoštevilski rezultat deljenja,
# na drugem pa ostanek pri deljenju. Zagotovljeno je, da druga vrednost ne bo `0`. 
# 
# Za vračanje več kot ene vrednosti po besedi `return` podate vrednosti ločene
# z vejico.
# =============================================================================
def deljenje ( a , b):
    return (a//b, a%b )

# Logične operacije
#
# Logični operator *konjunkcija* ima naslednjo resničnostno tabelo, kjer
# `F` predstavlja neresnično (`False`), `T` pa resnično (`True`) vrednost:
# 
#     A  B | A /\ B
#     -----+-------
#     F  F |   F
#     F  T |   F
#     T  F |   F
#     T  T |   T
# 
# S pomočjo vgrajenega operatorja `and` enostavno sestavimo funkcijo
# `konjunkcija(a, b)`, ki sprejme logični vrednosti `a` in `b` ter vrne logično
# vrednost konjunkcije `a /\ b`:
# 
#     def konjunkcija(a, b):
#         return a and b
# =====================================================================@021412=
# 1. podnaloga
# Logični operator *disjunkcija* ima naslednjo resničnostno tabelo:
# 
#     A  B | A \/ B
#     -----+-------
#     F  F |   F
#     F  T |   T
#     T  F |   T
#     T  T |   T
# 
# Sestavite funkcijo `disjunkcija(a, b)`, ki sprejme logični vrednosti
# `a` in `b` ter vrne logično vrednost disjunkcije `a \/ b`. Pri tem si
# pomagajte z vgrajenim operatorjem `or`.
# =============================================================================
def disjunkcija(a, b):
    return a or b
# =====================================================================@021413=
# 2. podnaloga
# Logični operator *negacija* ima naslednjo resničnostno tabelo:
# 
#     A | ~A
#     --+----
#     F | T
#     T | F
# 
# Sestavite funkcijo `negacija(a)`, ki vrne logično vrednost negacije `~a`.
# =============================================================================
def negacija (a):
    return not a
# =====================================================================@021414=
# 3. podnaloga
# Logični operator *implikacija* ima naslednjo resničnostno tabelo:
# 
#     A  B | A => B
#     -----+-------
#     F  F |   T
#     F  T |   T
#     T  F |   F
#     T  T |   T
# 
# Sestavite funkcijo `implikacija(a, b)`, ki vrne logično vrednost
# implikacije `a => b`.
# =============================================================================
def implikacija(a, b):
    return not a or b
# =====================================================================@021415=
# 4. podnaloga
# Logični operator *ekvivalenca* ima naslednjo resničnostno tabelo:
# 
#     A  B | A <=> B
#     -----+--------
#     F  F |    T
#     F  T |    F
#     T  F |    F
#     T  T |    T
# 
# Sestavite funkcijo `ekvivalenca(a, b)`, ki vrne logično vrednost implikacije
# `a <=> b`.
# 
# Namig: Pomagajte si lahko s funkcijo `implikacija`.
# =============================================================================
def ekvivalenca(a, b):
    return a == b
# =====================================================================@021416=
# 5. podnaloga
# Logični operator *ekskluzivni ali* (*exclusive or* ali XOR) ima naslednjo
# resničnostno tabelo:
# 
#     A  B | A XOR B
#     -----+--------
#     F  F |    F
#     F  T |    T
#     T  F |    T
#     T  T |    F
# 
# Sestavite funkcijo `xor(a, b)`, ki vrne logično vrednost `a XOR b`.
# =============================================================================
def xor(a, b):
    return not (a == b)
# =====================================================================@021417=
# 6. podnaloga
# Logični operator *NAND* (*not and*) ima naslednjo
# resničnostno tabelo:
# 
#     A  B | A NAND B
#     -----+---------
#     F  F |    T
#     F  T |    T
#     T  F |    T
#     T  T |    F
# 
# Sestavite funkcijo `nand(a, b)`, ki vrne logično vrednost `a NAND b`.
# =============================================================================
def nand(a, b):
    return not (a and b)
# =====================================================================@021418=
# 7. podnaloga
# Operator NAND je prav poseben, saj z njim lahko izrazimo vse osnovne logične
# operatorje (in s tem tudi vse operatorje).
# 
# Sestavite še funkcije `negacija_nand`, `disjunkcija_nand` in
# `konjunkcija_nand`, ki vrnejo logične vrednosti negacije, disjunkcije in
# konjunkcije svojih argumentov, vendar pri njihovih definicijah ne smete
# uporabiti vgrajenih logičnih operacij ali funkcij iz prejšnjih podnalog.
# Namesto tega uporabite funkcijo `nand`.
# =============================================================================
def negacija_nand (a):
    return nand (a,a)

def disjunkcija_nand (a,b):
    return nand ( nand(a,a), nand (b,b))

def konjunkcija_nand (a,b):
    return nand (nand(a,b), nand(a,b))

# Datumi
# =====================================================================@021409=
# 1. podnaloga
# Sestavite funkcijo `je_prestopno(leto)`, ki vrne `True`, kadar je `leto`
# prestopno, in `False`, kadar ni.
# =============================================================================
def je_prestopno(leto):
    if leto % 400 == 0:
        return True
    elif leto % 100 == 0:
        return False
    elif leto % 4 == 0:
        return True
    else:
        return False


# =====================================================================@021410=
# 2. podnaloga
# Sestavite funkcijo `stevilo_dni(mesec, leto)`, ki vrne število dni danega
# meseca (podanega s številom med 1 in 12) v danem letu.
# =============================================================================
def je_prestopno(leto):
    if leto % 400 == 0:
        return True
    elif leto % 100 == 0:
        return False
    elif leto % 4 == 0:
        return True
    else:
        return False

def stevilo_dni(mesec, leto):
    if mesec == 1 or mesec == 3 or mesec == 5 or mesec == 7 or mesec == 8 or mesec == 10 or mesec == 12:
        return 31
    elif mesec == 4 or mesec == 6 or mesec == 9 or mesec == 11:
        return 30
    elif mesec == 2:
        if je_prestopno(leto):
            return 29
        else:
            return 28

# =====================================================================@021411=
# 3. podnaloga
# Sestavite funkcijo `je_veljaven_datum(dan, mesec, leto)`, ki vrne `True`
# natanko tedaj, kadar `dan`, `mesec` in `leto` določajo veljaven datum
# (torej `mesec` mora biti število med 1 in 12, `dan` pa mora ustrezati dnevu
# v tem mesecu).
# =============================================================================
def je_veljaven_datum(dan, mesec, leto):
    return 1 <= mesec <= 12 and 1 <= dan <= stevilo_dni(mesec, leto)


# Razdalje med točkami
# =====================================================================@021949=
# 1. podnaloga
# Sestavite funkcijo `ravninska_razdalja(x1, y1, x2, y2)`, ki vrne
# razdaljo med točkama (`x1`, `y1`) in (`x2`, `y2`).
# 
#     >>> ravninska_razdalja(1, 2, 3, 4)
#     2.82842712475
# =============================================================================
import math
def ravninska_razdalja(x1, y1, x2, y2):
    return math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))

# =====================================================================@021950=
# 2. podnaloga
# Sestavite funkcijo `polarna_razdalja(r1, fi1, r2, fi2)`, ki vrne
# razdaljo med točkama (`r1`, `fi1`) in (`r2`, `fi2`) v ravnini, pri
# čemer so koordinate v polarnem zapisu, koti pa so izraženi v stopinjah.
# 
#     >>> polarna_razdalja(1, 30, 4, 90)
#     3.60555127546
# =============================================================================
import math
def polarna_razdalja(r1, fi1, r2, fi2):
    rad_fi1 = math.radians(fi1)
    rad_fi2 = math.radians(fi2)
    
    x1 = math.cos(rad_fi1) * r1
    y1 = math.sin(rad_fi1) * r1
    x2 = math.cos(rad_fi2) * r2
    y2 = math.sin(rad_fi2) * r2
    return math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))

##pretvori kote iz stopinj v radiane !!!

# Obresti
# =====================================================================@021419=
# 1. podnaloga
# Pri enostavnem obrestovanju s fiksno obrestno mero se vedno obrestuje
# samo glavnica, ne pa tudi obresti. Tako je vrednost na računu pri začetnem
# pologu $A_0$ po $n$ mesecih podana s formulo $A_0 (1 + m n)$, kjer je $m$
# pripadajoča mesečna obrestna mera.
# 
# Sestavite funkcijo
# `enostavno_obrestovanje(polog, mesecna_obrestna_mera, st_mesecev)`,
# ki za enostavno obrestovanju izračuna vrednost denarja na računu pri danem
# začetnem pologu, mesečni obrestni meri in številu mesecev.
# 
# Primeri:
# 
#     >>> enostavno_obrestovanje(100, 0.5, 0)
#     100.0
#     >>> enostavno_obrestovanje(100, 0.01, 1)
#     101.0
#     >>> enostavno_obrestovanje(100, 0.05, 12)
#     160.0
# =============================================================================
def enostavno_obrestovanje(polog, mesecna_obrestna_mera, st_mesecev):
    return polog * (1 + mesecna_obrestna_mera *  st_mesecev)

# =====================================================================@021420=
# 2. podnaloga
# Pri obrestno obrestnem računu s fiksno obrestno mero se poleg glavnice
# obrestujejo tudi obresti. Za glavnico $A_0$ je vrednost po $n$ mesecih podana
# s formulo $A_0 (1 + m)^n$, kjer je $m$ pripadajoča mesečna obrestna mera.
# 
# Sestavite funkcijo
# `obrestno_obrestovanje(polog, mesecna_obrestna_mera, st_mesecev)`,
# ki izračuna vrednost denarja na računu pri danem začetnem pologu, mesečni
# obrestni meri in številu mesecev, pri čemer se obresti računajo po obrestno
# obrestnem računu.
# 
# Primeri:
# 
#     >>> obrestno_obrestovanje(100, 0.5, 0)
#     100.0
#     >>> obrestno_obrestovanje(100, 0.05, 1)
#     105
#     >>> obrestno_obrestovanje(100, 0.01, 12)
#     112.68250301319698
# =============================================================================
def obrestno_obrestovanje(polog, mesecna_obrestna_mera, st_mesecev):
    return polog * ((1 + mesecna_obrestna_mera) ** st_mesecev)


# =====================================================================@021421=
# 3. podnaloga
# V bančništvu pogosto oglašujemo letno obrestno mero kljub temu, da obrestujemo
# mesečno.
# 
# Napišite funkcijo `pretvori_v_letno_obrestno_mero(mesecna_obrestna_mera)`,
# ki kot parameter sprejme mesečno obrestno mero, izraženo z decimalnim
# številom, in jo pretvori v letno obrestno mero, izraženo v odstotkih
# (zaokroženih na najbližje celo število). Pri računanju upoštevajte obrestno
# obrestni račun.
# 
# *Namig:* `help(round)`.
# =============================================================================
def pretvori_v_letno_obrestno_mero(mesecna_obrestna_mera):
    letna_obrestna_mera =  ((1 + mesecna_obrestna_mera) ** 12 - 1 ) * 100
    return round(letna_obrestna_mera)

# upoštevaj pretvorbo enačb iz mesečne v letno (1+r)^12 -1 

# Kontrolne števke
# =====================================================================@021406=
# 1. podnaloga
# Sestavite funkcijo `vsota_kvadratov_stevk(n)`, ki vrne vsoto kvadratov števk
# *tromestnega* števila `n`.
# 
#     >>> vsota_kvadratov_stevk(123)
#     14
# =============================================================================
def vsota_kvadratov_stevk(n):
    vsota = 0
    for znak in str(n):  # Pretvorimo število v niz
        vsota += int(znak) ** 2  # Kvadriramo in dodamo vsoti
    return vsota


# =====================================================================@021407=
# 2. podnaloga
# Sestavite funkcijo `obrat(n)`, ki vrne število, ki ga dobimo, če tromestnemu
# številu `n` zamenjamo števki na mestu enic in stotic.
# 
#     >>> obrat(123)
#     321
# =============================================================================
def obrat(n):
    vsota = 0
    faktor = 1
    for znak in str(n):  # Pretvorimo število v niz
        vsota += int(znak) * faktor
        faktor *= 10
    return vsota

# =====================================================================@021408=
# 3. podnaloga
# Da bi pri obdelavi podatkov lahko prepoznali morebitne napake, številske
# podatke pogosto opremimo s kontrolnimi števkami. Eden takšnih podatkov je
# sklic (referenca) po standardu SI12, ki ga uporabljamo pri plačevanju s
# položnicami UPN. Sklic zapišemo kot 13-mestno število, pri čemer je prvih 12
# števk poljubnih, zadnja (trinajsta) pa je kontrolna, torej izračunana iz
# prejšnjih, in nam služi za preverjanje, ali je pri branju podatkov s položnice
# bilo vse v redu.
# 
# Kontrolno števko za dano 12-mestno število izračunamo tako, da števke od desne
# proti levi pomnožimo z zaporednimi števili 2, 3, 4, … (enice torej pomnožimo z
# 2, desetice s 3, stotice s 4, …). Dobljene produkte seštejemo, nato izračunamo
# ostanek, ki ga da dobljena vsota pri deljenju z 11, in ta ostanek odštejemo od
# 11. Dobimo število med 1 in 11. Če je to število manjše od 10, je to že kar
# iskana kontrolna števka, sicer pa je kontrolna števka enaka 0.
# 
# Sestavite funkcijo `dodaj_kontrolno_stevko(sklic)`, ki za 12-mestno število
# `sklic` vrne 13-mestno število s pripadajočo kontrolno števko.
# 
#     >>> dodaj_kontrolno_stevko(265195368523)
#     2651953685235
# =============================================================================
def dodaj_kontrolno_stevko(sklic):
    niz = 0
    kontrolnast = 0
    stevilo = 0
    vsota = 0
    faktor = 13
    for znak in str(sklic):
        vsota += int(znak) * faktor
        faktor -= 1
    stevilo = 11 - (vsota % 11)
    if stevilo < 10:
        kontrolnast = stevilo
    elif stevilo >= 10:
        kontrolnast = 0
    niz = int(sklic) * 10 + kontrolnast
    return niz


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ZANKE:
# Vsote potenc
# =====================================================================@021456=
# 1. podnaloga
# Sestavite funkcijo `vsota_prvih(n)`, ki vrne vsoto prvih `n` naravnih števil.
# =============================================================================
def vsota_prvih(n):
    x = 1
    vsota = 0    
    while n > 0:
        vsota += x
        x += 1
        n -= 1
    return vsota
# =====================================================================@021457=
# 2. podnaloga
# Sestavite funkcijo `vsota_prvih_kvadratov(n)`, ki vrne vsoto kvadratov
# prvih `n` naravnih števil.
# =============================================================================
def vsota_prvih_kvadratov(n):
    x = 1
    vsota = 0    
    while n > 0:
        vsota += (x ** 2)
        x += 1
        n -= 1
    return vsota
# =====================================================================@021458=
# 3. podnaloga
# Sestavite funkcijo `vsota_prvih_potenc(n, k)`, ki vrne vsoto `k`-tih potenc
# prvih `n` naravnih števil. Argument `k` naj bo neobvezen in naj ima privzeto
# vrednost `1`.
# =============================================================================
def vsota_prvih_potenc(n, k = 1):
    vsota = 0
    x = 0   
    while n >= x:
        vsota += (x ** k)
        x += 1
    return vsota

# Vsote števk
# =====================================================================@021459=
# 1. podnaloga
# Sestavite funkcijo `vsota_stevk(n)`, ki vrne vsoto števk podanega števila.
# =============================================================================
def vsota_stevk(n):
    vsota = 0
    while n > 0:
        stevka = n % 10
        n = n // 10
        vsota += stevka
    return vsota
# =====================================================================@021460=
# 2. podnaloga
# Sestavite funkcijo `vsota_vecjih_stevk(n, k)`, ki vrne vsoto tistih števk
# števila `n`, ki so večje ali enake `k`. Če parametra `k` ne podamo, naj
# funkcija vrne vsoto vseh števk števila `n`.
# =============================================================================
def vsota_vecjih_stevk(n, k = 0):
    vsota = 0
    while n > 0:
        stevka = n % 10
        n = n // 10
        if stevka >= k:
            vsota += stevka
    return vsota
# =====================================================================@021461=
# 3. podnaloga
# Sestavite funkcijo `vsota_stevk_stevil_med(m, n)`, ki vrne vsoto števk
# vseh števil med vključno `m` in `n`.
# =============================================================================
#def vsota_stevk_stevil_med(m, n):
    vsota = 0
    for stevilka in range(m, n + 1):
        vsota += sum(int(stevka) for stevka in str(stevilka))
    return vsota

def vsota_stevk_stevil_med(m, n):
    vsota = 0
    stevilo = m
    while stevilo >= m and stevilo <= n:
        vsota += vsota_stevk(stevilo)
        stevilo += 1
    return vsota

# Delne vsote vrst
# =====================================================================@021951=
# 1. podnaloga
# Napišite funkcijo `vsota_potenc(n, k)`, ki izračuna vsoto
#    $$1^k + 2^k + ... + n^k$$
# =============================================================================
def vsota_potenc(n, k):
    vsota = 0
    stevilo = 1
    while stevilo <= n:
        vsota += stevilo ** k
        stevilo += 1
    return vsota
# =====================================================================@021952=
# 2. podnaloga
# Sestavite funkcijo `vsota_harmonicne(n)`, ki izračuna delno vsoto
#    $$1 + 1 / 2 + 1 / 3 + ... + 1 / n$$
# =============================================================================
def vsota_harmonicne(n):
    vsota = 0
    stevilo = 1
    x = 1
    while x <= n:
        vsota += stevilo * 1 / x
        x += 1
    return vsota
# =====================================================================@021953=
# 3. podnaloga
# Sestavite funkcijo `divergenca_harmonicne(n)`, ki izračuna število
# členov harmonične vrste, ki jih je treba sešteti, da bo njihova delna
# vsota večja od števila `n`.
# =============================================================================
def divergenca_harmonicne(n):
    vsota = 0
    cleni = 0
    x = 1
    while vsota <= n:
        vsota += (1 * (1 / x))
        x += 1
        cleni += 1
    return cleni   
# =====================================================================@021954=
# 4. podnaloga
# Sestavite funkcijo `eksponentna(n)`, ki izračuna delno vsoto:
#    $$1 + 1 / 1! + 1 / 2! + 1 / 3! + ... + 1 / n!$$
# =============================================================================
import math
def eksponentna(n):
    vsota = 0
    x = 0
    while x <= n:
        vsota += (1 / math.factorial(x))
        x += 1
    return vsota

# Kvadratni koren
#
# Približke za kvadratni koren števila $n$ lahko izračunamo po naslednjem
# postopku. Začetni približek $x_0$ je enak $n / 2$. Vsak naslednji približek
# $x_{k + 1}$ pa izračunamo kot $(x_k + n / x_k) / 2$.
# =====================================================================@021462=
# 1. podnaloga
# Sestavite funkcijo `priblizek_po_korakih(n, k)`, ki po zgornjem postopku
# izračuna `k`. približek korena števila `n`.
# =============================================================================
def priblizek_po_korakih(n, k):
    x = 1
    priblizek = 0
    if k == 0:
        priblizek = (n / 2)
    elif k > 0:
        priblizek = (n / 2)
        while x <= k:
            priblizek = ((priblizek + n / priblizek) / 2)
            x += 1
    return priblizek

# =====================================================================@021463=
# 2. podnaloga
# Sestavite funkcijo `priblizek_do_natancnosti(n, eps)`, ki po zgornjem
# postopku izračuna prvi približek korena števila `n`, za katerega se kvadrat
# približka od `n` razlikuje za manj kot `eps`. Smislena vrednost za argument
# `eps` je npr. $10^{-6}$.
# =============================================================================
#def priblizek_do_natancnosti(n, eps):
    k = 1  # Število korakov
    while True:
        priblizek = priblizek_po_korakih(n, k) # Preverimo, ali je razlika kvadratov znotraj eps
        if abs(n - priblizek**2) < eps:
            return priblizek
        k += 1  # Povečamo število korakov

def priblizek_do_natancnosti(n, eps):
    x = 1
    priblizek = (n / 2)
    while abs(n - priblizek ** 2) >= eps:
        priblizek = ((priblizek + n / priblizek) / 2)
        x += 1
    return priblizek

# Evklidov algoritem
# =====================================================================@021970=
# 1. podnaloga
# Implementirajte [Evklidov algoritem](https://sl.wikipedia.org/wiki/Evklidov_algoritem)
# za iskanje največjega skupnega delitelja s pomočjo zanke `while`.
# 
#     >>> evklidov_algoritem(144, 40)
#     8
#     >>> evklidov_algoritem(81, 36)
#     9
# =============================================================================
def evklidov_algoritem(x, y):
    while y != 0:
        x, y = y, x % y
    return x

# Zlati rez
#
# Pravimo, da sta števili $a$ in $b$ v razmerju _zlatega reza_, kadar je
# $a : b$ enako $(a + b) : a$, kar je takrat, ko je $\frac{a}{b}$ enako
# številu $\phi = \frac{1 + \sqrt{5}}{2}$.
# 
# Približek števila $\phi$ lahko izračunamo z zaporedjem
#   $\phi_0, \phi_1, \phi_2, \dots$,
# kjer je $\phi_0 = 1$, naslednji približek $\phi_{n + 1}$ pa izračunamo
# kot
#   $\phi_{n + 1} = 1 + 1 / \phi_n$.
# =====================================================================@021475=
# 1. podnaloga
# Sestavite funkcijo `naslednji_priblizek`, ki iz podanega približka po
# zgornjem postopku izračuna naslednji približek števila $\phi$.
# =============================================================================
def naslednji_priblizek(x):
    return 1 + 1 / x
# =====================================================================@021476=
# 2. podnaloga
# Sestavite funkcijo `priblizek(k)`, ki izračuna `k`. približek števila
# $\phi$. Za začetni približek (ko je `k` enak $0$) vzamite število $1$.
# =============================================================================
def priblizek(k):
    x = 1
    for _ in range(k):
        x = naslednji_priblizek(x)
    return x
# =====================================================================@021477=
# 3. podnaloga
# Sestavite funkcijo `natancni_priblizek`, ki sprejme pozitivno realno 
# število, ki predstavlja natančnost, ter izračuna prvi približek
# števila $\phi$, ki se od prejšnjega približka razlikuje za manj kot
# podano natančnost.
# =============================================================================
def natancni_priblizek(eps):
    prejsnji = 1
    naslednji = naslednji_priblizek(prejsnji)
    while abs(prejsnji - naslednji) >= eps:
        prejsnji = naslednji 
        naslednji = naslednji_priblizek(prejsnji)
    return naslednji

# Praštevila
# =====================================================================@021945=
# 1. podnaloga
# Sestavite funkcijo `je_prastevilo`, ki sprejme število in vrne `True`, če 
# je podano število praštevilo, in `False`, če ni.
# =============================================================================
def je_prastevilo(n):
    if n <= 1:
        return False
    else:
        d = 2
        while d ** 2 <= n:
            if n % d == 0:
                return False
            d += 1
        return True
# =====================================================================@021946=
# 2. podnaloga
# Sestavite funkcijo `prastevilo(n)`, ki vrne `n`-to praštevilo.
# =============================================================================
def prastevilo(n):
    i = 1
    kandidat = 2
    while i < n:
        kandidat += 1
        if je_prastevilo(kandidat):
            i += 1
    return kandidat
# =====================================================================@021947=
# 3. podnaloga
# Sestavite funkcijo `naslednje_prastevilo(n)`, ki vrne prvo praštevilo,
# strogo večje od števila `n`.
# =============================================================================
def naslednje_prastevilo(n):
    kandidat = n + 1
    while not je_prastevilo(kandidat):
        kandidat += 1
    return kandidat
# =====================================================================@021948=
# 4. podnaloga
# Sestavite funkcijo `prvo_prastevilo_z_vsoto_stevk_vsaj(n)`, ki izračuna
# točno to, kar piše v njenem imenu.
# =============================================================================
def vsota_stevk(n):
    vsota = 0
    while n > 0:
        vsota += n % 10
        n //= 10
    return vsota

def prvo_prastevilo_z_vsoto_stevk_vsaj(n):
    kandidat = (n % 9 + 1) * 10 ** (n // 9) - 1
    while not (je_prastevilo(kandidat) and vsota_stevk(kandidat) >= n):
        kandidat += 1
    return kandidat

# Collatzovo zaporedje
#
# Collatzovo zaporedje tvorimo na sledeč način. Začnemo z nekim naravnim
# številom $n$, ki ga nato delimo z $2$, če je sodo, ali pa pomnožimo s $3$ in
# prištejemo $1$, če je liho. Postopek ponavljamo, dokler ne pridemo do števila
# $1$ (v tem primeru stvar ni več zanimiva, saj se začno ponavljati števila
# $1, 4, 2, 1, 4, 2, 1, \ldots$). Primer zaporedja, ki se začne z $6$ je tako
# $6, 3, 10, 5, 16, 8, 4, 2, 1$. Collatzova domneva, ki trdi, da za poljubno
# naravno število njegovo Collatzovo zaporedje sčasoma doseže $1$, je še vedno
# nerešena.
# =====================================================================@021468=
# 1. podnaloga
# Sestavite funkcijo `naslednji_clen`, ki sprejme število in izračuna člen,
# ki v Collatzovemu zaporedju sledi temu številu.
# =============================================================================
def naslednji_clen(n):
    if n % 2 == 0:
        return n // 2
    else:
        return 3 * n + 1
# =====================================================================@021469=
# 2. podnaloga
# Sestavite funkcijo `dolzina_zaporedja`, ki sprejme število in izračuna 
# dolžino Collatzovega zaporedja, ki se začne s tem številom.
# =============================================================================
def dolzina_zaporedja(n):
    dolzina = 1
    while n != 1:
        n = naslednji_clen(n)
        dolzina += 1
    return dolzina
# =====================================================================@021470=
# 3. podnaloga
# Sestavite funkcijo `najvecji_clen`, ki sprejme število in izračuna največji 
# člen v Collatzovem zaporedju, ki se začne s tem številom.
# =============================================================================
def najvecji_clen(n):
    najvecji = n
    while n != 1:
        n = naslednji_clen(n)
        najvecji = max(najvecji, n)
    return najvecji
# =====================================================================@021471=
# 4. podnaloga
# Sestavite funkcijo `najdaljse_zaporedje(m, n)`, ki vrne dolžino najdaljšega
# zaporedja med vsemi tistimi Collatzovimi zaporedji, ki se začnejo s števili
# med (vključno) `m` in `n`.
# =============================================================================
def najdaljse_zaporedje(m, n):
    dolzina = 0
    for k in range(m, n + 1):
        dolzina = max(dolzina, dolzina_zaporedja(k))
    return dolzina

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SEZNAMI:
# Delo s seznami
# =====================================================================@021433=
# 1. podnaloga
# Sestavite funkcijo `razpolovi_seznam`, ki seznam prepolovi na dva podseznama
# in ju vrne kot par seznamov. V primeru lihe dolžine naj bo dolžina prvega
# podseznama krajša ali enaka dolžini drugega podseznama.
# 
#     >>> razpolovi_seznam(["a", "b", "c", "d"])
#     (["a", "b"], ["c", "d"])
#     >>> razpolovi_seznam([5, 4, 3, 2, 1])
#     ([5, 4], [3, 2, 1])
# =============================================================================
def razpolovi_seznam(s):
    d = len(s)
    i = d // 2
    return (s[:i], s[i:])
# =====================================================================@021434=
# 2. podnaloga
# Sestavite funkcijo `zamenjaj_elementa(sez,i,j)`, ki iz seznama `sez` sestavi
# nov seznam, v katerem sta elementa na mestih `i` in `j` zamenjana med sabo.
# Če kateri od indeksov `i` in `j` ne ustrezata nobenemu elementu, naj funkcija
# vrne kar seznam `sez`.
# 
#     >>> zamenjaj_elementa([1, 2, 3, 4], 1, 2)
#     [1, 3, 2, 4]
#     >>> zamenjaj_elementa([1, 2, 3, 4], 3, 1)
#     [1, 4, 3, 2]
#     >>> zamenjaj_elementa([1, 2, 3, 4], 1, 2017)
#     [1, 2, 3, 4]
# =============================================================================
def zamenjaj_elementa(sez,i,j):
    if len(sez) > i and len(sez) > j:
        x = sez [i]
        y = sez [j]
        del sez [i]
        sez.insert (i, y)
        del sez [j]
        sez.insert (j, x)
        return sez
    else:
        return sez
# =====================================================================@021435=
# 3. podnaloga
# Sestavite funkcijo `porezani_podseznami`, ki sprejme seznam in zgradi nov
# seznam podseznamov, ki jih pridobimo tako, da podanemu seznamu po vrsti
# odstranjujemo začetne elemente.
# 
#     >>> porezani_podseznami([1, 2, 3, 4])
#     [[1, 2, 3, 4], [2, 3, 4], [3, 4], [4], []]
# =============================================================================
def porezani_podseznami (s):
    sez = []
    for i in range( len(s)):
        x = s.copy()
        sez.append(x)
        del s [0]
    sez.append([])
    return(sez)
# =====================================================================@021436=
# 4. podnaloga
# Sestavite funkcijo `najvecji_element`, ki vrne največji element seznama. Če
# je seznam prazen, naj funkcija vrne `None`.
# 
#     >>> najvecji_element([2, 4, 3, 1])
#     4
#     >>> najvecji_element([1, 4, 5, 5, 2, -10])
#     5
# =============================================================================
def najvecji_element (s):
    if len(s) > 0:
        s.sort()
        return s[-1]
    else:
        return None
# =====================================================================@021437=
# 5. podnaloga
# Sestavite funkcijo `zdruzi_sezname`, ki zdruzi seznam seznamov v en seznam,
# ki vsebuje vse elemente seznamov v podanem seznamu seznamov.
# 
#     >>> zdruzi_sezname([[1], [2, 3], [4, 5, 6]])
#     [1, 2, 3, 4, 5, 6]
#     >>> zdruzi_sezname([[], [0], [], [0], [], [7], []])
#     [0, 0, 7]
# =============================================================================
def zdruzi_sezname (s):
    x = []
    for i in range( len(s)):
        x += s[i]
    return(x)

# Primerjanje
#
# Pri reševanju nalog ne uporabljajte funkcij kot sta `min` in `max`.
# =====================================================================@021438=
# 1. podnaloga
# Definirajte funkcijo `vecji_element`, ki sprejme seznam in število ter kot
# rezultat vrne, ali seznam vsebuje število strogo večje od podanega.
# 
#     >>> vecji_element([3, 6, 2], 5)
#     True
#     >>> vecji_element([7, 5, 1], 8)
#     False
#     >>> vecji_element([3], 3)
#     False
# =============================================================================
def vecji_element(s, x):
    return any(element > x for element in s)
# =====================================================================@021439=
# 2. podnaloga
# Definirajte funkcijo `prvi_najvecji`, ki kot rezultat vrne `True`, če je prvi
# element seznama večji ali enak preostalim elementom seznama, in `False`
# sicer.
# 
#     >>> prvi_najvecji([5, 3, 6, 2])
#     False
#     >>> prvi_najvecji([8, 7, 5, 1])
#     True
# =============================================================================
def prvi_najvecji(s):
    if not s:
        return True
    x = s[0]
    for i in s[1:]:
        if i > x:
            return False
    return True
# =====================================================================@021440=
# 3. podnaloga
# Definirajte funkcijo `vsi_vecji(sez1, sez2)`, ki sprejme dva seznama, `sez1`
# in `sez2`, ter preveri ali je vsak element seznama `sez1` večji ali enak
# elementom seznama `sez2`.
# 
#     >>> vsi_vecji([2, 4], [1, 3])
#     False
#     >>> vsi_vecji([5, 8], [1, 2, 4])
#     True
# =============================================================================
def vsi_vecji(sez1, sez2):
    for element1 in sez1:
        for element2 in sez2:
             if element1 < element2:
                return False
    return True

# Praštevila, drugič
# =====================================================================@021441=
# 1. podnaloga
# Definirajte funkcijo `je_deljivo_s_katerim_od(n, seznam)`, ki vrne `True`
# natanko tedaj, ko je število `n` deljivo z vsaj kakšnim številom iz seznama
# števil `seznam`.
# 
#     >>> je_deljivo_s_katerim_od(20, [3, 4, 6])
#     True
# =============================================================================
def je_deljivo_s_katerim_od(n, seznam):
    for element in seznam:
        if (n % element) == 0:
            return True
    return False
# =====================================================================@021442=
# 2. podnaloga
# Definirajte funkcijo `prastevila_do`, ki vrne seznam vseh praštevil, ki so
# manjša ali enaka podanemu številu.
# 
#     >>> prastevila_do(10)
#     [2, 3, 5, 7]
# =============================================================================
def je_pra(stevilo):
    if stevilo < 2:
        return False
    for i in range(2, int(stevilo**0.5) + 1):
        if stevilo % i == 0:
            return False
    return True

def prastevila_do(n):
    return [stevilo for stevilo in range(2, n + 1) if je_pra(stevilo)]
# =====================================================================@021443=
# 3. podnaloga
# Definirajte funkcijo `je_prastevilo`, ki vrne ali je število praštevilo.
# =============================================================================
def je_prastevilo(n):
    if n <= 1:
        return False
    else:
        prastevila = prastevila_do(round(n ** 0.5))
        return not je_deljivo_s_katerim_od(n, prastevila)

# Krogi
# =====================================================================@021449=
# 1. podnaloga
# Krog predstavimo s trojico `(x, y, r)`, kjer je `(x, y)` središče kroga in
# `r` njegov radij.
# 
# Sestavite funkcijo `v_uniji(x0, y0, krogi)`, ki vrne `True`, če točka
# `(x0, y0)` leži v vsaj enem krogu v seznamu `krogi`, in `False`
# sicer.
# =============================================================================
def v_uniji(x0, y0, krogi):
    for (x, y, r) in krogi:
        if (((x - x0)**2 + (y - y0)**2)**(1/2)) <= r:
            return True
    return False
# =====================================================================@021450=
# 2. podnaloga
# Sestavite funkcijo `v_preseku(x, y, krogi)`, ki vrne `True`, če točka
# `(x, y)` leži v vseh krogih v danem seznamu `krogi`, in `False`
# sicer.
# =============================================================================
def v_preseku(x, y, krogi):
    for (x0, y0, r) in krogi:
        if (((x - x0)**2 + (y - y0)**2)**(1/2)) > r:
            return False
    return True
# =====================================================================@021451=
# 3. podnaloga
# Sestavite funkcijo `pravokotnik(krogi)`, ki poišče najmanjši pravokotnik,
# ki vsebuje unijo vseh krogov iz danega seznama `krogi`. Pravokotnik
# naj vrne kot nabor `(x_min, y_min, x_max, y_max)`, torej najprej
# koordinati oglišča spodaj levo, nato pa koordinati oglišča zgoraj desno.
# 
# Predpostavite, da seznam vsebuje vsaj en krog.
# 
#     >>> pravokotnik([(0, 0, 1)]
#     (-1, -1, 1, 1)
# =============================================================================
def pravokotnik(krogi):
    x_min = 0
    y_min = 0
    x_max = 0
    y_max = 0
    for (x, y, r) in krogi:
        dx_min = x - r
        dy_min = y - r
        dx_max = x + r
        dy_max = y + r 
        if x_min > dx_min:
            x_min = dx_min
        if y_min > dy_min:
            y_min = dy_min
        if x_max < dx_max:
            x_max = dx_max
        if y_max < dy_max:
            y_max = dy_max  
    return (x_min, y_min, x_max, y_max)

# Preverimo urejanje
# =====================================================================@021963=
# 1. podnaloga
# Z namenom preverjanja različnih algoritmov za urejanje seznamov, si želite
# pripraviti zanimive testne primere. Ti bodo sestavljeni iz seznamov parov, 
# kjer druga komponenta pove, na katerem mestu mora stati par. 
# 
# Sestavite funkcijo `pripravi_primer`, ki sprejme dva seznama - seznam 
# elementov in seznam indeksov - ter iz njiju napravi testni primer. 
# 
#     >>> pripravi_primer(["c", "b", "d", "a"], [2, 1, 3, 0])
#     [('c', 2), ('b', 1), ('d', 3), ('a', 0)]
#     >>> pripravi_primer(['daj', 'cas', 'da', 5, 'zapeljem', 'mi', 'te', 'minut'],[3, 4, 5, 0, 7, 2, 6, 1])
#     [('daj', 3), ('cas', 4), ('da', 5), (5, 0), ('zapeljem', 7), ('mi', 2), ('te', 6), ('minut', 1)]
# =============================================================================
def pripravi_primer(sez1, sez2):
    sez3 = []
    for i in range(len(sez1)):
        x = sez1[i]
        y = sez2[i]
        sez3.append ((x, y))
    return sez3
# =====================================================================@021964=
# 2. podnaloga
# Svoje urejevalne algoritme ste uporabili na primerih in želite preveriti,
# ali delujejo pravilno. Sestavite funkcijo`pravilno_urejen`, ki pove, ali je
# seznam urejen skladno z zgornjim principom.
# 
# Namig: uporabite funkcijo `enumerate`
# 
#     >>> pravilno_urejen([('so', 5), ('vcasih', 6), ('stezice', 3), ('bile?', 7), ('tiste', 2), ('k', 4), ('Kje', 0), ('so', 1)])
#     False
#     >>> pravilno_urejen([('Kje', 0), ('so', 1), ('tiste', 2), ('stezice', 3), ('k', 4), ('so', 5), ('vcasih', 6), ('bile?', 7)])
#     True
#     >>> pravilno_urejen([('daj', 3), ('cas', 4), ('da', 5), (5, 0), ('zapeljem', 7), ('mi', 2), ('te', 6), ('minut', 1)])
#     False
#     >>> pravilno_urejen([(5, 0), ('minut', 1), ('mi', 2), ('daj', 3), ('cas', 4), ('da', 5), ('te', 6), ('zapeljem', 7)])
#     True
# =============================================================================
def pravilno_urejen(seznam):
    primerjava = 0
    for (x, y) in seznam:
        if y != primerjava:
            return False
        primerjava += 1
    return True

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
NIZI:
# Ogrevanje
# =====================================================================@039028=
# 1. podnaloga
# Nagajivi škrat je pokvaril zamike v funkciji `vsebuje_vprasaj` in premešal
# vrstice v funkciji `odstrani_presledke`. Popravite obe funkciji tako, da
# uspešno opravita vse teste.
# 
# *Funkciji sta že definirani v datoteki.*
# =============================================================================
def vsebuje_vprasaj(niz):
    for znak in niz:
        if znak == "?":
            return True
    return False

def odstrani_presledke(niz):
    nov_niz = ""
    for znak in niz:
        if znak == " ":
            pass
        else:
            nov_niz += znak
    return nov_niz
# =====================================================================@039029=
# 2. podnaloga
# Napišite funkcijo `vsebuje_niz_z_vprasajem`, ki sprejme seznam nizov ter
# preveri, ali v seznamu obstaja niz, ki vsebuje vprašaj.
# 
#     >>> vsebuje_niz_z_vprasajem(['Katera', 'riba', 'bi', 'pa', 'ne', 'more?'])
#     True
#     >>> vsebuje_niz_z_vprasajem(['Skuša'])
#     False
# =============================================================================
def vsebuje_niz_z_vprasajem(sez):
    for niz in sez:
        if vsebuje_vprasaj(niz):
            return True
    return False
# =====================================================================@039030=
# 3. podnaloga
# Sestavite funkcijo `zgolj_dolge_besede`, ki sprejme seznam nizov in število,
# ki predstavlja najmanjšo zahtevano dolžino niza, ter preveri, da so vsi nizi
# v seznamu primerne dolžine.
# 
#     >>> zgolj_dolge_besede(['Gandalf', 'Aragorn', 'Gimli', 'Legolas'], 5)
#     True
#     >>> zgolj_dolge_besede(['goblin', 'ork', 'zmaj', 'Balrog'], 5)
#     False
# =============================================================================
def zgolj_dolge_besede(sez, d):
    for beseda in sez:
        if len(beseda) < d:
            return False
    return True

# Delo z nizi
# =====================================================================@039023=
# 1. podnaloga
# Sestavite funkcijo `prezrcali`, ki vrne prezrcaljen niz.
# 
#     >>> prezrcali('abeceda')
#     'adeceba'
# =============================================================================
def prezrcali (beseda):
    nov_niz = '' # tako se navede prazen niz
    n = len(beseda) - 1
    while n >= 0: #ker je -1 je laho tudi 0!!!
        x = beseda[n]
        nov_niz += x
        n -= 1
    return nov_niz
# =====================================================================@039024=
# 2. podnaloga
# Sestavite funkcijo `je_palindrom`, ki preveri, če je niz palindrom.
# 
#     >>> je_palindrom('kajak')
#     True
# =============================================================================
def je_palindrom (beseda):
    nov_niz = ''
    n = len(beseda) - 1
    while n >= 0: 
        x = beseda[n]
        nov_niz += x
        n -= 1
    if nov_niz ==  beseda:
        return True
    else:
        return False
# =====================================================================@039025=
# 3. podnaloga
# Sestavite funkcijo `odstrani_presledke`, ki sprejme niz in vrne nov niz, ki
# ga dobimo, če iz podanega niza odstranimo vse presledke.
# 
#     >>> odstrani_presledke('Ni vsak dan nedelja')
#     'Nivsakdannedelja'
# =============================================================================
def odstrani_presledke (niz):
    nov_niz = ''
    presledek = ' '
    n = 0
    while n <= (len(niz) - 1): 
        x = niz[n]
        if x == presledek:
            n += 1
        else: 
            nov_niz += x
            n += 1
    return nov_niz
# =====================================================================@039026=
# 4. podnaloga
# Napišite funkcijo `odstrani_ponovljene_presledke`, ki sprejme niz in vrne nov
# niz, kjer večkratne ponovitve presledka zamenjamo z enojnim presledkom.
# 
#     >>> odstrani_ponovljene_presledke('  * -   *   - * ')
#     ' * - * - * '
# =============================================================================
def odstrani_ponovljene_presledke (niz):
    nov_niz = ''
    presledek = ' '
    n = 0
    while n <= (len(niz) - 1): 
        x = niz[n]
        if n == 0:
            nov_niz += x
            n += 1
        elif (niz[n - 1] + x) == '  ':
            n += 1
        else: 
            nov_niz += x
            n += 1
    return nov_niz
# =====================================================================@039027=
# 5. podnaloga
# Na zabavi ste uspeli dobiti telefonsko številko sošolke/sošolca, ki ste jo/ga
# pecali cel večer. Toda na poti domov vam je dež zbrisal nekaj cifer, zato ste
# vdrli v FMF bazo in pridobili seznam vseh telefonskih številk.
# 
# Napišite funkcijo `najdi_stevilko(vzorec, seznam)`, ki iz možnega seznama
# telefonskih številk vrne seznam tistih, ki ustrezajo vzorcu. Telefonske
# številke so podane kot nizi z 9 znaki iz števk `0`-`9`, vzorec pa vsebuje
# tudi znak `*`, ki pomeni, da te števke ne poznamo.
# 
# **Namig:** Napišite pomožno funkcijo, ki preveri ali številka ustreza vzorcu.
# 
#     >>> najdi_stevilko('05123***6', ['041890343', '051234446', '051342236'])
#     ['051234446']
#     >>> najdi_stevilko('0********', ['041890343', '051234446', '051342236'])
#     ['041890343', '051234446', '051342236']
#     >>> najdi_stevilko('0*1123*57', ['041123457', '071123456', '051123457'])
#     ['041123457', '051123457']
# =============================================================================
def stevilka_ustreza(vzorec, stevilka):
    for i in range(len(vzorec)):
        if not (vzorec[i] == stevilka[i] or vzorec[i] == '*'):
            return False
    return True

def najdi_stevilko(vzorec, seznam):
    mozne_stevilke = []
    for stevilka in seznam:
        if stevilka_ustreza(vzorec, stevilka):
            mozne_stevilke.append(stevilka)
    return mozne_stevilke

# Sprehod
# =====================================================================@039031=
# 1. podnaloga
# Sestavite funkcijo `celostevilski`, ki sprejme niz, ki
# predstavlja sprehod po celih številih, in vrne število, v katerem se
# sprehod konča.
# 
# Sprehod po celih številih se začne v številu 0, predstavimo pa ga z
# nizem, sestavljenim iz znakov `+` in `-`. Na ostale znake v nizu se
# ne oziramo.
# =============================================================================
def celostevilski (niz):
    vsota = 0
    for stevilo in niz:
        if stevilo == '+':
            vsota += 1
        elif stevilo == '-':
            vsota -= 1
    return vsota
# =====================================================================@039032=
# 2. podnaloga
# Napišite število, v katerem se konča sprehod:
# =============================================================================
42
# =====================================================================@039033=
# 3. podnaloga
# Sestavite funkcijo `ravninski`, ki sprejme niz, ki
# predstavlja zaporedje korakov v ravnini, in vrne točko, v kateri se
# sprehod konča.
# 
# Sprehod po ravnini se začne v izhodišču, predstavimo pa ga z nizem,
# sestavljenim iz črk `S`, `J`, `V` ali `Z`, odvisno od smeri
# (sever, jug, vzhod, zahod). Na ostale znake v nizu se ne oziramo.
# =============================================================================
def ravninski (niz):
    tocka = [0, 0]
    for crka in niz:
        if crka == 'S':
            tocka[1] += 1
        elif crka == 'J':
            tocka[1] -= 1
        elif crka == 'V':
            tocka[0] += 1
        elif crka == 'Z':
            tocka[0] -= 1
    return (tocka[0], tocka[1])
# =====================================================================@039034=
# 4. podnaloga
# Sestavite funkcijo `hitri(tek)`, ki sprejme niz, ki predstavlja
# zaporedje korakov in skokov v ravnini, in vrne točko, v kateri se
# tek konča.
# 
# Tek po ravnini se začne v izhodišču, predstavimo pa ga, tako kot
# sprehod, z nizem, sestavljenim iz črk `S`, `J`, `V` ali `Z`, odvisno
# od smeri (sever, jug, vzhod, zahod).
# 
# Poleg tega lahko tek vsebuje tudi števke od `1` do `9`, ki povedo,
# koliko dolg naj bo naslednji korak. Tako niz `5S` pomeni skok
# na sever, dolg 5 korakov. Privzamete lahko, da zaporednih števk v
# nizu ni, ter da se na ostale znake v nizu ne oziramo.
# =============================================================================
def hitri(tek):
    tocka = [0, 0]
    n = 1
    for crka in tek:
        if crka in '123456789':   # namesto if crka == '9' or crka == '8' or crka == '7' or crka == '6' or crka == '5' or crka == '4' or crka == '3' or crka == '2' or crka == '1': 
            n = int(crka)
        elif crka == 'S':
            tocka[1] += (n*1)
            n = 1 
        elif crka == 'J':
            tocka[1] -= (n*1)
            n = 1 
        elif crka == 'V':
            tocka[0] += (n*1)
            n = 1 
        elif crka == 'Z':
            tocka[0] -= (n*1)
            n = 1 
    return (tocka[0], tocka[1])

# Gnezdenje oklepajev
#
# Oklepaji so pravilno gnezdeni, če uklepaji in zaklepaji nastopajo v parih in
# število zaklepajev nikoli ne preseže števila uklepajev, ko jih štejemo od
# leve proti desni.
# =====================================================================@039035=
# 1. podnaloga
# Sestavite funkcijo `oklepaji`, ki bo preverila, ali so v nizu oklepaji
# pravilno gnezdeni. Na ostale znake naj se funkcija ne ozira.
# 
#     >>> oklepaji('(a + b)^2 = (((a^2) + 2ab) + b^2)')
#     True
#     >>> oklepaji('())(()')
#     False
# =============================================================================
def oklepaji(niz):
    '''Ali so oklepaji v nizu postavljeni pravilno'''
    oklepaji = 0  # koliko je več predklepajev kot zaklepajev
    for znak in niz:
        if znak == '(':
            oklepaji += 1
        elif znak == ')':
            oklepaji -= 1

        if oklepaji < 0:  # nikoli ne sme biti več zaklepajev
            return False

    return oklepaji == 0  # na koncu jih mora biti enako


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
DELO Z OBJEKTI:
# Ogrevanje
# =====================================================================@021478=
# 1. podnaloga
# Napišite funkcijo `poisci_zvezdico`, ki sprejme niz in vrne indeks, na
# katerem se zvezdica `*` prvič pojavi. Če zvezdice ni v nizu, naj funkcija
# vrne `None`.
# 
#     >>> poisci_zvezdico('Naj gre vse v *****!')
#     14
# =============================================================================
def poisci_zvezdico (niz):
    for znak in niz:
        if znak == '*':
            return niz.index(znak)
    return None
# =====================================================================@021479=
# 2. podnaloga
# Napišite funkcijo 'vse_crke_male', ki preveri, da niz ne vsebuje velikih črk.
# 
#     >>> vse_crke_male('Za spremembo ...')
#     False
#     >>> vse_crke_male('... je velika začetnica nezaželena!')
#     True
# =============================================================================
def vse_crke_male (niz):
    if niz.islower() == True:
        return True
    else:
        return False
# =====================================================================@021480=
# 3. podnaloga
# Napišite funkcijo `poudari_dolge_besede(sez, n)`, ki sprejme seznam nizov in
# vrne nov seznam, kjer so vse besede daljše od `n` napisane z velikimi črkami.
# 
#     >>> poudari_dolge_besede(['Nikjer', 'ni', 'krofov', 's', 'čokolado'], 5)
#     ['NIKJER', 'ni', 'KROFOV', 's', 'ČOKOLADO']
# =============================================================================
def poudari_dolge_besede(sez, n):
    nov_seznam = []
    for niz in sez:
        if len(niz) > n:
            nov_seznam.append(niz.upper())
        else:
            nov_seznam.append(niz)
    return nov_seznam
# =====================================================================@021481=
# 4. podnaloga
# Definirajte funkcijo `tisje_prosim`, ki v nizu vse velike črke spremeni v
# male in zamenja vse pojavitve klicaja s piko.
# 
#     >>> tisje_prosim('V moji juhi je PODGANA!')
#     'v moji juhi je podgana.'
# =============================================================================
def tisje_prosim (niz):
    nov_niz = ''
    for znak in niz:
        if znak == '!' or znak == '.':
            nov_niz += '.'
        elif znak.isupper() == True:
            nov_niz += znak.lower()
        else:
            nov_niz += znak
    return nov_niz

# Sklad oklepajev
#
# Oklepaji so pravilno gnezdeni, če oklepaji in zaklepaji nastopajo v parih in
# število zaklepajev nikoli ne preseže števila oklepajev, ko jih štejemo od
# leve proti desni.
# =====================================================================@021482=
# 1. podnaloga
# Sestavite funkcijo `naivna_resitev`, ki sprejme niz in zgolj preveri, da se
# število oklepajev `(`, `[`, ali `{` ujema s številom pripadajočih zaklepajev
# `)`, `]`, oziroma `}`.
# 
#     >>> naivna_resitev("()[](){}{}")
#     True
#     >>> naivna_resitev("([})")
#     False
# =============================================================================
def naivna_resitev(niz):
    if niz.count('(') == niz.count(')') and niz.count('[') == niz.count(']') and niz.count('{') == niz.count('}'):
        return True
    else:
        return False
# =====================================================================@021483=
# 2. podnaloga
# Sestavite funkcijo `gnezdeni_oklepaji`, ki bo preverila, ali so v danem nizu
# oklepaji pravilno gnezdeni. Pri tem upoštevajte, da `niz` lahko vsebuje poleg
# oklepajev `()` še para `{}` in `[]`. Na ostale znake naj se funkcija ne
# ozira.
# 
#     >>> gnezdeni_oklepaji('(a + b)^2 = ([{a^2} + 2ab] + b^2)')
#     True
#     >>> gnezdeni_oklepaji('(){]')
#     False
# 
# **Namig:** Pomagajte si s pomožnim seznamom, v katerega ob sprehodu po nizu
# dodajamo oziroma ostranjujemo oklepaje. Natančneje, ko vidimo oklepaj, ga
# dodamo v pomožen seznam, in ko vidimo zaklepaj, preverimo, ali se ujema z
# oklepajem na koncu seznama. V tem primeru zadnji element pomožnega seznama
# odstranimo. Na koncu mora biti pomožni seznam prazen.
# =============================================================================
def gnezdeni_oklepaji(niz):
    oklepaji = '({['
    zaklepaji = ')}]'
    seznam = []
    for znak in niz:
        if znak in oklepaji:
            seznam.append(znak)
        elif znak in zaklepaji:
            if seznam == []:
                return False
            elif seznam[-1] != oklepaji[zaklepaji.index(znak)]:
                return False
            else:
                seznam.pop()
    return seznam == []

# Ne obračaj mojih besed
# =====================================================================@021484=
# 1. podnaloga
# Vaš sosed, svetovno priznani pisatelj, vam je potacal gredico s petunijami.
# Odločeni, da mu otežite življenje s spreminjanjem njegovih zapiskov, ste se
# spravili k pisanju funkcije `obrni_vrstni_red`. Funkcija sprejme niz
# (sestavljen zgolj iz črk in presledkov) in v njem obrne vrstni red besed.
# 
#     >>> obrni_vrstni_red('kdor drugemu jamo koplje ne pade daleč od drevesa')
#     'drevesa od daleč pade ne koplje jamo drugemu kdor'
# =============================================================================
def obrni_vrstni_red(niz):
    return ' '.join(niz.split()[::-1]) # [::-1] pomeni, da obrne; ' '.join - združi z vmesnim presledkom
# =====================================================================@021485=
# 2. podnaloga
# Vaš sosed je na žalost navdušen bralec japonskih stripov, zato mu branje od
# desne proti levi ni tuje. Odločeni ste, da bo plačal za prerano smrt vaših
# petunij, zato sestavite funkcijo `obrni_besede`, ki sprejme niz in v njem
# obrne vrstni red črk v posameznih besedah (vrstni red besed se ne spremeni).
# 
#     >>> obrni_besede('palindromom kot je kajak ta funkcija ne naredi nič')
#     'momordnilap tok ej kajak at ajicknuf en ideran čin'
# =============================================================================
def obrni_besede (niz):
    return obrni_vrstni_red(niz[::-1]) # najprej obrnemo vse niz, nato pa po delih
# =====================================================================@021486=
# 3. podnaloga
# Ves vaš trud je sosedu zgolj izboljšal bralne sposobnosti! Vendar vas spomin
# na tragedijo petunij preganja v nočnih morah. Sestavite funkcijo
# `sosed_naj_trpi`, ki v nizu obrne vrstni red črk, presledke pa ohrani na
# istih mestih.
# 
#     >>> sosed_naj_trpi('petunije so si zaslužile lepši konec')
#     'cenokišp el el ižulsazis oseji nutep'
# 
# Namig: Zapomnite si pozicije presledkov preden obrnete vrstni red črk.
# =============================================================================
def sosed_naj_trpi(niz):
    nov_niz = ''
    presledki = []
    # Zapomnimo si mesta presledkov in jih poberemo iz niza
    for i, znak in enumerate(niz): # iteriraš čez elemente nekega zaporedja (npr. seznama, niza ipd.) in hkrati dobiš tudi indeks vsakega elementa
        if znak == ' ':
            presledki.append(i)
        else:
            nov_niz += znak
    # Niz obrnemo
    nov_niz = nov_niz[::-1]
    # Ponovno vstavimo presledke (od leve proti desni, da bodo indeksi pravi)
    for i in presledki:
        nov_niz = nov_niz[:i] + ' ' + nov_niz[i:]

    return nov_niz

# Ali sva za skupaj?
#
# Dolgoletne raziskave partnerskih odnosov kažejo, da je najboljši pokazatelj
# uspešnosti in dolgotrajnosti zveze število, ki ga izračunamo po spodnjem
# postopku. Najprej za vsako črko v besedi LOVES preštejemo število njenih
# pojavitev v imenih obeh partnerjev, s čimer dobimo petmestno število. Nato
# v tem številu seštejemo po dve sosednji števki in tako dobimo novo število.
# Ta postopek ponavljamo, dokler nam ne ostaneta le dve števki, ki nam povesta
# odstotek uspešnosti zveze. Poglejmo si primer za Julijo Primic in Franceta
# Prešerna. Najprej preštejemo število pojavitev črk LOVES:
# 
#            Julija Primic    France Prešeren
#     L: 1     *
#     O: 0
#     V: 0
#     E: 4                         *   * * *
#     S: 0
# 
# Nato postopoma računamo vsoto dveh sosednjih števk:
# 
#     1   0   0   4   0
#       1   0   4   4
#         1   4   8
#           5   12  (kar pišemo kot)
#         5   1   2
#           6   3
# 
# Možnosti je torej 63%. Nekateri znanstveniki (predvsem v svetu z bolj
# germansko kulturo) zagovarjajo alternativen pristop, v katerem je treba začeti
# s črkami v besedi ŠANSE. V tem primeru za naša zaljubljenca po podobnem
# postopku dobimo 87%.
# =====================================================================@021487=
# 1. podnaloga
# Sestavite funkcijo `razbij_na_stevke(stevilo)`, ki vrne števke danega
# števila:
# 
#     >>> razbij_na_stevke(12382)
#     [1, 2, 3, 8, 2]
#     >>> razbij_na_stevke(6)
#     [6]
# =============================================================================
def razbij_na_stevke(stevilo):
    sez = []
    for stevka in str(stevilo): #str - pretvori v niz
        sez.append(int(stevka)) #int - pretvori v število; append - zdaj jih posamezno deljene vpisujemo
    return sez


# =====================================================================@021488=
# 2. podnaloga
# Sestavite funkcijo `prestej_crke(geslo, niz)`, ki vrne seznam pojavitev črk
# niza `geslo` v danem nizu `niz`. Pri tem naj se ne ozira na male ali velike
# črke (pomagajte si z metodo `upper`):
# 
#     >>> prestej_crke('LOVES', 'france')
#     [0, 0, 0, 1, 0]
#     >>> prestej_crke('ŠANSE', 'prešeren')
#     [1, 0, 1, 0, 3]
# =============================================================================
def prestej_crke(geslo, niz):
    sez = []
    niz = niz.upper() # ker iščemo podobmost velikih črk
    for znak in geslo.upper(): # za vsak znak iz gesla
        sez.append(niz.count(znak)) #prešteje ponovitev v nizu in zapiše št. v seznam
    return sez


# =====================================================================@021489=
# 3. podnaloga
# Sestavite funkcijo `sestej_stevke(stevke)`, ki vrne seznam števk, ki ga
# dobimo, ko seštejemo sosednje števke v seznamu `stevke`. Če je vsota dveh
# sosednjih števk dvomestno število, v vrnjeni seznam dodate dve števki.
# Na primer:
# 
#     >>> sestej_stevke([1, 0, 4, 4])
#     [1, 4, 8]
#     >>> sestej_stevke([1, 4, 8])
#     [5, 1, 2]
#     >>> sestej_stevke([5, 1, 2])
#     [6, 3]
# =============================================================================
def sestej_stevke(stevke):
    nove_stevke = []
    for i in range(1, len(stevke)):
        nove_stevke.extend(razbij_na_stevke(stevke[i - 1] + stevke[i])) # pretvori število v int
    return nove_stevke


# =====================================================================@021490=
# 4. podnaloga
# Sestavite funkcijo `ujemanje(oseba1, oseba2, geslo)`, ki po zgoraj opisanem
# postopku izračuna odstotek uspešnosti zveze med osebama z imenoma `oseba1`
# in `oseba2`. Argument `geslo` naj ima privzeto vrednost `'LOVES'`.
# 
#     >>> ujemanje('Julija Primic', 'France Prešeren', geslo='LOVES')
#     63
#     >>> ujemanje('Julija Primic', 'France Prešeren')
#     63
#     >>> ujemanje('Julija Primic', 'France Prešeren', geslo='ŠANSE')
#     87
# =============================================================================
def ujemanje(oseba1, oseba2, geslo='LOVES'): #PRIVZETA VREDNOST: `geslo` naj ima privzeto vrednost `'LOVES'
    sk_ime = oseba1 + oseba2 # ker sta niza ju lahko seštejemo
    crke = prestej_crke(geslo, sk_ime) 
    while len(crke) > 2: # ponavlja dokler dolžina niza ni manjša od 2
        crke = sestej_stevke(crke) # ista spremenljivka, da loop
    return (10 * crke[0] + crke [1])

# Permutacije
#
# Permutacijo običajno predstavimo s seznamom slik posameznih elementov,
# npr. [5, 1, 6, 4, 2, 3], lahko pa tudi s seznamom disjunktnih ciklov, npr.
# [[1, 5, 2], [3, 6], [4]]. Ciklov dolžine 1 (fiksnih točk) običajno ne
# navajamo, a moramo v tem primeru navesti še velikost permutacije
# (v tem primeru 6).
# =====================================================================@021491=
# 1. podnaloga
# Sestavite funkcijo `je_permutacija`, ki sprejme seznam in preveri,
# ali je v njem zapisana permutacija v običajnem zapisu. V seznamu je zapisana
# permutacija, če se vsak element od $1$ do $n$, kjer je $n$ dolžina
# permutacije, pojavi natanko enkrat.
# 
#     >>> je_permutacija([7, 3, 4, 5, 2, 1])
#     False
#     >>> je_permutacija([7, 3, 4, 5, 2, 6, 1])
#     True
# =============================================================================
def je_permutacija (sez):
    for i in range (len(sez)): # len da števila od 0 do n-1 in po teh gredo, ker naraščajo
        if sez.count (i + 1) != 1: # i+1 ker moramo ta št. povečati za 1, da jih pregledujemo
            return False
    return True


# =====================================================================@021492=
# 2. podnaloga
# Sestavite funkcijo `je_seznam_ciklov`, ki sprejme seznam seznamov in preveri,
# ali vsebuje disjunktne cikle neke permutacije. Preveriti je torej treba,
# ali so vsi elementi pozitivni ter ali se vsak element v stiku vseh ciklov
# pojavi natanko enkrat.
# 
#     >>> je_seznam_ciklov([[8,3,4],[5,7,1]])
#     True
#     >>> je_seznam_ciklov([[8,1,4],[5,7,1]])
#     False
# =============================================================================
def je_seznam_ciklov (sez):
    sk_sez = []
    for podsez in sez:
        sk_sez += podsez
    for i in sk_sez:
        if sk_sez.count(i) > 1:
            return False
        elif i <= 0:
            return False
    return True



# =====================================================================@021493=
# 3. podnaloga
# Sestavite funkcijo `urejeni_cikli`, ki seznam ciklov pretvori v nov seznam
# tako, da je najmanjši element posameznega cikla vedno na začetku cikla,
# cikli v seznamu pa so urejeni po velikosti prvih elementov. Morebitne prazne
# cikle in cikle dolžine 1 naj odstrani.
# 
#     >>> urejeni_cikli([[7, 3], [4], [5, 2, 1], [8, 2, 14]])
#     [[1, 5, 2], [3, 7], [2, 14, 8]]
# =============================================================================
def urejeni_cikli(cikli):
    sez = []
    for cikel in cikli:
        if len(cikel) > 1: #preveri dolžino
            najmanjsi = cikel.index(min(cikel)) # poiščem najmanjši element in njegov indeks
            sez.append(cikel[najmanjsi:] + cikel[:najmanjsi]) # razdeliš na še dva pod in urediš, da se začne z najmanjšo št.
    sez.sort() # sortira sezname po prvem elementu
    return sez

#def urejeni_cikli(sez):
    n_sez= []
    for podsez in sez:
        if len(podsez) > 1:
            najmanjsi= podsez.index(min(podsez))
            n_sez.append(podsez[najmanjsi:] + podsez[:najmanjsi])
        n_sez.sort()
        return n_sez


# =====================================================================@021494=
# 4. podnaloga
# Sestavite funkcijo `iz_ciklov(cikli, dolzina)`, ki iz seznama ciklov `cikli`
# sestavi običajen zapis permutacije dolzine `dolzina`. Če parametra `dolzina`
# ne podamo, ali pa je ta premajhna, naj bo dolžina enaka največjemu elementu,
# ki se pojavi v ciklih.
# 
#     >>> iz_ciklov([[7, 3], [4], [5, 2, 1]])
#     [5, 1, 7, 4, 2, 6, 3]
#     >>> iz_ciklov([[7, 3], [4], [5, 2, 1]], 9)
#     [5, 1, 7, 4, 2, 6, 3, 8, 9]
# =============================================================================
def iz_ciklov(cikli, dolzina=0): #Če parametra `dolzina`ne podamo enaka največjemu elementu
    for cikel in cikli:
        dolzina = max(dolzina, max(cikel)) # določimo dolžino
    perm = list(range(1, dolzina + 1))
    for cikel in cikli:
        for i in range(1, len(cikel)):
            perm[cikel[i - 1] - 1] = cikel[i]
        perm[cikel[-1] - 1] = cikel[0]
    return perm


# =====================================================================@021495=
# 5. podnaloga
# Sestavite funkcijo `v_cikle`, ki iz permutacije sestavi njeno predstavitev s
# cikli.
# 
#     >>> v_cikle([5, 1, 7, 4, 2, 6, 3])
#     [[1, 5, 2], [3, 7]]
# =============================================================================
def v_cikle(perm):
    cikli = []
    pregledani = []
    for i in range(1, len(perm) + 1):
        j = i
        cikel = []
        while j not in pregledani:
            pregledani.append(j)
            cikel.append(j)
            j = perm[j - 1]
        if len(cikel) > 1:
            cikli.append(cikel)
    return cikli


# =====================================================================@021496=
# 6. podnaloga
# Sestavite funkcijo `inverz_perm`, ki sestavi in vrne inverz dane permutacije
# v običajni predstavitvi.
# 
#     >>> inverz_perm([7, 3, 4, 5, 2, 1, 6])
#     [6, 5, 2, 3, 4, 7, 1]
# =============================================================================
def inverz_perm(perm):
    n = len(perm)
    inverz = [0] * n
    for i in range(n):
        inverz[perm[i] - 1] = i + 1
    return inverz


# =====================================================================@021497=
# 7. podnaloga
# Sestavite funkcijo `inverz_cikli`, ki sestavi in vrne inverz dane
# permutacije, predstavljene s seznamom ciklov. Inverz permutacije dobimo tako,
# da v cikličnem zapisu obrnemo vse cikle (vsakega posebej).
# 
#     >>> inverz_cikli([[7, 3], [4], [5, 2, 1]])
#     [[1, 2, 5], [3, 7]]
# =============================================================================
def urejeni_cikli(cikli):
    sez = []
    for cikel in cikli:
        if len(cikel) > 1: #preveri dolžino
            najmanjsi = cikel.index(min(cikel)) # poiščem najmanjši element in njegov indeks
            sez.append(cikel[najmanjsi:] + cikel[:najmanjsi]) # razdeliš na še dva pod in urediš, da se začne z najmanjšo št.
    sez.sort() # sortira sezname po prvem elementu
    return sez

def inverz_cikli(cikli):
    inverz = []
    for cikel in cikli:
        inverz.append(cikel[::-1]) # odbnevsak cikel iz ciklov
    return urejeni_cikli(inverz) # uredi cikle po naraščanju


# =====================================================================@021498=
# 8. podnaloga
# Sestavite funkcijo `ciklicni_tip(cikli, dolzina)`, ki vrne ciklični tip
# permutacije dolžine `dolzina`, predstavljene s seznamom ciklov `cikli`.
# To je nabor, ki ima toliko elementov, kot je dolžina najdaljšega cikla.
# Prvi element v tem naboru je število ciklov dolžine 1, drugi element je
# število ciklov dolžine 2, itd. Če parametra `dolzina` ne podamo, ali pa
# je ta premajhna, naj bo dolžina enaka največjemu elementu, ki se pojavi
# v ciklih.
# 
#     >>> ciklicni_tip([[7, 3], [4], [5, 2, 1]])
#     (2, 1, 1)
#     >>> ciklicni_tip([[7, 3], [4], [5, 2, 1]], 9)
#     (4, 1, 1)
# =============================================================================
def ciklicni_tip(cikli, dolzina=0):
    for cikel in cikli:
        dolzina = max(dolzina, max(cikel))
    dolzine = []
    for cikel in cikli:
        dolzine.append(len(cikel))
    najdaljsi_cikel = max(dolzine)
    tip = []
    for i in range(1, najdaljsi_cikel + 1):
        tip.append(dolzine.count(i))
    tip[0] += dolzina - sum(dolzine)
    return tuple(tip)


# =====================================================================@021499=
# 9. podnaloga
# Sestavite funkcijo `red`, ki izračuna in vrne red permutacije podane s cikli.
# Naj bo $\pi$ permutacija. Red permutacije $\pi$ je najmanjše pozitivno
# število $k$, pri katerem je $\pi^k$ identiteta.
# 
# Namig 1: Red permutacije je najmanjši skupni večkratnik dolžin vseh ciklov.
# 
# Namig 2: Za poljubni dve naravni števili `a` in `b` velja, da je
# `gcd(a, b) * lcm(a, b) == a * b`. (Funkcija `gcd` računa največji
# skupni delitelj, funkcija `lcm` pa najmanjši skupni večkratnik.)
# 
#     >>> red([[7, 3], [4], [5, 2, 1]])
#     6
# =============================================================================
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def red(cikli):
    r = 1
    for cikel in cikli:
        r = lcm(r, len(cikel))
    return r


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SLOVARJI:
# Ogrevanje na družinskem pikniku
#
# Na tradicionalni družinski piknik  vsako leto prinesete sladice. Ker pa so
# člani razširjene družine zelo izbirčni, si že leta skrbno beležite, katere
# sladice najraje jedo. Tako imate spravljen slovar, ki vsakemu članu pristavi
# njegovo najljubšo sladico, npr.
# 
#     sladkosnedi= {"mami" : "vanilijev sladoled", "ati" : "puding",
#                       "babi Minka" : "prekmurska gibanica",
#                       "stric Franc" : "panacota", "teta Eli" : "magdalence",
#                       "sestra Katarina" : "jagodna torta"}
# =====================================================================@021500=
# 1. podnaloga
# Sestavite funkcijo `druzinski_clani`, ki sprejme slovar sladkosnedov in vrne
# seznam družinskih članov.
# 
#     >>> druzinski_clani({"mami": "pita", "ati": "torta"})
#     ['mami', 'ati']
# =============================================================================
def druzinski_clani (sladkosnedi):
    return list(sladkosnedi.keys())
# =====================================================================@021501=
# 2. podnaloga
# Vaša boljša polovica si je izpogajala, da bo na tokratni družinski piknik
# povabljena tudi njihova družina.
# 
# Sestavite funkcijo `zdruzi_sladkosnede(domaci, njihovi)`, ki združi slovarja
# vaših in njihovih sladkosnedov. Če se kakšno ime pojavi v obeh slovarjih, naj
# v združenem slovarju nastopa član vaše družine.
# 
#     >>> zdruzi_sladkosnede({"mami": "pita", "ati": "torta"},
#                            {"brat Jan": "cokolada", "mami": "piskoti"})
#     {'mami': 'pita', 'ati': 'torta', 'brat Jan': 'cokolada'}
# =============================================================================
def zdruzi_sladkosnede(domaci, njihovi):
    skupno = domaci
    for kljuc in njihovi.keys():
        if kljuc not in domaci.keys():
            skupno[kljuc] = njihovi [kljuc]
    return skupno

def zdruzi_sladkosnede(domaci, njihovi):
    njihovi.update(domaci)
    return njihovi
# =====================================================================@021502=
# 3. podnaloga
# Od babice Minke ste dobili seznam gostov, ki so potrdili udeležbo na pikniku. 
# 
# Sestavite funkcijo `nakupovalni_seznam`, ki sprejme slovar sladkosnedov in
# seznam gostov, ki so udeležbo potrdili, ter vrne slovar sladic s
# pripadajočimi količinami, ki jih je potrebno kupiti. Pazite na to, da ne
# veste najljubših sladic od vseh povabljenih gostov.
# 
#     >>> nakupovalni_seznam({"mami": "pita", "ati": "torta"}, ["mami", "brat"])
#     {'pita': 1}
# =============================================================================
def nakupovalni_seznam(sladkosnedi, gosti):
    slovar = dict()
    for gost in gosti:
        if gost in sladkosnedi.keys():
            sladica = sladkosnedi[gost]
            slovar [sladica] = slovar.get(sladica, 0) + 1
    return slovar

# Kuhamo in pečemo
#
# Sestavine, ki jih potrebujemo za nek recept, opišemo s slovarjem, v katerem
# so ključi sestavine, vrednosti pa količine, ki jih potrebujemo.
# =====================================================================@021503=
# 1. podnaloga
# Sestavite funkcijo `pomnozi`, ki sprejme recept in celoštevilski faktor in
# sestavi nov recept. Ta naj vsebuje iste sestavine kot podani recept le da so
# vse količine v njem pomnožene z danim faktorjem.
# 
#     >>> pomnozi({'jajca': 4, 'moka': 500}, 2)
#     {'jajca': 8, 'moka': 1000}
# =============================================================================
def pomnozi (recept, stevilo):
    nov_recept = recept
    for sestavina in recept:
        nov_recept [sestavina] = nov_recept.get(sestavina, 0) * stevilo
    return nov_recept
# =====================================================================@021504=
# 2. podnaloga
# Sestavite funkcijo `ali_imamo_sestavine(recept, shramba)`, ki preveri, ali
# imamo v shrambi dovolj sestavin za dani recept. Sestavine, ki jih imamo v
# shrambi, so predstavljene s slovarjem na enak način kot sestavine v receptu.
# 
#     >>> ali_imamo_sestavine({'jajca': 3, 'moka': 500}, {'moka': 1000, 'jajca': 6, 'sladkor': 1000})
#     True
#     >>> ali_imamo_sestavine({'jajca': 3, 'moka': 500}, {'moka': 1000, 'sladkor': 1000})
#     False
# =============================================================================
def ali_imamo_sestavine(recept, shramba):
    for sestavina in recept:
        if sestavina in shramba.keys():
                if recept.get(sestavina, 0) > shramba.get(sestavina, 0):
                    return False
        else:
            return False
    return True



def ali_imamo_sestavine(recept, shramba):
    for sestavina in recept:
        if sestavina in shramba.keys():
            if recept.get(sestavina, 0) < shramba.get(sestavina, 0):
                continue
        return False
    return True
# =====================================================================@021505=
# 3. podnaloga
# Sestavite funkcijo `kaj_moramo_se_kupiti(recept, shramba)`, ki vrne slovar
# sestavin s pripadajočimi količinami, ki jih moramo še dokupiti, da bomo lahko
# skuhali jed po danem receptu.
# 
#     >>> kaj_moramo_se_kupiti({'jajca': 3, 'moka': 500}, {'moka': 1000, 'jajca': 6, 'sladkor': 1000})
#     {}
#     >>> kaj_moramo_se_kupiti({'jajca': 3, 'moka': 500}, {'moka': 1000, 'sladkor': 1000})
#     {'jajca': 3}
#     >>> kaj_moramo_se_kupiti({'jajca': 3, 'moka': 500}, {'moka': 100})
#     {'jajca': 3, 'moka': 400}
# =============================================================================
def kaj_moramo_se_kupiti(recept, shramba):
    nakup = dict()
    for sestavina, kolicina in recept.items():
        if shramba.get(sestavina, 0) < kolicina: # ni treba še nekrat preverjati ali je sesetavina sploh v shrambi,saj pri .get privzamemo vrednost 0, če te ni
                nakup[sestavina] = kolicina - shramba.get(sestavina, 0)
    return nakup

# Šifriranje
#
# Substitucijska šifra je enostaven način šifriranja, pri katerem vsako črko iz
# dane abecede zamenjamo z neko drugo črko. Tako šifro predstavimo s slovarjem,
# ki ima za ključe vse črke iz abecede, pripadajoče vrednosti pa so črke, s
# katerimi jih zašifriramo.
# 
# Tako slovar `{'A': 'B', 'C': 'C', 'B': 'D', 'D': 'A'}` pomeni, da se `A`
# zašifrira v `B`, `B` v `D`, `D` v `A`, `C` pa se ne spremeni.
# 
# V vseh testnih primerih bomo uporabljali naslednjo substitucijsko šifro:
# 
#     nasa_sifra = {'Č': 'K', 'A': 'O', 'C': 'Z', 'B': 'M', 'E': 'V',
#                   'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F',
#                   'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R',
#                   'N': 'Š', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G',
#                   'T': 'Č', 'V': 'N', 'Z': 'Ž', 'Š': 'S', 'Ž': 'D'}
# =====================================================================@021506=
# 1. podnaloga
# Sestavite funkcijo `sifriraj`, ki sprejme šifro in besedo in vrne rezultat
# šifriranja. Predpostavite lahko, da vse črke v besedi nastopajo v šifri.
# 
#     >>> sifriraj(nasa_sifra, 'MATEMATIK')
#     'UOČVUOČBI'
# =============================================================================
def sifriraj(nasa_sifra, beseda):
    nova_beseda = []
    for i in beseda:
        nova_crka = nasa_sifra.get(i, 0)
        nova_beseda += nova_crka
    return ''.join(nova_beseda)

# =====================================================================@021507=
# 2. podnaloga
# Sestavite funkcijo `ali_je_sifra`, ki ugotovi, ali dani slovar predstavlja
# šifro, torej ali je bijekcija črk na neki abecedi.
# 
#     >>> ali_je_sifra({'A': 'B', 'B': 'A'})
#     True
#     >>> ali_je_sifra({'A': 'B', 'B': 'C'})
#     False
# =============================================================================
def ali_je_sifra(slovar):
    # Pogledamo, če je množica ključev slovarja enaka množici vrednosti. Ker so
    # ključi v slovarju enolični, je velikost množice ključev enaka kar številu
    # črk v abecedi. Če sta torej množici ključev in vrednosti enaki, je slovar
    # surjektiven in s tem tudi injektiven. (oba morata imeti enake elemente)
    return set(slovar.keys()) == set(slovar.values())


#def ali_je_sifra(slovar):
    kljuci= list(slovar.keys())
    crke = list(slovar.values())
    for i in kljuci:
        if i in crke:
            continue
    return True
    


    for kljuc in slovar.keys():
        for crka in slovar.values():
            if crka == kljuc:
                continue
        return False
    return True        
    
    return len(slovar.values()) == len(set(slovar.values()))



# =====================================================================@021508=
# 3. podnaloga
# Sestavite funkcijo `inverz`, ki vrne inverz dane šifre, če ta obstaja. V
# nasprotnem primeru funkcija vrne `None`.
# 
#     >>> inverz({'A': 'B', 'B': 'C', 'C': 'A'})
#     {'A': 'C', 'B': 'A', 'C': 'B'}
# =============================================================================
def inverz(sifra):
    if not ali_je_sifra(sifra):
        return None
    inv = {} 
    for k, v in sifra.items(): # obravnavamo za 2 elementa (par) takoj, lazje menjati !
        inv[v] = k
    return inv

#def inverz(sifra):
    nova_sifra = dict()
    kljuci= list(sifra.keys())
    crke = list(sifra.values())  
    for i in range(0, len(crke)):
        nova_sifra[crke[i]] = kljuci[i]
    return nova_sifra



# =====================================================================@021509=
# 4. podnaloga
# Sestavite funkcijo `odsifriraj`, ki sprejme šifro in zašifrirano besedilo,
# vrne pa odšifrirano besedilo. Če slovar ni bijekcija (in se torej besedilo ne
# da nujno odšifrirati), naj funkcija vrne `None`.
# 
#     >>> odsifriraj(nasa_sifra, 'MVCOI')
#     'BEDAK'
# =============================================================================
def odsifriraj(nasa_sifra, beseda):
    if len(nasa_sifra.values()) != len(set(nasa_sifra.values())): # Preverimo, ali je šifra bijekcija (vse vrednosti morajo biti edinstvene)
        return None #primerjaš lahko samo set, ker gre za množico

    inverzna_sifra = {vrednost: kljuc for kljuc, vrednost in nasa_sifra.items()}     # Zgradimo inverz šifre V nov slovar damo: vrednost kot ključ; ključ kot vrednost. Torej zamenjamo vloge ključa in vrednosti.

    nova_beseda = []     # Odšifriraj besedo
    for i in beseda:
        nova_crka = inverzna_sifra.get(i, None)
        if nova_crka is None:
            return None  # Če se črka ne najde v inverzni šifri, vrnemo None
        nova_beseda.append(nova_crka)
    return ''.join(nova_beseda)


#def odsifriraj(sifra, beseda): (ali ždružena funkcija)
    inv = inverz(sifra)
    if inv:
        return sifriraj(inv, beseda)
    else:
        return


# Permutacije
#
# V slovarju imamo shranjeno permutacijo naravnih števil od $1$ do $n$.
# Permutacijo, ki slika $1$ v $3$, $3$ v $1$, število $2$ pa pusti pri miru,
# torej zapišemo s slovarjem `{1: 3, 2: 2, 3: 1}`.
# =====================================================================@021510=
# 1. podnaloga
# Sestavite funkcijo `slika(permutacija, x)`, ki vrne sliko števila `x`
# s podano permutacijo.
# 
#     >>> slika({1: 3, 2: 4, 3: 2, 4: 1}, 1)
#     3
# =============================================================================
def slika(permutacija, x):
    return permutacija.get(x, None)


#def slika(permutacija, x):
    for i in permutacija.keys():
        if i == x:
            return permutacija.get(i, None)



# =====================================================================@021511=
# 2. podnaloga
# Sestavite funkcijo `slike(permutacija, x, n)`, ki vrne zaporedje slik, ki ga
# dobimo, če začnemo s številom `x` in na njem `n`-krat uporabimo permutacijo.
# 
#     >>> slike({1: 3, 2: 4, 3: 2, 4: 1}, 1, 2)
#     [1, 3, 2]
# =============================================================================
def slike(permutacija, x, n):
    rezultati = [x]  # Seznam za shranjevanje rezultatov, začnemo s številom x
    for ponovitev in range(n):
        x = permutacija[x]  # Uporabimo permutacijo na trenutni vrednosti x
        rezultati.append(x)  # Dodamo rezultat v seznam
    return rezultati    



# =====================================================================@021512=
# 3. podnaloga
# Sestavite funkcijo `cikel(permutacija, x)`, ki vrne celoten cikel, ki se
# začne s številom `x`.
# 
#     >>> cikel({1: 3, 2: 2, 3: 1}, 1)
#     [1, 3]
#     >>> cikel({1: 3, 2: 2, 3: 1}, 2)
#     [2]
# =============================================================================
def cikel(permutacija, x):
    rezultati = [x]
    stevilo = permutacija[x]
    while stevilo != x:
        rezultati.append(stevilo)
        stevilo = permutacija[stevilo]
    return rezultati 

    while True:
        stevilo = permutacija[stevilo]
        if stevilo == x:  # Ko pridemo nazaj do začetnega števila, končamo cikel
            break
        rezultati.append(stevilo)
    
    return rezultati



# =====================================================================@021513=
# 4. podnaloga
# Sestavite funkcijo `cikli`, ki vrne seznam disjunktnih ciklov dane
# permutacije. Vsak cikel naj se začne z najmanjšim številom v ciklu, cikli pa
# naj bodo urejeni po začetnem številu.
# 
#     >>> cikli({1: 3, 2: 2, 3: 1})
#     [[1, 3], [2]]
# =============================================================================
def cikli(permutacija):
    # V seznam cikli si shranjujemo do sedaj izračunane cikle, v množico
    # ugotovljena pa vsa tista števila, za katera smo že ugotovili, kateremu
    # ciklu pripadajo.
    cikli = []
    ugotovljena = set()
    # Nato gremo zaporedoma čez vsa števila od 1 do n. Če za neko število še
    # nismo ugotovili, kam spada, je najmanjše v svojem ciklu. Zato izračunamo
    # njegov cikel, ga dodamo k ciklom, vsa števila iz cikla pa dodamo med
    # ugotovljena.
    for i in range(1, len(permutacija) + 1):
        if i not in ugotovljena:
            c = cikel(permutacija, i)
            cikli.append(c)
            ugotovljena.update(c)
    return cikli


# =====================================================================@021514=
# 5. podnaloga
# Sestavite funkcijo `je_permutacija`, ki vrne `True`, če dani slovar
# predstavlja permutacijo, in `False` sicer.
# 
#     >>> je_permutacija({1: 2, 2: 1})
#     True
#     >>> je_permutacija({1: 3, 2: 4})
#     False
# =============================================================================
def je_permutacija(slovar):
    domena = set(slovar.keys())
    slika = set(slovar.values())
    return domena == slika == set(range(1, len(slovar) + 1)) #preveri, če se dolžina IN vsi vmesni elementi notri

# Ljubezen nam je vsem v pogubo
#
# Socialno omrežje zaljubljenosti podamo s slovarjem, ki ime osebe preslika v
# množico vseh, v katere je oseba zaljubljena (ena oseba je lahko zaljubljena v
# več oseb). Na primer, slovar
# 
#     {
#         'Ana': {'Bine', 'Cene'},
#         'Bine': set(),
#         'Cene': {'Bine'},
#         'Davorka': {'Davorka'},
#         'Eva': {'Bine'}
#     }
# 
# nam pove, da je Ana zaljubljena v Bineta in Ceneta, Bine ni zaljubljen, Cene
# ljubi Bineta, Davorka samo sebe in Eva Bineta.
# =====================================================================@021515=
# 1. podnaloga
# Sestavite funkcijo `narcisoidi`, ki sprejme slovar zaljubljenih in vrne
# _množico_ tistih, ki ljubijo same sebe.
# =============================================================================
def narcisoidi(slovar_zaljubljenih):
    narcisi = []
    for oseba in slovar_zaljubljenih.keys():
        if oseba in slovar_zaljubljenih.get(oseba, None):
            narcisi.append(oseba)
        else:
            continue
    return narcisi



# =====================================================================@021516=
# 2. podnaloga
# Sestavite funkcijo `ljubljeni`, ki sprejme slovar zaljubljenih in vrne
# _množico_ tistih, ki so ljubljeni.
# =============================================================================
def ljubljeni(slovar_zaljubljenih):
    ljubljeni = set() 
    for oseba in slovar_zaljubljenih.values(): 
        ljubljeni.update(oseba) 
    return ljubljeni

# =====================================================================@021517=
# 3. podnaloga
# Sestavite funkcijo `pari`, ki sprejme slovar zaljubljenih in vrne _množico_
# vseh parov, ki so srečno zaljubljeni. Vsak par naj se pojavi samo enkrat in
# sicer tako, da sta zaljubljenca našteta po abecedi. Na primer, če sta Ana in
# Bine zaljubljena, dodamo par `('Ana', 'Bine')`.
# =============================================================================
def pari(slovar_zaljubljenih):
    srečni_pari = set()
    for oseba, zaljubljeni_v in slovar_zaljubljenih.items():
        for partner in zaljubljeni_v:   # Preverimo, če je tudi partner zaljubljen v to osebo
            if oseba in slovar_zaljubljenih.get(partner, None):# Dodamo par v abecednem vrstnem redu
                srečni_pari.add(tuple(sorted([oseba, partner]))) # tuple naredi oklepaj
    return srečni_pari



# =====================================================================@021518=
# 4. podnaloga
# Sestavite funkcijo `ustrezljivi(oseba, zaljubljeni)`, ki sprejme ime osebe
# ter slovar zaljubljenih, vrne pa _množico_ vseh ljudi, ki so do dane osebe še
# posebej ustrežljivi. Posebej ustrežljivi so seveda zato, ker so bodisi
# zaljubljeni v dano osebo, bodisi so zaljubljeni v osebo, ki je posebej
# ustrežljiva do nje, in tako naprej.
# 
# Na primer, če imamo slovar
# 
#     {
#         'Ana': {'Bine', 'Cene'},
#         'Bine': {'Ana'},
#         'Cene': {'Bine'},
#         'Davorka': {'Davorka'},
#         'Eva': {'Bine'}
#     }
# 
# so do Ceneta posebej ustrežljivi Ana (ki je zaljubljena vanj), Bine (ki je
# zaljubljen v Ano) ter Cene in Eva (ki sta zaljubljena v Bineta).
# =============================================================================
# Brez izpeljanih seznamov
def ustrezljivi(oseba, zaljubljeni):
    ustrez = set()
    kandidati = set()
    for zaljubljenec in zaljubljeni:
        if oseba in zaljubljeni[zaljubljenec]:
            kandidati.add(zaljubljenec) # vse, ki so zaljubljeni v to osebo zapiše
    while kandidati: # dokler kandidati niso prazni
        kandidat = kandidati.pop() # zadnjo osebo vzamemo za kandidata
        ustrez.add(kandidat)
        for zaljubljenec in zaljubljeni:
            if kandidat in zaljubljeni[zaljubljenec] and zaljubljenec not in ustrez: # preverimo, kdo že ustreza
                kandidati.add(zaljubljenec) # dodamo ga k kandidato, da bo rekurzija
    return ustrez

# Ista zadeva z izpeljanimi seznami
def ustrezljivi(oseba, zaljubljeni):
    # seznam, v katerega nabiramo ustrežljive osebe
    ustrezljivi = set()
    # najprej dodamo tiste, ki ljubijo prvo osebo
    dodani = {o for o in zaljubljeni if oseba in zaljubljeni[o]}
    # dokler smo koga dodali, dodajamo ustrežljive
    while dodani:
        ustrezljivi.update(dodani)
        # sedaj pa dodajamo tiste, ki ljubijo nazadnje dodane osebe
        dodani = {o for o in zaljubljeni for dodan in dodani
                  if dodan in zaljubljeni[o] and o not in ustrezljivi}
    return ustrezljivi

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
UTRJRVANJE 1:
# Poudarjanje znakov
# =====================================================================@023460=
# 1. podnaloga
# Sestavite funkcijo `poudari(naslov)`, ki vrne poudarjen niz `naslov`,
# v katerem so vse črke velike in med seboj ločene s presledki. Presledke
# obravnavajte tako kot ostale znake (spremenijo se v trojni presledek).
# Pazite, da se niz ne konča s presledkom.
# 
#     >>> poudari("Zadnja novica")
#     "Z A D N J A   N O V I C A"
# =============================================================================
def poudari(naslov):
    sez = []
    for i in naslov:
        sez.append(i.upper())
    return (" ".join(sez)) #imamo seznam samih črk in presledkov, ki ga združimo s presledki

'''def poudari(naslov):
   sez = list(naslov.upper())
   return (" ".join(sez))
'''
# =====================================================================@023461=
# 2. podnaloga
# Sestavite funkcijo `poudari_besede(naslov)`, ki vrne naslov, v katerem
# so vse besede, označene z znakoma `*`, zapisane z velikimi črkami.
# 
#     >>> poudari_besede("Zadnja *novica* danes!")
#     "Zadnja NOVICA danes!"
# =============================================================================
def poudari_besede(naslov):
    nov_naslov = ''
    poudari = False #vpeljemo stikalo
    for znak in naslov:
        if znak == '*': # dokler ne pride spet do ponovitve znaka bo vse upper
            poudari = not poudari
        elif poudari == True:
            nov_naslov += znak.upper()
        else:
            nov_naslov += znak
    return nov_naslov

# Blagajna
#
# Zaradi prepovedi pisanja blagajniških računov na roko so v lokalni prodajalni
# prisiljeni preiti na računalniško podprto blagajno.
# Bazo prodajnih artiklov so pripravili v obliki slovarja, kjer je ključ
# ime artikla, vrednost pa par, ki vsebuje maloprodajno ceno in stopnjo
# davka (v procentih), na primer takole:
# 
#     artikli = {
#         'ponev': (32.74, 22),
#         'knjiga': (18.60, 9.5),
#         'gugalnik': (153.22, 22),
#         'igrača': (12.18, 0),
#         'likalnik': (43.15, 9.5)
#     }
# 
# Tudi vsak izdan račun predstavimo v obliki slovarja. Ključ je ime
# kupljenega artikla, vrednost pa par, ki vsebuje količino (celo število)
# in popust (v procentih). Primeri:
# 
#     racun1 = {'igrača': (2, 0), 'ponev': (1, 20), 'knjiga': (5, 10)}
#     racun2 = {'likalnik': (1, 5), 'igrača': (1, 20)}
#     racun3 = {'knjiga': (1, 0), 'igrača': (1, 0), 'ponev': (2, 20)}
# =====================================================================@021932=
# 1. podnaloga
# Sestavite funkcijo `davcna_osnova(mpc, ddv)`, ki bo za dano maloprodajno
# ceno `mpc` in stopnjo davka `ddv` izračunala davčno osnovo, to je znesek,
# na katerega zaračunamo davek, da dobimo maloprodajno ceno. Izračunano
# davčno osnovo zaokrožite na dve decimalni mesti. Zgled:
# 
#     >>> davcna_osnova(244.13, 22)
#     200.11
#     >>> davcna_osnova(1683.76, 9.5)
#     1537.68
# =============================================================================
def davcna_osnova(mpc, ddv):
    brez_ddv = (mpc/(1 + ddv/100))
    return round (brez_ddv, 2)
# =====================================================================@021933=
# 2. podnaloga
# Sestavite funkcijo `znesek_racuna(artikli, racun)`, ki izračuna, koliko
# mora kupec plačati za kupljeno blago. Končni znesek zaokrožite na dve
# decimalni mesti. Zgled:
# 
#     >>> znesek_racuna(artikli, racun1)
#     134.25
# 
# Predpostavite, da so na računu le artikli, ki so v s slovarjem podani bazi `artikli`
# =============================================================================
def znesek_racuna(artikli, racun):
    koncni_racun = 0
    for element in racun.keys():
        cena = artikli [element][0]
        popust = racun [element][1]
        kolicina = racun [element][0]
        koncna_cena = cena * kolicina * (1 - popust/100)
        koncni_racun += koncna_cena
    return round (koncni_racun, 2)
# =====================================================================@021934=
# 3. podnaloga
# Sestavite funkcijo `davcni_obracun(artikli, racun)`, ki sestavi
# specifikacijo davka za dani račun. Specifikacijo davka predstavimo
# s slovarjem, kjer so ključi davčne stopnje, vrednosti pa vsote
# davčnih osnov za kupljene artikle s takšno davčno stopnjo. Uporabite
# funkcijo `davcna_osnova` iz prve podnaloge! Končni zneski naj bodo
# zaokroženi na dve decimalni mesti. Zgled:
# 
#     >>> davcni_obracun(artikli, racun1)
#     {0: 24.36, 9.5: 76.44, 22: 21.47}
# =============================================================================
def davcni_obracun(artikli, racun):
    slo = {}
    for element in racun.keys():
        cena = artikli [element][0]
        ddv = artikli [element] [1]
        popust = racun [element][1]
        kolicina = racun [element][0]
        koncna_cena = cena * kolicina * (1 - popust/100)
        osn = davcna_osnova(koncna_cena, ddv)
        slo[ddv] = slo.get(ddv, 0) + osn #lažje kot da dodamo fn.; že obstoječi vr. dodamo novo
    return   

# Palindromi
# =====================================================================@021905=
# 1. podnaloga
# Sestavite funkcijo `palindrom(niz)`, ki vrne `True` kadar je `niz`
# palindrom, in `False` sicer.
# =============================================================================
def palindrom(niz):
    return niz == niz[::-1] #obrne niz


# =====================================================================@021906=
# 2. podnaloga
# Pravimo, da je beseda praktično palindrom, če ji je treba zbrisati natanko
# eno črko, da bi postala palindrom. Primer je beseda `kolo`, ki ji
# moramo zbrisati črko `k`, pa postane palindrom `olo`.
# 
# Sestavite funkcijo `prakticno_palindrom(niz)`, ki preveri, ali je `niz`
# priktično palindrom. Vse znake (tudi presledke) v besedi obravnavamo enako.
# =============================================================================
def prakticno_palindrom(niz):
    # za vsak i poskusimo izpustiti črko na i-tem mestu
    for i in range(len(niz)):
        # če smo dobili palindrom, končamo
        if palindrom(niz[:i] + niz[i + 1:]): # i+1, ker spustimo i
            return True
    # če je zanka prišla do konca, palindroma nismo našli
    return False


def prakticno_palindrom(niz):
    for i in range(len(niz)): # moraš podati dolžino
        if (niz [:i] + niz[i+1:]) == (niz [:i] + niz[i+1:])[::-1]:
            return True
    return False    


# =====================================================================@021907=
# 3. podnaloga
# Pravimo, da je beseda skoraj palindrom, če ji je treba dodati ali 
# izbrisati natanko eno črko oziroma zamenjati natanko eno črko z drugo, 
# da bi postala palindrom. Primeri:
# 
# - `robot`, kjer moramo `t` zamenjati z `r`,
# - `jana`, kjer moramo na konec dodati `j`.
# 
# Sestavite funkcijo `skoraj_palindrom(niz)`, ki preveri, ali je `niz`
# skoraj palindrom. Vse znake (tudi presledke) v besedi obravnavamo enako.
# =============================================================================
def skoraj_palindrom(niz):
    # Odstranjevanje in dodajanje črk preverimo s funkcijo prakticno_palindrom.
    # Razmislite, zakaj smo s tem pokrili tudi dodajanje ene črke.
    if prakticno_palindrom(niz):
        return True
    
    # Za vsak i poskusimo črko na i-tem mestu nadomestiti s pravilno.
    for i in range(len(niz)):
        if palindrom(niz[:i] + niz[-i - 1] + niz[i + 1:]): #niz[-i - 1] → znak iz "zrcalne" pozicije od konca
            return True

    # Če je zanka prišla do konca, palindroma z zamenjavo ene črke nismo našli.
    return False

# Analiza besedila
#
# Pri tej nalogi bomo analizirali nize, ki predstavljajo pravilno slovensko
# oblikovane besede in stavke. Pri vseh podnalogah lahko predpostavite, da
# so vhodni nizi `s` dobro oblikovani, tj. ne vsebujejo dveh zaporednih
# presledkov oz. nepotrebnih presledkov ter prelomov vrstice na začetku ali
# na koncu.
# =====================================================================@021925=
# 1. podnaloga
# Sestavite funkcijo `stevilo_besed`, ki v podanem nizu prešteje
# število besed, pri čemer lahko predpostavite, da presledki stojijo
# **natanko pred vsako** (razen prvo) besedo v nizu. Primer:
# 
#     >>> stevilo_besed('Višje, hitreje, močneje!')
#     3
# =============================================================================
def stevilo_besed(s):
    '''Koliko besed je v nizu s'''
    if s == '':
        return 0
    return s.count(' ') + 1 # +1 zaradi prve besede

def stevilo_besed(niz):
    st = 0
    nov_niz = niz.strip().split() # ali vejice ali presledke
    for beseda in nov_niz:
        st += 1
    return st



# =====================================================================@021926=
# 2. podnaloga
# Sestavite funkcijo `samoglasniki`, ki v podanem nizu prešteje
# število samoglasnikov. Zgled:
# 
#     >>> samoglasniki('pomaranča')
#     4
# =============================================================================
def samoglasniki(niz):
    sam = "aeiouAEIOU" #Potrebno bi bilo: "aeiou" (kot niz), ne brez narekovajev; Prav tako ni potrebe, da je v seznamu ([ ]), ker želiš kar niz samoglasnikov
    st= 0
    for crka in niz:
        for sam1 in sam:
            if sam1 == crka:
                st +=1
    return st

#Uradna rešitev:
def samoglasniki(s):
    '''Koliko je v nizu s samoglasnikov'''
    vsiSamoglasniki = 'aeiouAEIOU'
    stevec = 0
    for c in s:
        if c in vsiSamoglasniki:
            stevec += 1
    return stevec

# =====================================================================@021927=
# 3. podnaloga
# V Pythonu vrstice večvrstičnega niza ločujemo z znakom `'\n'`.
# Sestavite funkcijo `vrstice`, ki sprejme večvrstični niz in
# vrne seznam, ki vsebuje vse vrstice tega niza (v istem vrstnem redu).
# Zgled:
# 
#     >>> vrstice("Danes\n je lep\ndan.\n")
#     ['Danes', ' je lep', 'dan.', '']
# 
# _Opomba_: Python obravnava niz `'\n'` kot en sam znak.
# =============================================================================
def vrstice(s):
    '''Vrne seznam vrstic v nizu s''' # če dodaš še strip želiš odstraniti prazne vrstice na začetku in koncu.
    return s.split('\n')

'''def vrstice(s):
    #Vrne seznam vrstic v nizu s
    return s.strip().split('\n')
''' # odstrani še prazne vrstice, a tega ne zahteva

# =====================================================================@021928=
# 4. podnaloga
# Haiku (japonsko 俳句) je japonska pesniška oblika iz treh verzov
# (vrstic), ki obsega sedemnajst zlogov. Prvi in tretji verz imata po pet
# zlogov, drugi sedem.
# 
# Na kulturnem natečaju TomoHaiku udeleženci oddajajo svoje izdelke na
# strežnik Tomo. Napišite kontrolno funkcijo `haiku`, ki sprejme
# niz ter vrne `True`, če niz ustreza pesniški obliki haiku, sicer
# pa vrne `False`.
# 
# Predpostavite lahko, da število samoglasnikov v neki besedi ustreza
# številu njenih zlogov ter da niz ne vsebuje nepotrebnih začetnih oz.
# končnih praznih vrstic. Vrstice so ločene z znakom za prelom vrstice `'\n'`.
# Primer:
# 
#     >>> haiku('Skrit v svojem svetu,\ntemna otožnost neba,\ntvoj topli objem.')
#     True
#     >>> haiku('Riba,\nraca, rak,\nvinjak je grenak!')
#     False
# =============================================================================
def haiku(s):
    novi_niz = vrstice(s)
    st_vr = 0
    for vrstica in novi_niz:
        if st_vr == 0 or st_vr == 2:
            if samoglasniki(vrstica) != 5:
                return False
        elif st_vr == 1:
            if samoglasniki(vrstica) != 7:
                return False
        st_vr += 1
    if st_vr == 3:
        return True

# Uradna rešitev:
def haiku(s):
    '''Preveri, ali je v nizu s zapisan haiku'''
    if s.count('\n') != 2: # premalo vrstic
        return False
    i = s.find('\n') # konec prve vrstice
    j = s.find('\n', i + 1) # konec druge
    # prva in tretja morate imeti 5, srednja pa 7 samoglasnikov
    return samoglasniki(s[:i]) == samoglasniki(s[j:]) == 5 and samoglasniki(s[i:j]) == 7


# =====================================================================@021929=
# 5. podnaloga
# Sestavite funkcijo `podcrtaj`, ki za parameter dobi niz, v
# katerem so podnizi, ki bi morali biti izpisani podčrtano, označeni s
# podčrtajem na začetku in na koncu. Če je v nizu liho mnogo podčrtajev,
# si mislite, da je še eden na koncu. Funkcija naj vrne dvovrstični niz,
# kjer je v prvi vrstici originalni niz toda brez podčrtajev, sledi
# znak za prelom vrstice, naslednjo vrstico pa sestavlja niz, sestavljen
# iz presledkov in minusov, pri čemer minusi ležijo pod tistimi deli
# besedila, ki morajo biti podčrtani. Primer:
# 
#     >>> podcrtaj("Jaz _sem_ pa cajzelc!")
#     'Jaz sem pa cajzelc!\n    ---            '
# 
# Predpostavite, da v nizu `s` ni nobenega znaka `'\n'`.
# =============================================================================
def podcrtaj(s):
    '''Vrne niz iz dveh vrstic, kjer so ustrezni znaki podčrtani'''
    prvaVrsta = ''
    drugaVrsta = ''
    podcrtujem = False  # ali so trenutni znaki podčrtani
    for znak in s:
        if znak == '_': # preklopimo način podčrtovanja
            podcrtujem = not podcrtujem
        else:
            prvaVrsta += znak # v prvi vrsti so vsi znaki razen podčrtajev
            if podcrtujem: # v drugi pa bodisi presledki, bodisi podčrtaji
                drugaVrsta += '-'
            else:
                drugaVrsta += ' '
    return prvaVrsta + '\n' + drugaVrsta # ker so nizi se uporabi +


# =====================================================================@021930=
# 6. podnaloga
# Sestavite funkcijo `stevilo_znakov`, ki v podanem nizu prešteje
# število znakov, pri čemer se presledki ne upoštevajo. Zgled:
# 
#     >>> stevilo_znakov('B     u!')
#     3
# =============================================================================
def stevilo_znakov(s):
    '''Število znakov brez presledkov'''
    return len(s) - s.count(' ')


# =====================================================================@021931=
# 7. podnaloga
# [Sonet](https://sl.wikipedia.org/wiki/Sonet) je priljubljena pesniška oblika.
# Sestavljen je iz štirih kitic,
# pri čemur med vsakima dvema kiticama avtor izpusti eno prazno vrstico.
# Prvi dve kitici sta štirivrstični — kvartini, drugi dve pa sta trivrstični
# — tercini.
# 
# V slovenskem sonetu je standardni verz italijanski (laški) ali jambski
# enajsterec. To pomeni, da v vsaki vrstici nastopa natanko enajst zlogov.
# 
# Na kulturnem natečaju TomoSonet udeleženci oddajajo svoje izdelke na
# strežnik Tomo. Napiši kontrolno funkcijo `sonet`, ki sprejme niz,
# ter vrne `True`, če niz ustreza slovenskemu sonetu, in `False` sicer.
# Zgled:
# 
#     >>> sonet('Bolj slab\nsonet.\n\nZa umret!')
#     False
# 
# _Namig_: V slovenskem jeziku število samoglasnikov v neki besedi ustreza
# številu njenih zlogov. (Obstaja nekaj izjem, ki pa jih bomo zanemarili.)
# =============================================================================
def sonet(s):
    '''Ali je v s zapisan sonet'''
    v = vrstice(s) # seznam vrstic - s pomočjo funkcije od prej!
    if len(v) != 17:
        return False  # Sonet mora imeti 14 + 3 (prazne) = 17 vrstic.
    for i in range(17): # indeksi vseh vrstic
        if i in [4, 9, 13]:
            if v[i] != '':
                return False  # Med kiticami morajo biti prazne vrstice.
        else:
            if samoglasniki(v[i]) != 11:
                return False  # Verz ni jambski enajsterec.
    return True

# Ogrlice
#
# Takrat, ko je upokojenki Marti dolgčas, vzame svoji dve posodici z belimi
# in rdečimi kroglicami ter začne nizati ogrlice. Te ogrlice bomo
# predstavili z nizi, sestavljenimi iz znakov `B` in `R`.
# Na primer: `"BBRBBRB"` in `"RRBBBBB"` sta dve izmed 21 možnih ogrlic,
# sestavljenih iz petih belih in dveh rdečih kroglic.
# 
# Drugi del te naloge je namenjen rekurziji, ki je pri tem predmetu ne obdelamo, zato ne pride v poštev za izpit. Vseeno vabljeni k reševanju!
# =====================================================================@021912=
# 1. podnaloga
# Sestavite funkcijo `je_ogrlica(niz, b, r)`, ki preveri, ali `niz`
# predstavlja ogrlico iz `b` belih in `r` rdečih kroglic. Na primer:
# 
#     >>> je_ogrlica("BBRBBRB", 5, 2)
#     True
#     >>> je_ogrlica("RRBBBBB", 5, 2)
#     True
#     >>> je_ogrlica("BBRBBRB", 2, 5)
#     False
#     >>> je_ogrlica("BBRBBRBBB", 5, 2)
#     False
#     >>> je_ogrlica("BBRBBRBXY", 5, 2)
#     False
# =============================================================================
def je_ogrlica(niz, b, r):
    st_b = 0
    st_r = 0
    for i in range(len(niz)): # lahko se tudi sprehajaš po nizu - i ima vrednost črke
        if niz[i] == 'B':
            st_b += 1
        elif niz[i] == 'R':
            st_r += 1
        else:
            return False
    if st_b == b and st_r == r:
        return True
    else:
        return False


# Uradna rešitev:
def je_ogrlica(niz, b, r):
    for znak in niz:
        if znak == 'B':
            b -= 1
        elif znak == 'R':
            r -= 1
        else:
            return False
    return b == 0 and r == 0

def je_ogrlica(niz, b, r):
    return niz.count('B') == b and niz.count('R') == r and len(niz) == r+b
# =====================================================================@021913=
# 2. podnaloga
# Z $O(b, r)$ označimo število različnih ogrlic, sestavljenih iz natanko
# $b$ belih in $r$ rdečih kroglic. Če je eno od števil $b$ ali $r$ enako
# nič, potem je $O(b, r) = 1$. Na primer, $O(5, 0) = 1$, saj iz petih
# belih kroglic lahko sestavimo le ogrlico `"BBBBB"`.
# 
# V nasprotnem primeru pa velja $O(b, r) = O(b - 1, r) + O(b, r - 1)$,
# saj se vsaka izmed ogrlic iz $b$ belih in $r$ rdečih kroglic:
# 
# 1. bodisi začne z belo kroglico, preostalih $b - 1$ belih in $r$ rdečih
#    kroglic pa lahko sestavimo na $O(b - 1, r)$ načinov,
# 2. bodisi začne z rdečo kroglico, preostalih $b$ belih in $r - 1$ rdečih
#    kroglic pa lahko sestavimo na $O(b, r - 1)$ načinov.
# 
# Sestavite funkcijo `stevilo_ogrlic(b, r)`, ki izračuna število vseh
# možnih ogrlic, sestavljenih iz natanko `b` belih in `r` rdečih kroglic.
# Na primer:
# 
#     >>> stevilo_ogrlic(5, 0)
#     1
#     >>> stevilo_ogrlic(5, 2)
#     21
#     >>> stevilo_ogrlic(4, 2)
#     15
#     >>> stevilo_ogrlic(5, 1)
#     6
# =============================================================================
# NI NA IZPITU!!!:
def stevilo_ogrlic(b, r):
    if b == 0 or r == 0:
        return 1
    else:
        return stevilo_ogrlic(b - 1, r) + stevilo_ogrlic(b, r - 1)

import scipy.special as sp
def stevilo_ogrlic(b, r):
    return sp.binom(b+r, b)

# Igra življenja
#
# [Igra življenja](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)
# gre takole: Imamo matriko, katere elementi sta logični vrednosti `True`
# in `False`. Vrednost `True` pomeni, da je celica živa, vrednost `False`
# pa pomeni, da je celica mrtva. Celice (razen robnih) imajo po 8 sosedov:
# dva horizontalna, dve vertikalna in štiri diagonalne. Čas teče v
# diskretnih korakih. S trenutnim stanjem sveta je tudi stanje sveta
# v naslednjem koraku natanko določeno in sicer po naslednjih pravilih:
# 
# - Živa celica, ki ima manj kot 2 živa soseda, umre (zaradi osamljenosti).
# - Živa celica, ki ima 2 ali 3 žive sosede, preživi.
# - Živa celica, ki ima več kot 3 žive sosede, umre (zaradi prenaseljenosti).
# - Mrtva celica, ki ima natanko 3 žive sosede, oživi (reprodukcija).
# 
# Primeri matrik, ki predstavljajo stanje sveta:
# 
#     svet_1 = [
#         [False, False, False, False, False, False],
#         [False, False, False, True, False, False],
#         [False, True, False, False, True, False],
#         [False, True, False, False, True, False],
#         [False, False, True, False, False, False],
#         [False, False, False, False, False, False]
#     ]
# 
#     svet_2 = [
#         [False, False, False, False],
#         [False, True, True, False],
#         [False, True, True, False],
#         [False, False, False, False]
#     ]
# 
# Tukaj si lahko ogledate 
# [simulacijo](http://pmav.eu/stuff/javascript-game-of-life-v3.1.1/).
# =====================================================================@021918=
# 1. podnaloga
# Napišite funkcijo `zivi(svet, i, j)`, ki v svetu `svet` prešteje in
# vrne število živih sosedov celice v $i$-ti vrstici in $j$-tem stolpcu.
# Zgled (naj bo `svet_1` matrika, kot je definirana zgoraj):
# 
#     >>> zivi(svet_1, 2, 0)
#     2
# 
# _Opomba_: Kot je za Python običajno, se stolpci in vrstice začnejo
# številčiti pri 0.
# =============================================================================
def zivi(svet, i, j):
    '''Koliko živih sosedov ima celica (i,j) '''
    n, m = len(svet), len(svet[0]) # dimenzije sveta
    stej = 0
    for vrst in range(i-1, i+2):
        for stol in range(j-1, j+2):
            if (vrst == i) and (stol == j): # sama sebi ni sosed
                continue
            if (vrst < 0) or (vrst > n-1) or (stol < 0) or (stol > m-1):
                # smo izven sveta
                continue
            if svet[vrst][stol] : # živ sosed!
                stej += 1 
    return stej


# =====================================================================@021919=
# 2. podnaloga
# Napišite funkcijo `igra(svet)`, ki sestavi in vrne matriko, ki
# predstavlja novo stanje sveta. Štiri pravila, ki določajo novo stanje
# sveta, so opisana zgoraj.
# 
# Zgled (matrika `svet_1` naj bo enaka kot zgoraj):
# 
#     >>> igra(svet_1)
#     [[False, False, False, False, False, False],
#      [False, False, False, False, False, False],
#      [False, False, True, True, True, False],
#      [False, True, True, True, False, False],
#      [False, False, False, False, False, False],
#      [False, False, False, False, False, False]]
# =============================================================================
def igra(svet):
    '''vrne nov svet po enem koraku'''
    n, m = len(svet), len(svet[0])
    novSvet = []
    for i in range(n): # po vrsticah
        novaVr = []
        for j in range(m): # po stolpcih
            novaVr.append(zivi(svet, i, j) == 3 or # celica ima tri žive sosede
                           (zivi(svet, i, j) == 2 and svet[i][j])) # ali pa 2 in je ona živa
        novSvet.append(novaVr)
    return novSvet
    
## Z nekaj več znanja lahko napišemo le
##     n, m = len(svet), len(svet[0])    
##     return [[zivi(svet, i, j) == 3 or \
##        (zivi(svet, i, j) == 2 and svet[i][j]) for j in range(m)] for i in range(n)]


# =====================================================================@021920=
# 3. podnaloga
# Napišite funkcijo `populacija(svet, n)`, ki naredi `n` korakov igre
# življenje in na vsakem koraku prešteje število živih celic. Ta
# števila naj vrne v obliki seznama, ki ima $n + 1$ elementov – prvo
# število v seznamu naj bo število živih celic v začetnem svetu. Zgled
# (matrika `svet_1` naj bo enaka kot zgoraj):
# 
#     >>> populacija(svet_1, 3)
#     [6, 6, 6, 6]
# 
# Funkcijo bomo testirali še na naslednjih svetovih (poleg tistih dveh,
# ki sta podana zgoraj):
# 
#     svet_3 = [
#         [False, False, False, False, False, False],
#         [False, True, True, False, False, False],
#         [False, True, True, False, False, False],
#         [False, False, False, True, True, False],
#         [False, False, False, True, True, False],
#         [False, False, False, False, False, False]
#     ]
# 
#     svet_4 = [
#         [True, True, True],
#         [True, True, True],
#         [True, True, True]
#     ]
# 
# _Nasvet_: Najprej napišite pomožno funkcijo, ki prešteje število živih
# celic v matriki.
# =============================================================================
def koliko_zivih(svet):
    '''Koliko je v svetu živih celic'''
    n, m = len(svet), len(svet[0])
    koliko = 0
    for i in range(n): # po vrsticah
        novaVr = []
        for j in range(m): # po stolpcih
            if svet[i][j] : # živa celica!
                koliko += 1
    return koliko


def populacija(svet, n):
    '''Kako se v n korakih spreminja populacija živih celic'''
    ret = [koliko_zivih(svet)] # stanje na začetku
    for i in range(n): # koliko korakov
        svet = igra(svet) # nov svet
        ret.append(koliko_zivih(svet)) # dodamo število živih
    return ret

## Z nekaj več znanja:
##
## def koliko_zivih(svet):
##    return sum(sum(1 if x else 0 for x in vr) for vr in svet)
##
## def populacija(svet, n):
##    ret = [pop(svet)]
##    for i in range(n):
##        svet = igra(svet)
##        ret.append(koliko_zivih(svet))
##    return ret

# Lepšanje in šifriranje
#
# [Klodovik /papiga/](http://skab612.com/AlanFord/af_likovi.html) in ne
# [Klodvik /frankofonski kralj/](https://sl.wikipedia.org/wiki/Seznam_frankovskih_kraljev)
# bi rad zašifriral svoja besedila, da jih nepoklicane osebe
# ne bodo mogle prebrati.
# =====================================================================@023462=
# 1. podnaloga
# To stori tako, da najprej v besedilu vse male črke spremeni v velike in
# odstrani vse znake, ki niso črke. (Klodovik vsa pomembna besedila piše v
# angleščini. Uporabljali bomo angleško abecedo.) Na primer iz besedila
# `'Attack at dawn!'` dobi besedilo `'ATTACKATDAWN'`. Nato ga zapiše cik-cak
# v treh vrsticah, kot prikazuje primer:
# 
#     A...C...D...
#     .T.A.K.T.A.N
#     ..T...A...W.
# 
# Sestavite funkcijo `cik_cak`, ki sprejme niz in  vrne trojico nizov
# (torej `tuple`) in sicer prvo, drugo in tretjo vrstico v tem zapisu. Primer:
# 
#     >>> cik_cak('Attack at dawn!')
#     ('A...C...D...', '.T.A.K.T.A.N', '..T...A...W.')
# =============================================================================
def cik_cak(niz):
    '''Niz spremenimo v trtvrstični zapis CikCak'''
    perioda = [0, 1, 2, 1] # kako se izmenjujejo nizi, kamor
                           # zapišemo znak: prva, druga, tretja, druga, prva, druga, tretja, druga ...
    niz = niz.upper()
    vrste = ['', '', '']  # vrstice bodo na začetku seznami, da jih lahko spreminjamo!
    stevec = 0 # kateri znak jemljemo 
    for znak in niz:
        if not 'A' <= znak <= 'Z': # če ne gre za znak angleške abecede
            continue
        pos = perioda[stevec % 4] # kam bomo napisali znak
        vrste[pos] += znak
        vrste[(pos+1)%3] += '.'
        vrste[(pos+2)%3] += '.'
        stevec += 1
    return tuple(vrste) # vrniti moramo trojico!


# =====================================================================@023463=
# 2. podnaloga
# Zašifrirano besedilo dobi tako, da najprej prepiše vse znake iz prve
# vrstice, nato vse znake iz druge vrstice in na koncu še vse znake iz
# tretje vrstice. V zgornjem primeru bi tako dobil `'ACDTAKTANTAW'`.
# Sestavite funkcijo `cik_cak_sifra`, ki dobi kot argument niz
# in vrne zašifrirano besedilo. Primer:
# 
#     >>> cik_cak_sifra('Attack at dawn!')
#     'ACDTAKTANTAW'
# =============================================================================
def cik_cak_sifra(s):
    '''Zašifrirajmo besedilo'''
    prva, druga, tretja = cik_cak(s) # najprej zapišemo cik-cak
    sifra = ''
    for znak in prva + druga + tretja: # gremo preko vseh treh vrstic
        if znak != '.': # spustimo pike # NE UPORABIŠ STRIP !!!
            sifra += znak
    return sifra


# =====================================================================@023464=
# 3. podnaloga
# Klodovik se zelo razjezi, ko dobi elektronsko pošto v takšni obliki:
# 
#     Kar sva  si obljubljala    že leta,  si   želiva potrditi tudi   pred prijatelji in   celo
#     žlahto. Vabiva te na
#     
#          poročno slovesnost,        ki bo
#        10.   maja 2016 ob    15.    uri na gradu Otočec.   Prijetno   druženje bomo 
#     nadaljevali v    hotelu   Mons.   Tjaša in  Pavle
# 
# Nepopisno mu gre na živce, da je med besedami po več presledkov. Še
# bolj pa ga nervira, ker so nekatere vrstice precej daljše od drugih.
# Ker je Klodovik vaš dober prijatelj, mu boste pomagali in napisali
# funkcije, s katerimi bo lahko olepšal besedila.
# 
# 
# Najprej napišite funkcijo `razrez`, ki kot argument dobi niz in vrne
# seznam besed v tem nizu. Besede so med seboj ločene z enim ali večimi
# praznimi znaki: `' '` (presledek), `'\t'` (tabulator) in `'\n'` (skok
# v novo vrstico). Pri tej nalogi ločilo obravnavamo kot del besede.
# Primer:
# 
#     >>> razrez('   Kakšen\t pastir, \n\ntakšna  čreda. ')
#     ['Kakšen', 'pastir,', 'takšna', 'čreda.']
# =============================================================================
def razrez(s):
    '''Niz s razreže na podnize, ki jih ločijo "beli" presledki'''
    seznam = []
    beseda = '' # trenutna beseda, ki jo sestavljamo
    for znak in s:
        if znak in ' \n\t':  # znak ni del besede
            if len(beseda) > 0: # če je ta znak zaključil besedo, jo dodamo v seznam
                seznam.append(beseda)
            beseda = '' # in nato bomo začeli sestavljati novo
        else:
            beseda += znak # smo "znotraj" besede
    if len(beseda) > 0: # ne pozabimo na morebitno besedo na koncu!
        seznam.append(beseda)
    return seznam


# =====================================================================@023465=
# 4. podnaloga
# Sedaj, ko že imate funkcijo `razrez`, bo lažje napisati tisto funckijo, ki
# jo Klodovik zares potrebuje. To je
# funkcija `olepsanoBesedilo(s, sir)`, ki kot argumenta dobi niz
# `s` in naravno število `sir`. Funkcija vrne olepšano besedilo, kar
# pomeni naslednje:
# 
# * Funkcija naj odstrani odvečne prazne znake.
# * Vsaka vrstica naj bo kar se le da dolga.
# * Nobena vrstica naj ne vsebuje več kot `sir` znakov (pri čemer znaka
#   `'\n'` na koncu vrstice ne štejemo).
# * Besede znotraj iste vrstice naj bodo ločene s po enim presledkom
#   (ne glede na to, s katerimi in koliko praznimi znaki so ločene v
#   originalnem besedilu).
# 
# Predpostavite, da dolžina nobene besede ni več kot `sir` in da je niz
# `s` neprazen. Primer:
# 
#     >>> s2 = olepsanoBesedilo('  Jasno in   svetlo \t\tna sveti \t\n\nvečer,  dobre\t\t letine je dost, če pa je\t  oblačno in   temno,        žita ne bo.', 20)
#     >>> print(s2)
#     Jasno in svetlo na
#     sveti večer, dobre
#     letine je dost, če
#     pa je oblačno in
#     temno, žita ne bo.
# =============================================================================
def olepsanoBesedilo(s, sir):
    '''olepša besedilo do največje širine sir'''
    besedilo = '' #končno besedilo
    besede = razrez(s) # razrežemo na posamezne besede
    vrstica = ''
    for b in besede:
        if len(vrstica) + len(b) > sir: # če je beseda, ki je na vrsti, predolga
            besedilo += vrstica[:-1] + '\n' # odrežemo presledek, ki smo ga dodali za stikanje
            vrstica = '' # začnemo novo vrstico
        vrstica += b + ' ' # dodamo presledek za vsako novo besedo
    if len(vrstica) > 0: # ne pozabimo na zadnjo vrstico!
        besedilo += vrstica[:-1] + '\n'
    return besedilo[:-1] # na koncu je odvečni prehod v novo vrsto


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
DATOTEKE:
# Ogrevanje
# =====================================================================@021880=
# 1. podnaloga
# Ker študirate v Ljubljani, ste se preselili v bližnji študentski dom. Žal pa
# ob izpolnjevanju vloge niste bili dovolj pozorni, zato ste pristali v eni
# najbolj hrupnih sob na kampusu. Vaše živce kravžljajo študenti FDVja iz
# sosednjega stanovanja, saj zaradi manjka študijskih obveznosti v času vašega
# počitka na veliko razgrajajo. Odločili ste se, da jim napišete grozilno
# pismo, a kaj ko se ga vedno spravite pisati podnevi, ko niste dovolj
# razburjeni.
# 
# Sestavite funkcijo `prepisi_in_zagrozi`, ki sprejme ime vhodne datoteke in
# ime izhodne datoteke, ter vsebino vhodne datoteke prepiše v izhodno datoteko,
# pri tem pa spremeni vse črke v velike in vse pike v klicaje.
# 
# Denimo, da imamo v datoteki `diplomatsko.txt` zapisano naslednje besedilo
# 
#     "Prosim, da študentje ponoči utihnejo.
#      Sicer bo red naredila policija."
# 
# Tedaj klic funkcije `prepisi_in_zagrozi("diplomatsko.txt","groznja.txt")` v
# datoteko `groznja.txt` zapiše naslednjo vsebino:
# 
#     'PROSIM, DA ŠTUDENTJE PONOČI UTIHNEJO!
#      SICER BO RED NAREDILA POLICIJA!'
# =============================================================================
def prepisi_in_zagrozi(vhodna_datoteka, izhodna_datoteka):
    with open(vhodna_datoteka, 'r', encoding='utf-8') as datoteka:
        vsebina = datoteka.read()

    vsebina_spremenjena = vsebina.upper().replace('.', '!')
    
    with open(izhodna_datoteka, 'w', encoding='utf-8') as datoteka:
        datoteka.write(vsebina_spremenjena)
# =====================================================================@021881=
# 2. podnaloga
# Ker želite, da bodo sosedje vašo grožnjo vzeli resno, ste si pripravili več
# osnutkov besedila. Še vedno pa niste povsem odločeni, katero grožnjo bi
# najprej poslali. En izmed možnih kriterijev je, da mora besedilo vsebovati
# vsaj tri klicaje.
# 
# Sestavite funkcijo `groznje_z_dovolj_klicaji`, ki iz seznama imen vhodnih
# datotek izbere tiste datoteke, ki vsebujejo vsaj tri klicaje.
# 
# Denimo, da imamo v datoteki `diplomatsko.txt` zapisano naslednje besedilo
# 
#     'PROSIM, DA ŠTUDENTJE PONOČI UTIHNEJO!
#      SICER BO RED NAREDILA POLICIJA!'
# 
# in v datoteki `nepoliticno.txt` zapisano naslednje besedilo
# 
#     'Nehajte mi težit!!!!'
# 
# Tedaj klic funkcije `groznje_z_dovolj_klicaji` vrne naslednje:
# 
#     >>> groznje_z_dovolj_klicaji(["diplomatsko.txt", "nepoliticno.txt"])
#     ['nepoliticno.txt']
# =============================================================================
def groznje_z_dovolj_klicaji(sez):
    datoteke_z_klicaji = []
    for datoteka in sez:
        with open(datoteka, 'r', encoding='utf-8') as file:
            vsebina = file.read()
            
        if vsebina.count('!') > 3:
            datoteke_z_klicaji.append(datoteka)
    return datoteke_z_klicaji

# Imena
#
# V neki datoteki, ki ima lahko več vrstic, so zapisana imena. Znotraj
# posamične vrstice so imena ločena z vejicami (brez presledkov). Primer take
# datoteke:
# 
#     Jaka,Peter,Miha,Peter,Anja
#     Franci,Roman,Renata,Jožefa
#     Pavle,Tadeja,Arif,Filip,Gašper
# =====================================================================@021886=
# 1. podnaloga
# Sestavite funkcijo `kolikokrat_se_pojavi(niz, ime)`, ki vrne število
# pojavitev imena `ime` v nizu imen `niz`.
# 
#     >>> kolikokrat_se_pojavi('Alojz,Samo,Peter,Alojz,Franci', 'Alojz')
#     2
# =============================================================================
def kolikokrat_se_pojavi(niz, ime):
    st_ponovitev= 0
    besede = niz.split(',')
    for novoime in besede:
        if novoime == ime:
            st_ponovitev += 1
    return st_ponovitev


# =====================================================================@021887=
# 2. podnaloga
# Sestavite funkcijo `koliko(niz, datoteka)`, ki na izhodno datoteko za vsako
# ime zapiše, kolikokrat se pojavi v nizu.
# 
# Na primer, če je niz enak `'Jaka,Luka,Miha,Luka'`, naj funkcija v izhodno
# datoteko zapiše
# 
#     Jaka 1
#     Luka 2
#     Miha 1
# 
# Pozor: Imena naj bodo izpisana v takem vrstnem redu, kakor si sledijo njihove
# prve pojavitve v nizu.
# =============================================================================
def koliko(niz, datoteka) :
    slovar = dict()
    besede = niz.split(',')  # seznam besed, ločene z vejico
    for novoime in besede: # Preštejemo število ponovitev vsakega imena
        if novoime in slovar:
            slovar[novoime] += 1 # prištevanje vrednosti v slovarju !!!
        else:
            slovar[novoime] = 1
    
    with open(datoteka, 'w') as doc:  # Zapišemo rezultate v datoteko v vrstnem redu, kot so se pojavili v nizu
        for ime in besede:
            if ime in slovar:
                doc.write(f"{ime} {slovar[ime]}\n")
                slovar.pop(ime)  # Po tem, ko smo ime zapisali, ga odstranimo iz slovarja, da se ne ponovi


# =====================================================================@021888=
# 3. podnaloga
# Sestavite funkcijo `koliko_iz_datoteke(vhodna, izhodna)`, ki naj naredi isto
# kot funkcija `koliko`, le da podatke prebere iz datoteke. Torej, na izhodno
# datoteko naj za vsako ime zapiše, kolikokrat se pojavi v vhodni datoteki.
# 
# Pozor: Vhodna datoteka ima lahko več vrstic. Imena izpišite v enakem vrstnem
# redu, kot si sledijo njihove prve pojavitve v vhdoni datoteki.
# =============================================================================
def koliko_iz_datoteke(vhodna, izhodna):
    vrstice = []  # Seznam vseh vrstic v datoteki vhodna
    with open(vhodna) as f:
        for vrstica in f:
            vrstice.append(vrstica.strip())  # Odstranimo '\n' s konca vrstice
    imena = ','.join(vrstice)  # Niz z vsemi imeni iz datoteke
    koliko(imena, izhodna)


'''def koliko_iz_datoteke(vhodna, izhodna):
    slovar = dict()
    with open(vhodna, 'r', encoding='utf-8') as dat1:
        for vrstica in dat1:
            slovar.append(vrstica.strip())
        vsebina = dat1.read().replace('\n', ',')  # nadomestimo vrstice z vejicami
        besede = vsebina.split(',')

    for novoime in besede:
        if novoime == None:
            continue
        elif novoime in slovar:
            slovar[novoime] += 1
        else:
            slovar[novoime] = 1

    with open(izhodna, 'w', encoding='utf-8') as dat2:
        for ime in besede:
            if ime in slovar:
                dat2.write(f"{ime} {slovar[ime]}\n")
                slovar.pop(ime)'''



# =====================================================================@021889=
# 4. podnaloga
# Sestavite funkcijo `koliko_urejen`, ki sprejme imeni vhodne in izhodne
# datoteke in v izhodno datoteko za vsako ime zapiše, kolikokrat se pojavi v
# vhodni datoteki. Imena naj bodo urejena padajoče po frekvenci pojavitev.
# Imena, ki imajo enako frekvenco, naj bodo nadalje urejena leksikografsko (tj.
# po abecednem vrstnem redu).
# 
# Primer: Če je na datoteki imena_vhod.txt vsebina
# 
#     Luka,Jaka
#     Luka,Miha,Miha
#     Miha,Aleš,Aleš
# 
# naj bo po klicu funkcije `koliko_urejen('imena_vhod.txt', 'imena_izhod.txt')`
# na datoteki imena_izhod.txt naslednja vsebina:
# 
#     Miha 3
#     Aleš 2
#     Luka 2
#     Jaka 1
# =============================================================================
def koliko_urejen(vhod, izhod):
    imena = []  # Seznam vseh imen
    brez_ponovitev = []  # Seznam imen brez ponovitev, DVA SEZNAMA, DA LAŽJE ŠTEJEMO
    with open(vhod) as f:
        for vrstica in f:
            for ime in vrstica.strip().split(','):
                imena.append(ime)
                if ime not in brez_ponovitev:
                    brez_ponovitev.append(ime)
    # Seznam pari bo vseboval pare oblike (-3, 'Miha'). Druga komponenta bo
    # ime; prva komponenta bo število pojavitev tega imena, pomnoženo z -1.
    pari = []
    for ime in brez_ponovitev:
        pari.append((-imena.count(ime), ime))
    # Metoda sort uredi števila naraščajoče po vrednosti, nize pa leksikografsko
    # (tj. tako kot so urejeni v leksikonu). Pare uredi glede na prvo
    # komponento, tiste z enako prvo komponento pa še glede na drugo komponento.
    pari.sort()
    with open(izhod, 'w') as f:
        for s, ime in pari:
            print(ime, -s, file=f)

# Alternativna rešitev (uporablja izpeljane sezname, množice in lambda funkcije)
def koliko_urejen_2(vhod, izhod):
    with open(vhod) as f:
        imena = ','.join([vrstica.strip() for vrstica in f])
    enkrat_imena = set(imena.split(','))
    pari = [(ime, kolikokrat_se_pojavi(imena, ime)) for ime in enkrat_imena]
    pari.sort(key=lambda p: (-p[1], p[0]))
    with open(izhod, 'w') as f:
        for ime, s in pari:
            print(ime, s, file=f)

# Kolokviji
#
# V vsaki vrstici datoteke imamo shranjene rezultate kolokvija v obliki:
# 
#     Ime Priimek,N1,N2,N3,N4,N5
# 
# Cela števila od `N1` do `N5` predstavljajo število točk pri posamezni nalogi.
# Zgled:
# 
#     Janez Novak,1,3,3,0,2
# =====================================================================@021890=
# 1. podnaloga
# Sestavite funkcijo `nabor`, ki kot parameter dobi niz z vejico ločenih
# vrednosti v taki obliki, kot je opisano zgoraj. Funkcija naj vrne nabor s
# temi vrednostmi. Pri tem naj točke za posamezne naloge spremeni v števila
# (tj. naj jih ne vrača kot nize).
# 
#     >>> nabor('Janez Novak,1,3,3,0,2')
#     ('Janez Novak', 1, 3, 3, 0, 2)
#     >>> nabor('Janez Horvat,2,4,0')
#     ('Janez Horvat', 2, 4, 0)
# 
# Predpostavite lahko, da so vsi podatki razen prvega res števila. Ni pa nujno,
# da imenu sledi natanko 5 števil.
# =============================================================================
def nabor(niz):
    s = niz.split(',')
    for i in range(1, len(s)):
        s[i] = int(s[i])
    return tuple(s)

#def nabor(niz):
    deli = niz.split(',') #Razdelimo niz na delce z vejico
    ime = deli[0]
    for i in range(0, len(deli)):
        deli[i] = int(deli[i]) #prepišemo niz (deli)
    return tuple(deli)



# =====================================================================@021891=
# 2. podnaloga
# Sestavite funkcijo `nalozi_csv`, ki kot parameter dobi ime datoteke, v kateri
# se nahajajo rezultati kolokvija. Vrstice v tej datoteki so take oblike, kot
# je opisano zgoraj. Funkcija naj vrne seznam naborov; za vsako vrstico po
# enega.
# 
# Primer: Če so v datoteki kolokviji.txt shranjeni naslednji podatki:
# 
#     Janez Novak,1,3,3,0,2
#     Peter Klepec,1,0,1,2,1,3
#     Drago Dragić,7
# 
# potem
# 
#     >>> nalozi_csv('kolokviji.txt')
#     [('Janez Novak', 1, 3, 3, 0, 2), ('Peter Klepec', 1, 0, 1, 2, 1, 3), ('Drago Dragić', 7)]
# =============================================================================
def nalozi_csv(ime):
    rezultat = []
    with open(ime) as f:
        for vrstica in f:
            rezultat.append(nabor(vrstica.strip()))
    return rezultat


def nalozi_csv(datoteka):
    niz = []
    with open(datoteka, 'r', encoding='utf-8') as dat:
        for vrstica in dat:
            niz.append(nabor(vrstica.strip())) #vrstica.strip() odstrani presledke in znak za novo vrstico (\n) na začetku in koncu vrstice.
    return niz



    niz = []
    with open(datoteka, 'r', encoding='utf-8') as dat:
        for vrstica in dat:
            deli = vrstica.split(',')
            ime = deli[0]
            for i in range(1, len(deli)):
                deli[i] = int(deli[i])
            niz.append(tuple(deli))
    return niz
    

# =====================================================================@021892=
# 3. podnaloga
# Sestavite funkcijo `vsote`, ki sprejme imeni vhodne in izhodne datoteke. Iz
# prve naj prebere vrstice s podatki (ki so v taki obliki, kot je opisano
# zgoraj), nato pa naj izračuna vsoto točk za vsakega študenta in v drugo
# datoteko shrani podatke v obliki:
# 
#     Ime Priimek,vsota
# 
# Za vsako vrstico v vhodni datoteki morate zapisati ustrezno vrstico v izhodno
# datoteko.
# 
# Primer: Če je v datoteki kolokviji.txt enaka vsebina kot pri prejšnji
# podnalogi, potem naj bo po klicu `vsote('kolokviji.txt', 'sestevki.txt')` v
# datoteki sestevki.txt naslednja vsebina:
# 
#     Janez Novak,9
#     Peter Klepec,8
#     Drago Dragić,7
# =============================================================================
def vsote(vhodna, izhodna):
    rezultati = []
    
    with open(vhodna, 'r', encoding='utf-8') as dat1:
        for vrstica in dat1:
            deli = vrstica.strip().split(',') # Razdelimo vrstico na delce
            ime = deli[0]  # Ime in priimek je prvi del
            tocke = map(int, deli[1:])  # Preostali deli so števila, pretvorimo jih v int (map(function, iterable))
            vsota = sum(tocke)
            rezultati.append((ime, vsota)) # Dodamo rezultat v seznam kot tuple (ime, vsota)
    
    with open(izhodna, 'w', encoding='utf-8') as dat2:
        for ime, vsota in rezultati:
            dat2.write(f"{ime},{vsota}\n")

#Uradna rešitev:
def vsote(vhodna, izhodna):
    podatki = nalozi_csv(vhodna)
    with open(izhodna, 'w') as f:
        for student in podatki:
            ime = student[0]
            vsota_tock = sum(student[1:]) #namesto map in vsota, zapišeš samo sum
            print(ime + ',' + str(vsota_tock), file=f)

# Alternativna rešitev (uporablja metodo format)
def vsote_2(vhodna, izhodna):
    podatki = nalozi_csv(vhodna)
    with open(izhodna, 'w') as f:
        for student in podatki:
            print('{0},{1}'.format(student[0], sum(student[1:])), file=f)

# =====================================================================@021893=
# 4. podnaloga
# Sestavite funkcijo `rezultati`, ki sprejme imeni vhodne in izhodne datoteke.
# Iz prve naj prebere vrstice s podatki, v drugo pa naj zapiše originalne
# podatke, skupaj z vsotami (na koncu dodajte še en stolpec). Predpostavite, da
# je v vsaki vrstici enako število ocen po posameznih nalogah.
# 
# V zadnjo vrstico naj funkcija zapiše še povprečne ocene po posameznih
# stolpcih, zaokrožene in izpisane na dve decimalni mesti. Ime v tej vrstici
# naj bo `POVPRECEN STUDENT`.
# 
# V izhodni datoteki naj bodo vrstice urejene po priimkih (razen zadnje
# vrstice, v kateri so povprečja). Predpostavite, da ima vsak študent eno ime
# in en priimek, ki sta ločena s presledkom. Ne pozabite na povprečje vsot!
# 
# Primer: Če je na datoteki kolokviji.txt vsebina
# 
#     Janez Novak,1,3,3,2,0
#     Micka Kovačeva,0,3,2,2,3
#     Peter Klepec,1,0,1,2,1
# 
# naj bo po klicu funkcije `rezultati('kolokviji.txt', 'rezultati.txt')` na
# datoteki rezultati.txt naslednja vsebina:
# 
#     Peter Klepec,1,0,1,2,1,5
#     Micka Kovačeva,0,3,2,2,3,10
#     Janez Novak,1,3,3,2,0,9
#     POVPRECEN STUDENT,0.67,2.00,2.00,2.00,1.33,8.00
# =============================================================================
#Uradna rešitev:
def str_seznam(l):
    """
    Dobi seznam l in vrne nov seznam, ki vsebuje iste elemente kot l,
    le da so ti spremenjeni v nize. Če funkcija npr. kot argument dobi
    [2, 3, 5, 7], vrne ['2', '3', '5', '7'].
    """
    l2 = []
    for x in l:
        l2.append(str(x))
    return l2

def rezultati(vhodna, izhodna):
    podatki = nalozi_csv(vhodna)
    # V seznamu seznam bomo podatke hranili v naslednji obliki:
    # ('Klepec', 'Peter', (1,0,1,2,1,5), 10)
    seznam = []
    for student in podatki:
        ime, priimek = student[0].split(' ')
        tocke = student[1:]
        skupaj = sum(tocke)
        seznam.append((priimek, ime, tocke, skupaj))
    seznam.sort() # Ker je prva komponenta priimek, sortira po priimkih !!!
    n = len(seznam) # Število študentov
    m = len(seznam[0][2]) # Število kolokvijev (izračunaj dolžino tretjega elementa prvega elementa v seznamu seznam)
    # Izračunamo vsote po stolpcih
    skupaj_vsota = 0
    tocke_vsota = [0] * m
    for priimek, ime, tocke, skupaj in seznam:
        skupaj_vsota += skupaj
        for i in range(m):
            tocke_vsota[i] += tocke[i]
    # Izračunamo povprečja po stolpcih
    # Povprečne vrednosti shranimo kot nize (z dvema decimalkama)
    skupaj_povpr = '{0:.2f}'.format(skupaj_vsota / n) #(.2f – prikaži ga kot število s plavajočo vejico (float) z dvema decimalnima mestoma)
    tocke_povpr = []
    for t in tocke_vsota: #izpovprečimo celoto
        tocke_povpr.append('{0:.2f}'.format(t / n))
    # Zapišemo podatke na izhodno datoteko
    with open(izhodna, 'w') as f:
        for priimek, ime, tocke, skupaj in seznam:
            tocke_niz = ','.join(str_seznam(tocke))
            print(ime + ' ' + priimek + ',' + tocke_niz + ',' + str(skupaj), file=f)
        print('POVPRECEN STUDENT,' + ','.join(tocke_povpr) + ',' + skupaj_povpr, file=f)
    
# Alternativna rešitev (uporablja izpeljane sezname in lambda funkcije)
def rezultati_2(vhodna, izhodna):
    seznam = nalozi_csv(vhodna)
    # Izračunamo vsote po vrsticah
    n = len(seznam)
    for i in range(n):
        seznam[i] = seznam[i] + (sum(seznam[i][1:]),)
    # Sortiramo po priimkih
    seznam.sort(key=lambda x: x[0].split(' ')[1])
    # Izračunamo povprečja po stolpcih
    m = len(seznam[0])
    povpr = ['POVPRECEN STUDENT'] + ['{0:.2f}'.format(sum(seznam[i][j] for i in range(n)) / n) for j in range(1, m)]
    seznam.append(tuple(povpr))
    # Zapišemo podatke na izhodno datoteko
    with open(izhodna, 'w') as f:
        for vrstica in seznam:
            print(','.join(str(x) for x in vrstica), file=f)

# Pogoste besede
#
# V tej nalogi preštejmo najpogostejše besede v Cankarjevem romanu
# [Na klancu](https://sl.wikisource.org/wiki/Na_klancu).
# Vsebino romana najprej shranite v datoteko `na_klancu.txt`.
# =====================================================================@021898=
# 1. podnaloga
# Sestavite funkcijo `najpogostejse_besede(vhod, st_besed, izhod)`, 
# ki iz dane datoteke `vhod` določi tistih `st_besed` besed, ki se pojavijo
# najpogosteje. Te besede (skupaj z njhovim številom pojavitev) naj funkcija zapiše v datoteko `izhod`, urejene
# po padajočem vrstnem redu glede na število pojavitev.
# 
# Klic funkcije `najpogostejse_besede("na_klancu.txt", 2, "pogosti.txt")`
# bo v datoteko `pogosti.txt` tako zapisal naslednje:
# 
#     je 5692
#     in 3014
# =============================================================================
def najpogostejse_besede(vhod, st_besed, izhod):
    slovar = dict()
    with open(vhod, 'r', encoding='utf-8') as dat1:
        vsebina = dat1.read().lower().strip().replace('\n', ',')
        besede = vsebina.split(',')

    for novabeseda in besede:
        if novabeseda in slovar:
            if novabeseda == '':
                continue
            else:
                slovar[novabeseda] += 1
        else:
            slovar[novabeseda] = 1
    
    sortirani_slovar = dict(sorted(slovar.items(), key=lambda x: x[1]))

    with open(izhod, 'w', encoding='utf-8') as dat2:
        for i in besede:
            if i in sortirani_slovar:
                dat2.write(f"{i} {slovar[i]}\n")
                slovar.pop(i)

# HTML datoteke
# =====================================================================@021899=
# 1. podnaloga
# Sestavite funkcijo `html2txt(vhodna, izhodna)`, ki bo vsebino datoteke
# z imenom `vhodna` prepisala v datoteko z imenom `izhodna`, pri tem pa
# odstranila vse značke.
# 
# Značke se začnejo z znakom `'<'` in končajo z znakom `'>'`. Pozor: Začetek
# in konec značke nista nujno v isti vrstici.
# 
# Na primer, če je v datoteki vreme.html zapisano:
# 
#     <h1>Napoved vremena</h1>
#     <p>Jutri bo <i><b>lepo</b></i> vreme.
#     Več o vremenu preberite <a
#     href="http://www.arso.gov.si/">tukaj</a>.</p>
# 
# bo po klicu `html2txt('vreme.html', 'vreme.txt')` v datoteki vreme.txt
# zapisano:
# 
#     Napoved vremena
#     Jutri bo lepo vreme.
#     Več o vremenu preberite tukaj.
# =============================================================================
def html2txt(vhodna, izhodna):
    znacka = False # Stikalo, ki pove, če smo znotraj HTML značke.
    with open(vhodna) as html:
        with open(izhodna, 'w') as txt:
            for vrstica in html:
                txt_vrstica = ''
                for znak in vrstica:
                    if znak in '<>': #bere po besedah in tako določi
                        znacka = not znacka
                    elif not znacka:
                        txt_vrstica += znak
                # Opomba: pri klicu funkcije print smo uporabili imenovani
                # parameter end='', s čimer smo preprečili, da bi print na
                # koncu izpisal znak '\n' !
                print(txt_vrstica, file=txt, end='')



'''import re

def html2txt(vhodna, izhodna):
    with open(vhodna, 'r', encoding='utf-8') as f:
        vsebina = f.read()
    
    # Odstrani vse značke: kar je med < in >
    besedilo = re.sub(r'<.*?>', '', vsebina, flags=re.DOTALL)

    with open(izhodna, 'w', encoding='utf-8') as f:
        f.write(besedilo)
'''

# =====================================================================@021900=
# 2. podnaloga
# Sestavite funkcijo `tabela(ime_vhodne, ime_izhodne)`, ki bo podatke
# iz vhodne datoteke zapisala v obliki HTML tabele v izhodno datoteko.
# 
# V vhodni datoteki so podatki shranjeni po vrsticah ter ločeni z vejicami.
# Na primer, če je v datoteki tabela.txt zapisano:
# 
#     ena,dva,tri
#     17,52,49.4,6
#     abc,xyz
# 
# bo po klicu `tabela('tabela.txt', 'tabela.html')` v datoteki tabela.html
# zapisana naslednja vsebina:
# 
#     <table>
#       <tr>
#         <td>ena</td>
#         <td>dva</td>
#         <td>tri</td>
#       </tr>
#       <tr>
#         <td>17</td>
#         <td>52</td>
#         <td>49.4</td>
#         <td>6</td>
#       </tr>
#       <tr>
#         <td>abc</td>
#         <td>xyz</td>
#       </tr>
#     </table>
# 
# Pozor: Pazi na zamik (število presledkov na začetku vrstic) v izhodni
# datoteki.
# =============================================================================
def tabela(ime_vhodne, ime_izhodne):
    with open(ime_vhodne) as vhodna:
        with open(ime_izhodne, 'w') as izhodna:
            print('<table>', file=izhodna)
            for vrstica in vhodna:
                print('  <tr>', file=izhodna)
                podatki = vrstica.strip().split(',')
                for podatek in podatki:
                    print('    <td>' + podatek + '</td>', file=izhodna) # dodatni presledki so zaradi oblike;, pomembno!
                print('  </tr>', file=izhodna)
            print('</table>', file=izhodna)


# =====================================================================@021901=
# 3. podnaloga
# Sestavite funkcijo `seznami(ime_vhodne, ime_izhodne)`, ki bo podatke
# iz vhodne datoteke zapisala v izhodno datoteko v obliki neurejenega
# seznama. V vhodni datoteki se vrstice seznamov začnejo z zvezdico.
# 
# Na primer, če je v datoteki seznami.txt zapisano:
# 
#     V trgovini moram kupiti:
#     * jajca,
#     * kruh,
#     * moko.
#     Na poti nazaj moram:
#     * obiskati sosedo.
# 
# bo po klicu funkcije `seznami('seznami.txt', 'seznami.html')` v datoteki
# seznami.html naslednja vsebina:
# 
#     V trgovini moram kupiti:
#     <ul>
#       <li>jajca,</li>
#       <li>kruh,</li>
#       <li>moko.</li>
#     </ul>
#     Na poti nazaj moram:
#     <ul>
#       <li>obiskati sosedo.</li>
#     </ul>
# =============================================================================
def seznami(ime_vhodne, ime_izhodne):
    seznam = False # Stikalo, ki pove, če smo znotraj seznama.
    with open(ime_vhodne) as vhodna:
        with open(ime_izhodne, 'w') as izhodna:
            for vrstica in vhodna:
                if vrstica[0] == '*': # vemo, da se pojavi lahko samo na prvem mestu
                    if not seznam:
                        seznam = True
                        print('<ul>', file=izhodna)
                        
                    print('  <li>' + vrstica[1:].strip() + '</li>', file=izhodna) #vrstica[1:].strip()-prvo mesto odstranimo in napišemo naprej; ods. /n
                else:
                    if seznam:
                        seznam = False
                        print('</ul>', file=izhodna) # vmesne zaključitve
                    print(vrstica, file=izhodna, end='')
            if seznam:
                print('</ul>', file=izhodna) #da zaključimo seznem


# =====================================================================@021902=
# 4. podnaloga
# Sestavite funkcijo `gnezdeni_seznami(ime_vhodne, ime_izhodne)`, ki bo
# podatke iz vhodne datoteke zapisala v izhodno datoteko v obliki neurejenega
# gnezdenega seznama. V vhodni datoteki je vsak element seznama v svoji
# vrstici, zamik pred elementom pa določa, kako globoko je element gnezden.
# Zamik bo vedno večkratnik števila 2. 
# 
# Na primer, če je v datoteki seznami.txt zapisano:
# 
#     zivali
#       sesalci
#         slon
#       ptiči
#         sinička
#     rastline
#       sobne rastline
#         difenbahija
# 
# bo po klicu `gnezdeni_seznami('seznami.txt', 'seznami.html')` v datoteki
# seznami.html zapisano:
# 
#     <ul>
#       <li>živali
#         <ul>
#           <li>sesalci
#             <ul>
#               <li>slon
#             </ul>
#           <li>ptiči
#             <ul>
#               <li>sinička
#             </ul>
#         </ul>
#       <li>rastline
#         <ul>
#           <li>sobne rastline
#             <ul>
#               <li>difenbahija
#             </ul>
#         </ul>
#     </ul>
# 
# Značk `<li>` ne zapirajte.
# =============================================================================
def gnezdeni_seznami(ime_vhodne, ime_izhodne):
    nivo = 0
    zamik = 2
    with open(ime_vhodne) as vhodna:
        with open(ime_izhodne, 'w') as izhodna:
            for vrstica in vhodna:
                prvi = 0 # Prvi znak, ki ni presledek.
                while vrstica[prvi] == ' ':
                    prvi += 1
                n = prvi // zamik + 1
                vrstica = vrstica.strip()
                if n > nivo:
                    print(2*zamik*nivo*' ' + '<ul>', file=izhodna)
                    nivo += 1
                while n < nivo:
                    nivo -= 1
                    print(2*zamik*nivo*' ' + '</ul>', file=izhodna)
                print((2*zamik*nivo - zamik)*' ' + '<li>' + vrstica, file=izhodna)
            while nivo > 0:
                nivo -= 1
                print(2*zamik*nivo*' ' + '</ul>', file=izhodna)


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
UTRJEVANJE 2:
# Tekmovanje
#
# Na tekmovanju tekmuje več ekip, vsaka ekipa ima več članov. Vsak član
# mora samostojno v čim krajšem času opraviti vsako od posameznih iger.
# Dosežene čase zapišemo na datoteko, kjer vsakemu članu namenimo eno vrstico,
# sestavljeno iz imena ekipe, imena člana in doseženih časov (cela števila).
# Predpostavimo, da imajo vsi člani iste ekipe različna imena.
# Podatke ločimo z vejicami, če član katere od iger ni opravil,
# pa ustreznega časa ne zapišemo. Morebitnih vejic na koncu vrstic ne pišemo.
# Primer takšne datoteke bi bila datoteka `tekma.txt` z vsebino:
# 
#     FMF,Janez,23,15,,34,22
#     FRI,Sonja,26,,36
#     FMF,Marija,25,12,,,27
#     FE,Ana,,18,,14
#     FRI,Miha,27,16,34,22
#     FRI,Matej
#     FE,Bine,,19,24,18
# 
# Ekipo FMF sestavljata Janez in Marija, ekipo FRI Sonja, Miha in Matej,
# ekipo FE pa Ana in Bine. Pomerili so se v petih igrah, nihče pa ni opravil
# vseh iger.
# =====================================================================@042576=
# 1. podnaloga
# Sestavite funkcijo `preberi`, ki iz datoteke prebere podatke o izvedenem
# tekmovanju. Za parameter naj dobi ime datoteke, vrne pa naj slovar, kjer
# so ključi imena ekip, vrednosti pa slovarji, ki imajo za ključe imena članov,
# za vrednosti pa sezname doseženih časov. Če igra ni opravljena, za dosežen
# čas zapišemo vrednost `None`. Vrednosti `None` na koncu seznama ne pišemo.
# 
#     >>> preberi("tekma.txt")
#     {"FMF": {"Janez": [23, 15, None, 34, 22], "Marija": [25, 12, None, None, 27]},
#      "FRI": {"Sonja": [26, None, 36], "Miha": [27, 16, 34, 22], "Matej": []},
#      "FE": {"Ana": [None, 18, None, 14], "Bine": [None, 19, 24, 18]}}
# =============================================================================
def preberi(datoteke):
    slovar = {}
    with open(datoteke, 'r', encoding='utf-8') as dat:
        # preberemo vrstico po vrstico
        for vrstica in dat:
            # v seznam splitiramo po vejici
            vrstica_sez = vrstica.strip().split(',')
            # ustrezno preberemo podatke
            ekipa = vrstica_sez[0]
            ime = vrstica_sez[1]
            tocke = vrstica_sez[2:]
            # če ekipe še ni v slovarju jo dodamo
            if ekipa not in slovar.keys():
                slovar[ekipa] = {}
            # dobimo ime in prave_tocke
            prave_tocke = []
            for t in tocke:
                if t == '':
                    prave_tocke.append(None)
                else:
                    prave_tocke.append(int(t))
            slovar[ekipa][ime] = prave_tocke
        return slovar
    

#Uradna rešitev:
def preberi(datoteka):
    slovar = {}
    for vrstica in open(datoteka):
        ekipa, clan, *casi = vrstica.strip().split(',')
        if ekipa not in slovar: slovar[ekipa] = {}
        slovar[ekipa][clan] = [int(cas) if len(cas) > 0 else None for cas in casi]
    return slovar

# =====================================================================@042577=
# 2. podnaloga
# Sestavite funkcijo `najboljsi_casi`, ki za parameter dobi ime datoteke
# s podatki o izvedenem tekmovanju, vrne pa slovar, kjer so ključi imena
# ekip, vrednosti pa seznami najboljših časov, ki so jih dosegli člani ekipe
# pri posameznih igrah.
# 
#     >>> najboljsi_casi("tekma.txt")
#     {"FE": [None, 18, 24, 14], "FMF": [23, 12, None, 34, 22], "FRI": [26, 16, 34, 22]}
# =============================================================================
'''def najboljsi_casi(datoteke):
    slovar = {}
    podatki = preberi(datoteke)
    for skupina in podatki.keys():
        najboljsi = podatki[skupina][list(podatki[skupina].keys())[0]]
        for oseba in podatki[skupina].keys():
                seznam_tock = podatki[skupina][oseba]
                for i in range(len(seznam_tock)):
                    if seznam_tock[i] != None and najboljsi[i] != None:
                        if seznam_tock[i] < najboljsi[i]:
                            najboljsi = seznam_tock[i]
        slovar[skupina] = najboljsi 
    return slovar
'''

#Uradna rešitev:
def najboljsi_casi(datoteka):
    slovar = {}
    podatki = preberi(datoteka)
    for ekipa in podatki:
        seznam = []
        for casi in podatki[ekipa].values():
            for i, cas in enumerate(casi):  # i števec, ki označuje indeks časa v posamezni štafeti.
                if i >= len(seznam): seznam.append(None)
                if cas == None: continue
                if seznam[i] == None or cas < seznam[i]: seznam[i] = cas
        slovar[ekipa] = seznam
    return slovar

# =====================================================================@042578=
# 3. podnaloga
# Sestavite funkcijo `lestvica`, ki za parameter dobi ime datoteke
# s podatki o izvedenem tekmovanju, vrne pa lestvico tekmovanja, to je
# seznam ekip od najboljše do najslabše, pri čemer ekipo zapišemo kot
# trojico (ime ekipe, število iger, skupni čas). Ekipa je boljša od druge,
# če je opravila več iger ali pa je pri enakem številu iger dosegla boljši čas.
# Predpostaviš lahko, da ni ekip, ki bi dosegle enaka rezultata.
# 
#     >>> lestvica("tekma.txt")
#     [("FMF", 4, 91), ("FRI", 4, 98), ("FE", 3, 56)]
# =============================================================================
def lestvica(datoteka):
    seznam = []
    podatki = najboljsi_casi(datoteka)
    for ekipa, casi in podatki.items():
        s = [cas for cas in casi if cas != None]
        seznam.append((ekipa, len(s), sum(s)))
    seznam.sort(key=lambda x: (-x[1], x[2]))
    return seznam

# Knjige so naše največje bogastvo
#
# Knjižnica se je modernizirala in pridni knjižničarji so vsako knjigo
# pretipkali v elektronsko obliko. Datoteke, kamor so jih pretipkali,
# so podvržene strogemu knjižničarskemu redu in vse po vrsti sledijo naslednji
# obliki:
# 
# 1. V prvi vrstici so avtorji, ločeni z vejico, ki ji sledi presledek,
#    npr. `Ana Ban, Samo Kralj` ali pa samo `Franco Mercatori`.
# 2. V drugi vrstici je naslov, npr. `Slava vojvodinje Francke`.
# 3. V preostalih vrsticah je vsebina dela.
# 
# V `datoteka1.txt` se lahko tako npr. nahaja
# 
#     Ivan Cankar, Jurij Profesor
#     Sile na klancu
#     Predgovor
#     Dragi bralec, če na prekmurskih ravnicah živiš, ta knjiga ti
#     ne bo v tak poduk in korist, kot če ...
#     ...
#     S tem pa tudi zaključujeva razpravo o tej tematiki in se bralcu,
#     ki je do samega konca zdržal, najiskreneje zahvaljujeva.
# 
# medtem kot je v `datoteka2.txt` najti tole:
# 
#     Franco Mercatori
#     Poslovna matematika
#     V tem učbeniku bralca naučimo, kako uspešno trgovati.
#     ...
#     Opomba: s prebranjem knjige ste avtorju dolžni 5 evrov.
# =====================================================================@042570=
# 1. podnaloga
# Kot zunanji sodelavec si želiš najprej ustvariti pregled nad tem, kaj je
# bilo pretipkano. Napiši funkcijo `pregled_del(datoteke)`, ki sprejme seznam
# imen datotek in vrne slovar, katerega ključi so avtorji, vrednosti pa
# seznam imen datotek, v katerih so dela, katerih (so)avtor je pripadajoči ključ.
# 
#     >>>> pregled_del(["datoteka1.txt", "datoteka2.txt"])
#     {"Ivan Cankar": ["datoteka1.txt"], "Jurij Profesor": ["datoteka1.txt"], "Franco Mercatori": ["datoteka2.txt"]}
# 
# Če se datoteka `A` v seznamu `datoteke` pojavi pred datoteko `B`,
# naj bo tako tudi v seznamih v slovarju (če sta to deli istega avtorja).
# =============================================================================
def pregled_del(datoteke):
    slovar = {}
    for datoteka in datoteke:
        with open(datoteka, encoding="utf-8") as f:
            avtorji = f.readline().strip().split(", ") # prebere to/prvo vrstico
        for avtor in avtorji:
            if avtor not in slovar:
                slovar[avtor] = []
            slovar[avtor].append(datoteka) # .update ni metoda za sezname!
    return slovar

'''for i, datoteka in enumerate(datoteke):
    if i == 0:
        with open(datoteka, encoding="utf-8") as f:
            vrstica = f.readline()''' #za branje prve vrstice


# =====================================================================@042571=
# 2. podnaloga
# Po prebrani Poslovni matematiki začutiš poslovno priložnost: izdaš lahko
# zbrana dela danega avtorja. Napiši funkcijo `zbrana_dela(avtor, datoteke, izhod)`,
# ki sprejme ime avtorja, seznam imen datotek, v katerih so dela,
# in ime izhodne datoteke `izhod`.
# Funkcija naj v izhodno datoteko zapiše
# 
# 1. ime avtorja (morebitne preostale soavtorje izpustimo)
# 2. niz `Zbrana dela`
# 3. naslov in vsebino vseh del, pri katerih je `avtor` sodeloval.
# 
# Vrsti red del naj bo tak kot v seznamu `datoteke`. Če npr. združimo deli
# 
#     Miran Učitelj
#     Števila do 3
#     1
#     2
#     3
# 
# in
# 
#     Miran Učitelj
#     Števili 4 in 5
#     4
#     5
# 
# naj bo izhodna datoteka
# 
#     Miran Učitelj
#     Zbrana dela
#     Števila do 3
#     1
#     2
#     3
#     Števili 4 in 5
#     4
#     5
# =============================================================================
def zbrana_dela(avtor, datoteke, izhod):
    dela_avtorja = pregled_del(datoteke)[avtor]
    with open(izhod, "w", encoding="utf-8") as f:
        print(avtor, file=f)
        print("Zbrana dela", file=f) # vsak print(...) po privzetem zaključi vrstico z znakom za novo vrstico (\n)
        for delo in dela_avtorja:
            with open(delo, encoding="utf-8") as g:
                g.readline()  # preskok avtorja, samo prebere, nič ne zapiše
                for vrstica in g:
                    print(vrstica, end="", file=f)



# =====================================================================@042572=
# 3. podnaloga
# Nekateri avtorji so enostavno preplodoviti, da bi lahko njihova dela
# izdali zgolj v eni knjigi (poleg tega lahko zaslužiš več, če
# izdaš več knjig). Napiši funkcijo `zbrana_dela_razdeljeno(avtor, datoteke, izhodi)`,
# kjer sta argumenta `avtor` in `datoteke` kot pri prejšnji podnalogi, seznam `izhodi`
# pa je seznam izhodnih datotek, kamor želimo zapisati zbrana dela.
# 
# Ker želimo, da so si velikosti knjig podobne, bomo izhodne datoteke polnili tako,
# da damo vsebino trenutnega dela v seznamu `datoteke` v tisti izhod, ki ima trenutno
# najmanj vrstic.
# Če je takih izhodov več, ga damo v prvega med njimi (glede na seznam `izhodi`).
# Privzamete lahko, da je vhodov vsaj toliko kot izhodov.
# 
# Denimo, da združujemo `dat1.txt`, `dat2.txt` in `dat3.txt`, ki imajo po vrsti vsebino
# 
#     Miran Učitelj
#     Števila do 3
#     1
#     2
#     3
# 
# in
# 
#     Miran Učitelj
#     Števili 4 in 5
#     4
#     5
# 
# in
# 
#     Miran Učitelj
#     Število 6
#     6
# 
# Če želimo to objaviti v zbranih delih `["izh1.txt", "izh2.txt"]`, bo
# `izh1.txt` na koncu vseboval
# 
#     Miran Učitelj
#     Zbrana dela
#     Števila do 3
#     1
#     2
#     3
# 
# medtem ko bo `izh2.txt` vseboval
# 
#     Miran Učitelj
#     Zbrana dela
#     Števili 4 in 5
#     4
#     5
#     Število 6
#     6
# =============================================================================
def zbrana_dela_razdeljeno(avtor, datoteke, izhodi):
    dela_avtorja = pregled_del(datoteke)[avtor]
    stevilo_vrstic = {izhod: 0 for izhod in izhodi}
    for delo in dela_avtorja:
        # najdimo primeren izhod
        opt_dolzina = float("inf")
        opt_izhod = "noben"
        for izhod in izhodi:
            if stevilo_vrstic[izhod] < opt_dolzina:
                opt_dolzina = stevilo_vrstic[izhod]
                opt_izhod = izhod
                # lahko break ce opt_dolzina = 0
        # zapisimo delo
        with open(opt_izhod, "a", encoding="utf-8") as f:
            if opt_dolzina == 0:
                # to je prvo delo, dopisati moramo tudi avtorja
                # in Zbrana dela
                print(avtor, file=f)
                print("Zbrana dela", file=f)
                opt_dolzina += 2
            with open(delo, encoding="utf-8") as g:
                g.readline()  # preskok avtorja
                for vrsta in g:
                    print(vrsta, end="", file=f)
                    opt_dolzina += 1
        # posodobimo stevilo vrstic
        stevilo_vrstic[opt_izhod] = opt_dolzina


import heapq
def zbrana_dela_razdeljeno(avtor, datoteke, izhodi):
    dela_avtorja = pregled_del(datoteke)[avtor]
    n_izhodov = len(izhodi)  # brez dodatne predpostavke: min(len(datoteke), len(izhodi))
    for i in range(n_izhodov):
        with open(izhodi[i], "w", encoding="utf-8") as f:
            print(avtor, file=f)
            print("Zbrana dela", file=f)
    izhodne_datoteke = [(2, i) for i in range(n_izhodov)]  # (n vrstic, stevilka izhoda)
    heapq.heapify(izhodne_datoteke)
    for delo in dela_avtorja:
        opt_dolzina, i = heapq.heappop(izhodne_datoteke)
        with open(izhodi[i], "a", encoding="utf-8") as f:
            with open(delo, encoding="utf-8") as g:
                g.readline()
                for vrsta in g:
                    print(vrsta, end="", file=f)
                    opt_dolzina += 1
        heapq.heappush(izhodne_datoteke, (opt_dolzina, i))

# Podnapisi
#
# Podnapise za video datoteke dobimo v ločenih datotekah. Eden bolj razširjenih
# formatov za podnapise je tekstovni format SRT, kot je prikazano v spodnjem
# primeru (datoteka `'podnapisi.srt'`):
# 
#     1
#     00:01:26,872 --> 00:01:28,705
#     Yes, Mr. Burnish,
# 
#     2
#     00:01:28,707 --> 00:01:30,807
#     the venue
#     is completely sold out.
# 
# Vsebina datoteke SRT je sestavljena iz več *blokov*. V prvi vrstici bloka
# je zaporedna številka podnapisa, v drugi vrstici sta začetni in končni čas
# podnapisa (ločena sta s puščico), sledi pa ena ali več vrstic besedila.
# Bloki so ločeni s prazno vrstico. Tudi za zadnjim blokom lahko imamo še
# kakšno prazno vrstico.
# =====================================================================@042573=
# 1. podnaloga
# Sestavi funkcijo `preberi(ime_datoteke)`, ki sprejme ime datoteke, jo prebere
# in vrne seznam blokov. Blok predstavimo kot večvrstičen niz. Prazna vrstica
# ni del bloka. Za primer iz uvoda bi dobili:
# 
#     >>> preberi('podnapisi.srt')
#     ['1\n00:01:26,872 --> 00:01:28,705\nYes, Mr. Burnish,',
#     '2\n00:01:28,707 --> 00:01:30,807\nthe venue\nis completely sold out.']
# =============================================================================
def preberi(ime_datoteke):
    with open(ime_datoteke) as dat:
        bloki = dat.read().strip().split("\n\n") # .split("\n\n"): razdeli besedilo na dele (bloke), kjer sta dve prazni vrstici zapored
    return bloki


# =====================================================================@042574=
# 2. podnaloga
# Sestavi funkcijo `popravi_cas(cas, tisocinke)`, ki sprejme čas kot niz oblike
# `"hh:mm:ss,ttt"` in vrne nov niz enake oblike, kjer se času prišteje
# (ali odšteje) `tisocinke` tisočink.
# 
#     >>> popravi_cas('00:09:59,000', 1000)
#     '00:10:00,000'
#     >>> popravi_cas('00:09:10,731', -800)
#     '00:09:09,931'
# =============================================================================
def popravi_cas(cas, tisocinke):
    hh, mm, ssttt = cas.split(":") # dobiš elemente, ki jih splitaš
    ss, ttt = ssttt.split(",") # dobiš elemente, ki jih splitaš (da se znebiš vejice)
    cas = 1000 * (60 * (60 * int(hh) + int(mm)) + int(ss)) + int(ttt)
    cas += tisocinke
    ttt = cas % 1000
    ss = cas // 1000 % 60
    mm = cas // 60000 % 60
    hh = cas // 3600000 
    return "{:02d}:{:02d}:{:02d},{:03d}".format(hh, mm, ss, ttt) # {:02d} pomeni: cela števila, z vsaj 2 števkama, dopolnjena z ničlami spredaj, če je treba.


# =====================================================================@042575=
# 3. podnaloga
# Sestavi funkcijo `zamakni_podnapis(ime_vhod, ime_izhod, tisocinke)`,
# ki prebere podnapise v datoteki `ime_vhod` in za `tisocinke` tisočink
# popravi čas, nove podnapise pa zapiše v datoteko `ime_izhod`. Število
# praznih vrstic na koncu izhodne datoteke ni pomembno. Po klicu
# 
#     >>> zamakni_podnapis('podnapisi.srt', 'popravljen.srt', 972)
# 
# bi dobili datoteko `'popravljen.srt'` z naslednjo vsebino
# 
#     1
#     00:01:27,844 --> 00:01:29,677
#     Yes, Mr. Burnish,
# 
#     2
#     00:01:29,679 --> 00:01:31,779
#     the venue
#     is completely sold out.
# =============================================================================
def zamakni_podnapis(ime_vhod, ime_izhod, tisocinke):
    bloki = preberi(ime_vhod)
    with open(ime_izhod, "w") as dat:
        for blok in bloki:
            blok_po_delih = blok.split("\n")
            cas_zacetek, cas_konec = blok_po_delih[1].split(" --> ")
            cas_zacetek = popravi_cas(cas_zacetek, tisocinke)
            cas_konec = popravi_cas(cas_konec, tisocinke)
            blok_po_delih[1] = "{} --> {}".format(cas_zacetek, cas_konec)
            print("\n".join(blok_po_delih), file=dat)
            print(file=dat)

# Prijave na izpit
#
# Pri prijavah na izpit iz Uvoda v programiranje je prišlo do velike zmešnjave.
# Ker so izvajalci pozabili razpisati ločena izpitna roka za pisanje na lastnih
# in šolskih računalnikih, so morali izvesti anketo med študenti glede njihovega
# izbranega načina pisanja izpita, da bi rezervirali ustrezno število učilnic
# in ustrezno razporedili študente. 
# Pomagajte jim obdelati podatke, da bo izpit potekal čim manj kaotično. :)
# =====================================================================@042567=
# 1. podnaloga
# Podatke iz VIS-a in z učilnice so izvajalci izvozili v dve datoteki:
# 
# Datoteka iz VIS-a vsebuje podatke o vpisni številki, imenu in priimku. 
# 
# Datoteka s spletne učilnice vsebuje poleg imena študenta še
# njegovo izbiro glede pisanja izpita (`"Na svojem"` oziroma `"Na šolskem"`). 
# V tabeli so vključeni vsi študenti, ki so na spletni učilnici vpisani v predmet.
# Tisti, ki na anketo niso odgovorili imajo v stolpcu izbira zapisan niz `"Ni izbire"`.
# 
# Primera datotek:
# 
#     prijave_vis.csv:                      izbire_moodle.csv:
#     
#     vpisna št,ime,priimek                 ime,priimek,izbira
#     12229283,Ana,Novak                    Ana,Novak,Na svojem
#     12222843,Luka,Kovač                   Marko,Kos,Ni izbire
#     12222471,Petra,Čeh                    Luka,Kovač,Na svojem
#     12222481,Matej,Horvat                 Nika,Zupan,Na šolskem
#     12216131,Nika,Zupan                   Maja,Potočnik,Ni izbire
#     12217842,Marko,Kos                    Jan,Žnidar,Na svojem
#                                           Tim,Gorišek,Na šolskem
# 
# Napišite funkcijo `podatki_o_prijavah(datoteka_vis, datoteka_moodle)`, ki sprejme
# poti do datoteke s podatki iz študijskega sistema (`datoteka_vis`) ter datoteke
# s podatki iz spletne učilnice (`datoteka_moodle`). Funkcija naj vrne par slovarjev,
# s podatki v datotekah. Oba slovarja naj imata za ključe par imena in priimka,
# v prvem naj bo pod vrednostjo zapisana vpisna številka, v drugem pa način pisanja.
# 
# Če uporabimo zgornji datoteki, naj funkcija vrne takšen rezultat:
# 
#     >>> podatki_o_prijavah('prijave_vis.csv', 'izbire_moodle.csv')
#     ({('Ana', 'Novak'): '12229283', ('Luka', 'Kovač'): '12222843', ..., ('Marko', 'Kos'): '12217842'}, 
#      {('Ana', 'Novak'): 'Na svojem', ('Marko', 'Kos'): 'Ni izbire', ..., ('Tim', 'Gorišek'): 'Na šolskem'})
# 
# Opomba: zaradi preglednosti izpisa je nekaj elementov slovarjev v izpisu nadomeščenih s tremi pikami.
# =============================================================================
def podatki_o_prijavah(datoteka_vis, datoteka_moodle):
    prijave = {}
    with open(datoteka_vis, encoding='utf8') as f:
        f.readline() # # preskočiš prvo vrstico (npr. glavo CSV datoteke)
        for vrstica in f:
            vpisna, ime, priimek = vrstica.strip().split(",")
            prijave[(ime, priimek)] = vpisna
    
    izbire = {}
    with open(datoteka_moodle, encoding='utf8') as f:
        f.readline()
        for vrstica in f:
            ime, priimek, izbira = vrstica.strip().split(',')
            izbire[(ime, priimek)] = izbira
    
    return prijave, izbire


# Primeri branja:
'''with open(datoteka_moodle, encoding='utf8') as f:
    f.readline()  # preskoči glavo
    for vrstica in f:
        ...

with open(datoteka_moodle, encoding='utf8') as f:
    vrstice = f.readlines()
    for vrstica in vrstice[1:]:  # od druge naprej
        ...'''


# =====================================================================@042568=
# 2. podnaloga
# Ob pregledu podatkov iz obeh virov se je izkazalo, da se med prijavljenimi
# študenti najdejo študenti, ki niso odgovorili na anketo, med tistimi, ki so izpolnili 
# anketo pa študenti, ki niso prijavljeni na izpit. V izogib težavam na
# dan izpita je pomembno, da ugotovimo, kateri študenti niso prijavljeni, a
# se izpita vseeno nameravajo udeležiti.
# 
# Sestavite funkcijo `poisci_neprijavljene(prijave_vis, izbire_moodle)`, 
# ki sprejme slovarja, kot ju dobimo s pomočjo funkcije iz prve naloge, in vrne
# množico študentov, ki niso prijavljeni na izpit. Neprijavljeni študenti so
# tisti, ki imajo v slovarju izbir vrednost "Na svojem" ali "Na šolskem", ni
# pa jih v slovarju VIS prijav.
# 
# 
# Primer:
# 
#     >>> slovar_vis = {("Ana", "Novak"): "12229283", ("Luka", "Kovač"): "12222843"}
#     >>> slovar_moodle = {("Ana", "Novak"): "Na svojem", ("Petra", "Čeh"): "Na šolskem", ("Maja", "Potočnik"): "Ni izbire", ("Jan", "Žnidar"): "Na svojem", ("Sara", "Vidmar"): "Na šolskem"}
#     >>> poisci_neprijavljene(slovar_vis, slovar_moodle)
#     {("Petra", "Čeh"), ("Jan", "Žnidar"), ("Sara", "Vidmar")}
# =============================================================================
# Uradna rešitev:
def poisci_neprijavljene(prijave, izbire):
    prijave_mnozica = set(prijave)
    izbire_mnozica = {ime_priimek for ime_priimek in izbire if izbire[ime_priimek] != "Ni izbire"}

    return izbire_mnozica - prijave_mnozica

# brez izpeljanih množic
def poisci_neprijavljene_v2(prijave, izbire):
    neprijavljeni = set()
    for ime_priimek, izbira in izbire.items():
        if ime_priimek not in prijave and izbira != "Ni izbire":
            neprijavljeni.add(ime_priimek)
    return neprijavljeni



# =====================================================================@042569=
# 3. podnaloga
# Izvajalci predmeta potrebujejo pomoč pri razporejanju študentov v skupine.
# Pomagajte jim sestaviti funkcijo `razdeli_skupine(prijave, izbire, datoteka)`,
# ki bo na podlagi podanega slovarja prijav (VIS) in slovarja izbir (z učilnice) 
# v izhodno datoteko `datoteka` zapisala razpored študentov (po vpisnih številkah) 
# v skupine. Vpisne številke znotraj skupine naj bodo urejene naraščajoče.
# Če v skupino ni prijavljen noben študent, naj se ta skupina ne izpiše.
# Pri tem naj upošteva le študente, ki so na izpit prijavljeni, saj za neprijavljene 
# ne poznamo vpisnih številk.
# 
# Za slovarja:
# 
#     prijave = {
#         ("Ana", "Novak"): "12229283",
#         ("Matej", "Horvat"): "12222481",
#         ("Nika", "Zupan"): "12216131",
#         ("Petra", "Čeh"): "12222471",
#         ("Marko", "Kos"): "12217842",
#         ("Luka", "Kovač"): "12222843",
#     }
#     
#     izbire = {
#         ("Ana", "Novak"): "Na svojem",
#         ("Luka", "Kovač"): "Na svojem",
#         ("Petra", "Čeh"): "Na svojem",
#         ("Matej", "Horvat"): "Na šolskem",
#         ("Nika", "Zupan"): "Na šolskem",
#         ("Marko", "Kos"): "Ni izbire",
#         ("Maja", "Potočnik"): "Ni izbire",
#         ("Jan", "Žnidar"): "Na svojem", 
#     }
# 
# Naj po klicu `razdeli_skupine(prijave, izbire, "skupine.txt")` datoteka
# `skupine.txt` izgleda tako:
# 
#     Na svojem:
#     - 12222843
#     - 12222471
#     - 12229283
#     
#     Na šolskem:
#     - 12216131
#     - 12222481
#     
#     Ni izbire:
#     - 12217842
# =============================================================================
def razdeli_skupine(prijave, izbire, datoteka):
    skupine = {"Na svojem": [], "Na šolskem": [], "Ni izbire": []}
    for (ime, priimek), vpisna in prijave.items():
        izbira = izbire.get((ime, priimek)) # preverimo kaj je njegova izbira
        skupine[izbira].append(vpisna) # dodoamo številko v slovar skladno z izbiro

    with open(datoteka, 'w', encoding="utf-8") as f:
        for skupina in ["Na svojem", "Na šolskem", "Ni izbire"]:
            if skupina not in skupine or len(skupine[skupina]) == 0: # preveri ali je prazna
                continue
            print(f"{skupina}:", file=f)
            for student in sorted(skupine[skupina]): # razvrsti številke
                print(f"- {student}", file=f) # zapiše kar je v "" v f (f"- {student}")
            print("", file=f) # konča s prazno vrstico


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
NUMPY I.:
# Osnove numpy
# =====================================================================@023119=
# 1. podnaloga
# Numpy tabelo lahko ustvarimo na več načinov. Ustvarimo jo lahko enostavno iz
# seznama z funkcijo `np.array()`. Definiraj funkcijo `kvadrat(n)`, ki sestavi
# tabelo dolžine $n$, kjer so elementi kvadrati indeksa.
# 
# Primer:
# 
#     >>> kvadrat(5)
#     array([0, 1, 4, 9, 16])
# =============================================================================
import numpy as np
def kvadrat(n):
    return np.array([i**2 for i in range(n)])

#def kvadrat(n):
    np.arange(0,n) ** 2
# =====================================================================@023120=
# 2. podnaloga
# Definiramo pa jih lahko tudi drugače. Lahko že v naprej s funkcijo `np.ones()`
# ali pa `np.zeros()` ustvarimo numpy tabelo željenih dimenzij, potem pa jo
# uredimo.
# 
# Sestavi funkcijo `tabela_enic(dim1, dim2)`, ki za argumenta sprejme
# dimenzijo tabele in vrne dvodimenzionalno tabelo željenih dimenzij zapolnjeno
# z enicami.
# 
# Primer:
# 
#     >>> tabela_enic(2, 2)
#     array([[1., 1.]
#            [1., 1.]])
# 
#     >>> tabela_enic(3, 2)
#     array([[1., 1.],
#            [1., 1.],
#            [1., 1.]])
# =============================================================================
import numpy as np
def tabela_enic(dim1, dim2):
    return np.array(np.ones((dim1, dim2)))
# =====================================================================@023121=
# 3. podnaloga
# Sestavi funkcijo `simetrija(dim1, dim2)`, ki sprejme dimenzije tabele in vrne
# tabelo v kateri je vsak element vsota indeksov. $$a[i, j] = i + j$$
# 
# Primer:
# 
#     >>> simetrija(2, 2)
#     array([[0., 1.]
#            [1., 2.]])
# 
#     >>> simetrija(2, 3)
#     array([[0., 1., 2.]
#            [1., 2., 3.]])
# =============================================================================
import numpy as np
def simetrija(dim1, dim2):
    tabela = np.zeros((dim1, dim2))
    for i in range(dim1):
        for j in range(dim2):
            tabela[i, j] = i + j
    return tabela
# =====================================================================@023122=
# 4. podnaloga
# Zdaj pa je čas da uporabiš moč `numpy`. Operacije med numpy tabelami so zelo
# enostavne. Tako lahko dve tabeli med seboj sešteješ kar z simbolom `+` in
# se bosta element za elementom seštela. Enako velja tudi za množenje, deljenje,
# celoštevilko deljenje itd. S pomočjo prejšnjih funkcij, simetrični tabeli
# prištej kompleksno enico na vsakem mestu. Zapiši funkcijo
# `carobni_kompleks(dim1, dim2)`. _Namig: Imaginarno enoto $i$ v Pythonu zapišemo
# kot `1j`._
# 
# Primer:
# 
#     >>> carobni_kompleks(2, 2)
#     array([[0. + 1.j, 1. + 1.j]
#            [1. + 1.j, 2. + 1.j]])
# =============================================================================
import numpy as np
def carobni_kompleks(dim1, dim2):
    return simetrija(dim1, dim2) + 1j
# =====================================================================@023123=
# 5. podnaloga
# Tabele lahko med seboj tudi primerjamo. Preverimo lahko torej če sta elementa
# v dveh tabelah enakih dimenzij enaka, večja, manjša. Tako lahko zapišeš funkcijo
# `kdo_je_pravi_velikan(tabela1, tabela2)`, ki sprejme dve tabeli in vrne tabelo
# zgolj tistih elementov iz prve tabele, ki so večji od pripadajočih elementov
# v drugi tabeli, ostale vrednsoti pa so ničle. _Namig:Spomni se, da je False
# $0$ in True $1$._
# 
# Primer:
# 
#     >>> kdo_je_pravi_velikan(simetrija(2, 2), tabela_enic(2, 2))
#     array([[0., 0.]
#            [0., 2.]])
# =============================================================================
import numpy as np
def kdo_je_pravi_velikan(tabela1, tabela2):
    return tabela1 * (tabela1 > tabela2 )
# =====================================================================@023124=
# 6. podnaloga
# S pomočjo funkcij `np.all()`, `np.any()` in podobnih, lahko izvajaš tudi
# bolj zapletene logične operacije, kot recimo ugotoviš, če so vsi elementi
# večji ali pa preveriš če je vsaj en element večji. Zapiši funkcijo
# `premisljeni_delilec(tabela1, tabela2)`, ki sprejme, dve tabeli in izvede
# operacijo deljenja, če ugotovi, da je operacija povsod definirana (da nikjer
# ne delimo z ničlo), sicer pa vrže `None`
# 
# Primer:
# 
#     >>> premisljeni_delilec(np.array([1, 2]), np.array([1, 0]))
#     None
#     >>> premisljeni_delilec(np.array([1, 2]), np.array([1, 4]))
#     np.array([1., 0.5])
# =============================================================================
import numpy as np
def premisljeni_delilec(tabela1, tabela2):
    if np.all(tabela2) != 0:
        return tabela1/tabela2
    else:
        return None

# Generiranje tabel podatkov
#
# Pri numeričnem delu pogosto potrebujemo tabele podatkov. Numpy vsebuje metode za generiranje
# tabel, ki so pripravnejše in hitrejše od pythonove 'range()' funkcije in zank. Za pomoč si oglejte
# [dokumentacijo](https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html).
# =====================================================================@022443=
# 1. podnaloga
# Sestavite funkcijo `vrednosti_sinusa(N)`, ki vrne vrednosti funkcije sinus v `N`
# ekvidistančnih točkah z intervala $[0, 2\pi]$.
# =============================================================================
import numpy as np
def vrednosti_sinusa(N):
    return np.sin(np.linspace (0, 2*np.pi, N))
# =====================================================================@022444=
# 2. podnaloga
# Sestavite funkcijo `linearna_funkcija(k, x_max, dx)`, ki vrne vrednosti linearne
# funkcije `f(x) = kx`, kjer so `x` vrednosti z intervala $[0, x_{max})$ z začetkom
# v 0 in razmaknjene za `dx`.
# =============================================================================
import numpy as np
def linearna_funkcija(k, x_max, dx):
    vrednosti = np.arange(0, x_max, dx)
    return k* vrednosti
# =====================================================================@022445=
# 3. podnaloga
# Sestavite funkcijo `dvodimenzionalni(N)`, ki vrne dvodimenzionalni array
# ($N \times N$ matriko). Prva vrstica naj vsebuje vrednosti 1, druga 2, itd.,
# do N-te vrstice napolnjene z vrednostmi N.
# =============================================================================
import numpy as np
def dvodimenzionalni(N): # Ustvarimo matriko N x N, kjer vsaka vrstica vsebuje vrednost številke vrstice
    matrika = np.array([[i+1] * N for i in range(N)])
    return matrika

# =====================================================================@022446=
# 4. podnaloga
# Sestavite funkcijo `produkt_indeksov(N)`, ki vrne dvodimenzionalni array
# ($N \times N$ matriko). Vrednost komponente z indeksoma `i` in `j` naj bo `i*j`.
# =============================================================================
import numpy as np
def produkt_indeksov(N): # Ustvarimo matriko N x N, kjer je vrednost komponente na poziciji (i, j) enaka i * j
    matrika = np.array([[i * j for j in range(N)] for i in range(N)])
    return matrika

# Iskanje po tabelah
#
# Pri delu s podatkovnimi nizi nas pogosto zanimajo indeksi, ki ustrezajo nekim pogojem. V tem
# sklopu se boste spoznali s
# [funkcijami](https://docs.scipy.org/doc/numpy/reference/routines.sort.html) uporabnimi za iskanje
# po tabelah.
# 
# Naloge rešujte brez uporabe zank.
# =====================================================================@022451=
# 1. podnaloga
# Definirajte funkcijo `vecji(a, b)`, ki sprejme dva enodimenzionalna seznama
# iste dolžine in vrne indekse mest, kjer je prvi seznam večji od drugega.
# =============================================================================
import numpy as np
def vecji(a, b): # Pretvorimo sezname v numpy arrays
    a = np.array(a)
    b = np.array(b)
    return np.where(a > b)[0] # Primerjamo elemente in vrnemo indekse, kjer je a > b
    #[0] pomeni: "vzemi prvi (in edini) array iz tuple-a

# =====================================================================@022452=
# 2. podnaloga
# Definirajte funkcijo `zdruzena(a, b)`, ki sprejme dva enodimenzionalna seznama
# iste dolžine in vrne seznam z vrednostmi iz `a`, kjer so le te večje od 0 in
# vrednostmi iz `b` povsod drugje.
# =============================================================================
import numpy as np
def zdruzena(a, b):
    a = np.array(a)
    b = np.array(b)
    rezultat = np.where(a > 0, a, b) # Ustvarimo seznam, kjer bodo vrednosti iz `a` če so večje od 0, sicer vrednosti iz `b`
    return rezultat

# =====================================================================@022453=
# 3. podnaloga
# Definirajte funkcijo `lokalni_maksimum(a)`, ki sprejme enodimenzionalen seznam
# in vrne indekse lokalnih maksimumov. Lokalni maksimum je element seznama, za
# katerega velja `a[i-1] < a[i] > a[i+1]`. Za robne elemente smatramo, da so
# lokalni maksimumi, če so večji od edinega soseda.
# Za reševanje sta koristni funkciji
# [np.roll](https://docs.scipy.org/doc/numpy/reference/generated/numpy.roll.html)
# in [np.pad](https://docs.scipy.org/doc/numpy/reference/generated/numpy.pad.html).
# =============================================================================
import numpy as np
def lokalni_maksimum(a):
    a = np.pad(a, (1, 1), 'minimum')
    return np.flatnonzero((a > np.roll(a, 1)) * (a > np.roll(a, -1))) - 1

# np.roll: a, zamaknjeni za eno mesto levo in desno
# np.pad(a, (1, 1), 'minimum'): Dodamo en element na začetek in konec, ki je enak najmanjši možni vrednosti
# np.flatnonzero(...): Vrne indekse, kjer je maska True – torej lokalni maksimumi
# -1 na koncu: Popravi za zamik, ki je bil uveden z np.pad

# Osi in operacije med tabelami
#
# Mladi fizik Aljaž je septembra prišel na IJS, da bi si poiskal študentsko
# delo. Ker je neizkušen in se profesorjem zdi, da še ne razume čisto vsega,
# so ga prosili, da preuči kolikšen je električni pretok v takoimenovani
# super elektro cevi in kako ga lahko spreminja. V tej cevi v eno in drugo smer
# naravnost frčijo nabiti delci, z različnimi naboji in hitrostmi.
# =====================================================================@022801=
# 1. podnaloga
# Definiraj funkcijo 'celotni_tok(tabela)', ki kot argument sprejme
# tabelo, v kateri prva vrstica predstavlja število delcev, ki se giblje s
# hitrostjo iz druge vrstice in naboj iz zadnje vrstice, vrne pa celotni
# električni tok, definiran kot $$j = \sum_{m} n_{m} v_{m} e_{m},$$
# kjer je $e_{m}$ naboj, $v_{m}$ hitrost in $n_{m}$ število delcev z nabojem
# $e_{m}$ in hitrostjo $v_{m}$.
# 
# Primer:
# 
#     >>> celotni_tok(np.array([[1, 2], [-1, 2], [1, 0.1]]))
#     -0.6
# =============================================================================
import numpy as np
def celotni_tok(tabela):
    skupna = 0
    for i in range(len(tabela[0])):
        n = tabela[0, i] # [] predstavljajo koordinate
        v = tabela[1, i]
        e = tabela[2, i]
        skupna += (n * v * e)
    return skupna          

#Uradna rešitev:
'''def celotni_tok(arr):
    return np.sum(np.prod(arr, axis=0))'''

# np.prod(arr, axis=0): je funkcija iz knjižnice NumPy, ki zmnoži elemente v tabeli (array) po določeni osi.
# arr: NumPy array (lahko je 1D, 2D, 3D ...), axis=0: pomeni po vrsticah, torej se množi navpično (po stolpcih)


# =====================================================================@022803=
# 2. podnaloga
# Hitrost delcev lahko spreminja tako, da v eno izmed smeri vklopi električno
# polje $E$. Le to hitrost delca z nabojem $e$ spremeni kot
# $$\Delta v(t) = e\int_{0}^{t}E(t')dt'.$$ Če Aljaž hipno vklopi konstantno
# električno polje za čas $t$, z vrednostjo $E$, potem velja
# 
# $$v_{nova} = v_{začetna} + E e t.$$
# 
# Zapiši funkcijo `celotni_tok_po_vklopu(tabela, E, t)`, ki sprejme
# za argument zgornjo tabelo in $E$ ter $t$.
# 
# Primer:
# 
#     >>> celotni_tok_po_vklopu(np.array([[1, 2], [-1, 2], [1, 0.1]]), 1, 2)
#     1.44
# =============================================================================
import numpy as np
def celotni_tok_po_vklopu(tabela, E, t):
    skupna = 0
    for i in range(len(tabela[0])):
        n = tabela[0, i]
        v = tabela[1, i]
        e = tabela[2, i]
        v_nova = v + E * e * t
        skupna += (n * v_nova * e)
    return skupna

# Uradna rešitev:
'''def celotni_tok_po_vklopu(arr, E, t):
    arr[1, :] = arr[1] + arr[2] * E * t
    return np.sum(np.prod(arr, axis=0))'''

# arr je 2D NumPy array (matrika). arr[1, :] pomeni: vsa stolpca druge vrstice (ker indeksiranje začne pri 0).
# arr[1] pomeni isto kot arr[1, :], torej spet druga vrstica. arr[2] je tretja vrstica

# =====================================================================@022804=
# 3. podnaloga
# A Aljaž hitro ugotovi, da v realnosti ne mora doseči povsem konstantnega polja,
# temveč le polje, ki poda odvisnost
# $$v_{nova} = v_{začetna} + \frac{Ee}{\sigma}\ln(\exp(\sigma t)+1).$$
# 
# Definiraj funkcijo `celotni_tok_po_vklopu_realno(tabela, sigma, E, t)`, ki
# sprejme tabelo, parameter natančnosti $\sigma$, maksimalno jakost polja $E$
# in čas $t$.
# 
# Primer:
# 
#     >>> celotni_tok_po_vklopu_realno(np.array([[1, 2], [-1, 2], [1, 0.1]]), 100, 1, 2)
#     1.44
# =============================================================================
import numpy as np
def celotni_tok_po_vklopu_realno(tabela, sigma, E, t):
    skupna = 0
    for i in range(len(tabela[0])):
        n = tabela[0, i]
        v = tabela[1, i]
        e = tabela[2, i]
        v_nova = v + ((E *e) / sigma )* np.log(np.exp(sigma * t)+1)
        skupna += (n * v_nova * e)
    return skupna   

# Uradna rešitev:
'''def celotni_tok_po_vklopu_realno(arr, sigma, E, t):
    arr[1, :] = arr[1] + arr[2] * E / sigma * np.log(np.exp(sigma * t) + 1)
    return np.sum(np.prod(arr, axis=0))'''

# =====================================================================@023072=
# 4. podnaloga
# Kljub upoštevanju tega popravka se rezultati eksperimenta ne ujemajo z
# modelom, zato se posvetuje pri profesorjih. Ti se mu povejo, da se pri
# določeni hitrosti delci zaletijo v steno zaradi magnetnih polj. Aljažu seveda
# nič ni jasno, a razume, da mora napisati program, ki bo upošreval le tiste
# delce, ki se ne zaletijo v steno.
# 
# Napiši funkcijo `celotni_tok_po_vklopu_realno_stena(tabela, sigma, E, t, v_max)`,
# ki sprejme enake parametre kot prejšnja, in maksimalno dovoljeno hitrost, vrne
# pa celotni tok.
# 
# Primer:
# 
#     >>> celotni_tok_po_vklopu_realno_stena(np.array([[1, 2], [-1, 2], [1, 0.1]]), 100, 1, 2, 2)
#     1.0
# =============================================================================
import numpy as np
def celotni_tok_po_vklopu_realno_stena(arr, sigma, E, t, v0):
    arr[1, :] = arr[1] + arr[2] * E / sigma * np.log(np.exp(sigma * t) + 1)
    arr[1, :] = arr[1] * (np.abs(arr[1]) < v0)
    return np.sum(np.prod(arr, axis=0))

# Piramida
# =====================================================================@022805=
# 1. podnaloga
# S knjižnico numpy si lahko privoščimo zelo uporabne manipulacije
# tabel, še posebaj več dimenzionalnih. Na tak način lahko
# ustvarimo tridimenzionalno tabelo, ki predstavlja štiristrano
# piramido. Piramido označimo z enicami, preostanek pa z ničlami. Sestavi
# funkcijo `numpy_piramida`, ki sprejme kot argument dolžino spodnjega roba
# piramide in skonstruira štiristrano numpy piramido z naklonom $45°$. Nična
# os naj bo višina.
# 
# Namig: pomagaj si z `np.zeros()` in `np.ones()`
# 
# Primer:
# 
#     >>> numpy_piramida(5)
#     array([[[0. 0. 0. 0. 0.]
#       [0. 0. 0. 0. 0.]
#       [0. 0. 1. 0. 0.]
#       [0. 0. 0. 0. 0.]
#       [0. 0. 0. 0. 0.]]
# 
#      [[0. 0. 0. 0. 0.]
#       [0. 1. 1. 1. 0.]
#       [0. 1. 1. 1. 0.]
#       [0. 1. 1. 1. 0.]
#       [0. 0. 0. 0. 0.]]
# 
#      [[1. 1. 1. 1. 1.]
#       [1. 1. 1. 1. 1.]
#       [1. 1. 1. 1. 1.]
#       [1. 1. 1. 1. 1.]
#       [1. 1. 1. 1. 1.]]])
# =============================================================================
import numpy as np
def numpy_piramida(a):
    import numpy as np
    v = (a + 1) // 2  # bolj berljivo kot a // 2 + a % 2
    piramida = np.zeros((v, a, a))

    for i in range(v):
        size = a - 2 * i
        layer = v - i - 1
        if size > 0: # pogoj, da ustvarimo kvadrat
            piramida[layer, i:a - i, i:a - i] = 1  # i:a - i so rezine po vrsticah in stolpcih, ki definirajo kvadrat, ki ga polnimo z 1 (i je mesto)
                                                    # =1 vse elemente v tem kvadratu nastaviš na vrednost 1
    return piramida


#Uradna rešitev:
#def numpy_piramida(a):
    ''' funkcija skonstruira piramido s stranico dolžine a'''

    v = a // 2 + a % 2
    piramida = np.zeros((v, a, a))
    for i in np.arange(v):
        if i != 0:
            piramida[v - i - 1, i: -i, i: -i] = np.ones((a - 2*i, a - 2*i))
        else:
            piramida[v - i - 1, :, :] = np.ones((a - 2*i, a - 2*i))

    return piramida


# Ne dela:
#def numpy_piramida(n):
    for i in range(n):
        nivo = np.zeros((n, n))
        nivo [i, i:n-i, i:n-i] = 1
        matrika = np.hstack([nivo])
    return matrika



# =====================================================================@022806=
# 2. podnaloga
# Zapiši funkcije `pticja_perspektiva(piramida)`, `s_strani1(piramida)` in
# `s_strani2(piramida)`, ki sprejme piramido napisano na prejšnji način in
# vrne tabelo, ki prikazuje profil piramide iz ptičje perspektive in iz strani.
# 
# Primer:
# 
#     >>> s_strani1(numpy_piramida(11))
#     array([[ 0.  0.  0.  0.  0.  1.  0.  0.  0.  0.  0.]
#      [ 0.  0.  0.  0.  3.  3.  3.  0.  0.  0.  0.]
#      [ 0.  0.  0.  5.  5.  5.  5.  5.  0.  0.  0.]
#      [ 0.  0.  7.  7.  7.  7.  7.  7.  7.  0.  0.]
#      [ 0.  9.  9.  9.  9.  9.  9.  9.  9.  9.  0.]
#      [11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11.]])
# =============================================================================
def pticja_perspektiva(piramida):
    '''Funkcija sprejme piramido in pokaže njen 'profil' iz ptičje perspektive.'''
    return np.sum(piramida, axis=0)

def s_strani1(piramida):
    '''Funkcija sprejme piramido in pokaže njen 'profil' iz strani.'''
    return np.sum(piramida, axis=1)

def s_strani2(piramida):
    '''Funkcija sprejme piramido in pokaže njen 'profil' iz druge strani.'''
    return np.sum(piramida, axis=2)


# axis=0 – deluje po vrsticah (navpično)
# axis=1 – deluje po stolpcih (vodoravno)
# axis=2 – globina (za 3D ali več)	deluje znotraj posamezne matrike

# Več dimenzionalne tabele
# =====================================================================@022807=
# 1. podnaloga
# Z numpy lahko učinkovito ustarjamo tabele raznoraznih oblik in dimenzij, z
# uporabo funkcij kot so `np.ones()` in `np.zeros()`. Definiraj funkcijo
# `prazna_tabela(dimenzije, tip)`, ki sprejme željeno obliko in tip tabele
# in vrne tabelo željene oblike iz samih ničel.
# 
# Primer:
# 
#     >>> prazna_tabela((1, 2, 1, 1), 'float32')
#     array([[[[0.]], [[0.]]]], dtype=float32)
# =============================================================================
import numpy as np
def prazna_tabela(niz, tip):
    return np.zeros(niz, dtype=tip) # dtype - tip tabele


# =====================================================================@023094=
# 2. podnaloga
# S tem močnim orožjem si lahko privoščimo izredno abstraktne manipulacije tabel.
# Napiši funkcijo `sodi_so_2(tabela)`, ki sprejme prazno tabelo dimenzije 3
# in na vseh mestih, kjer so vsi indeksi sodi postavi vrednost 2.
# 
# Primer:
# 
#     >>> sodi_so_2(prazna_tabela((5, 1, 2), None))
#     array([[[2. 0.]]
# 
#      [[0. 0.]]
# 
#      [[2. 0.]]
# 
#      [[0. 0.]]
# 
#      [[2. 0.]]])
# =============================================================================
import numpy as np
def sodi_so_2(tabela):
    tabela[::2, ::2, ::2] = np.ones((np.array(np.shape(tabela)) + 1 ) //2) * 2
    return tabela

def sodi_so_2(tabela):
    ''' To pa je alternativni način.'''
    oblika = np.shape(tabela)
    rezina = tuple([slice(0, oblika[i], 2) for i in range(3)])
    tabela[rezina] = np.ones((np.array(oblika) + 1 ) // 2) * 2
    return tabela



# =====================================================================@023095=
# 3. podnaloga
# Pa pojdimo zdaj še korak dlje. Zapiši funkcijo `sodi_so_3(tabela)`, ki sprejme
# prazno tabelo poljubne dimenzije in na vseh mestih, kjer so vsi indeksi sodi
# postavi vrednost 3. _Namig: Poglej uradno rešitev prejšnje naloge._
# 
# Primer:
# 
#     >>> sodi_so_3(prazna_tabela((3, 2, 2, 3), None))
#     array([[[[3. 0. 3.]
#        [0. 0. 0.]]
# 
#       [[0. 0. 0.]
#        [0. 0. 0.]]]
# 
# 
#      [[[0. 0. 0.]
#        [0. 0. 0.]]
# 
#       [[0. 0. 0.]
#        [0. 0. 0.]]]])
# =============================================================================
import numpy as np
def sodi_so_3(tabela):
    oblika = np.shape(tabela)
    rezina = tuple([slice(0, oblika[i], 2) for i in range(len(oblika))])
    tabela[rezina] = np.ones(np.shape(tabela[rezina])) * 3
    return tabela


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
NUMPY II.:
# Ponarejevalka
#
# Teoretična fizičarka Lana ne mara eksperimentalnega dela. Zaradi tega je meritve
# pri zadnji nalogi pri fizikalnemu praktikumu opravila zelo slabo. Kjub opozorilom
# asistenta se je lotila ponarejevanja podatkov.
# 
# Nalogo rešuj brez uporabe zank.
# =====================================================================@039113=
# 1. podnaloga
# V nalogi, ki je še ni zagovorila, mora preiskovati nihanje vzmetnega nihala.
# Vemo, da se odmik vzmetnega nihala spreminja s časom kot $x = A \sin(\omega t)$,
# kjer sta $A$ in $\omega$ podani konstanti.
# 
# Napiši funkcijo `odmik(A, omega, t_z, t_k)`, ki izračuna odmik na 10 točkah
# enakomerno porazdeljenih po intervalu $[t_z, t_k]$. 
# 
# Primer:
# 
#       >>> odmik(10, 1, 0, 2 * np.pi)
#       array([ 0.00000000e+00,  6.42787610e+00,  9.84807753e+00,  8.66025404e+00,
#               3.42020143e+00, -3.42020143e+00, -8.66025404e+00, -9.84807753e+00,
#               -6.42787610e+00, -2.44929360e-15])
# =============================================================================
import numpy as np
def odmik(A, omega, t_z, t_k):
    return (A * (np.sin(omega * np.linspace (t_z, t_k, 10)))) # np.linspace - ustvari enakomerno razporejeno zaporedje števil


# =====================================================================@039114=
# 2. podnaloga
# Rezultati pri prejšnji nalogi so seveda brez merske napake, kot pa vsi vemo, je 
# ta pri meritvah vedno prisotna, zato se je Lana odločila, da meritvam doda nekaj
# šuma. In sicer vsakemu elementu `a[i]` razen prvemu in zadnjemu želi prišteti
# `A * sin(omega * (a[i + 1] + a[i - 1]) / 2) / 10`. Za dane `A, omega, t_z, t_k` 
# napiši funkcijo `realni_odmik(A, omega, t_z, t_k)`, ki vrne meritve z dodanim šumom.
# Na primer:
# 
#       >>> realni_odmik(10, 1, 0, 2 * np.pi)
#       array([ 0.00000000e+00  5.45019043e+00  1.08004365e+01  9.00404801e+00
#               3.91844027e+00 -3.91844027e+00 -9.00404801e+00 -1.08004365e+01
#               -5.45019043e+00 -2.44929360e-15])
# =============================================================================
import numpy as np
def realni_odmik(A, omega, t_z, t_k):
    x = odmik(A, omega, t_z, t_k)
    sum1 = (np.roll(x, 1) + np.roll(x, -1)) / 2 # np.roll - prejšnji in naslednji element
    sum2 = A * np.sin(omega * sum1) / 10
    sum2[0] = 0  # prvemu in zadnjemu nobenega šuma
    sum2[-1] = 0 
    return x + sum2 # prištejemo napake


# =====================================================================@039115=
# 3. podnaloga
# Lana ni izbrala preveč dobre funkcije za dodajanje šuma in sedaj asistent sumi,
# da je podatke ponaredila. Ker tega seveda ne more dokazati, se je odločil, da jo
# kaznuje tako, da mu mora pomagati poiskati študente, ki so podatke vzeli od 
# kolegov. Asistent meni, da če se povprečna frekvenca $\omega$ dveh študentov
# razlikuje za manj kot 2 %, je velika verjetnost, da je en študent prepisoval
# od drugega (prepisanim podatkom je le dodal nekaj šuma).
# 
# Lana ima meritve ostalih študentov na voljo v dveh tabelah, v tabeli `X` so
# meritve odmikov, v `i`-ti vrstici so vse meritve, ki pripadajo `i`-temu 
# študentu. V tabeli `T` so v enakem formatu shranjene meritve časov. 
# Za amplitudo vzami kar maksimalen odmik med meritvami.
# 
# Napiši funkcijo `prepisovalci(X, T, omega_0)`, ki vrne urejen seznam (!) zaporednih številk
# učencev, katerih meritve frekvenc se od frekvence `omega_0` razlikujejo za 
# manj kot 2 % (kjer za osnovo pri računanju odstotkov vzamemo `omega_0`).
# 
# Primer:
# 
#       >>> prepisovalci(np.array([[0.5, 1, 1.5], [0.6, 1.2, 1.8]]), np.array([[1, 2, 3], [4, 5, 6]]), 0.97)
#       [1]
# =============================================================================
import numpy as np
def prepisovalci(X, T, omega_0):
    A = np.max(X, axis = 1)
    A = A.reshape(len(A), 1) # da lahko množimo X / A preoblikujemo !!!
    omega = np.mean(np.arcsin(X / A ) / T, axis=1) # np.mean - naredimo povprečje
    razlika = np.abs(omega - omega_0) / omega_0
    return list(np.where(razlika < 0.02))

# Obsedena elektronika
#
# Fizik Albert se ukvarja s težkimimi problemi dinamike teniških žogic. Projekt
# predvideva tudi eksperimentalno potrditev rezultatov, kar pa Albertu povzroča
# nemalo skrbi, saj je, teoretik po duši, večino projektnega denarja porabil za
# svinčnike in črni čaj.
# V stiski, tik pred rokom za oddajo članka, je na bolhi kupil najcenejši 
# merilnik hitrosti. Sumljivo nizka cena se seveda izkaže za upravičeno, saj se
# je merilnik od svojih bivših lastnikov, slovenskega satanističnega društva,
# navzel slabih navad in med sicer popolnoma veljavnimi meritvami naključno 
# vrača hudičevo število 666. 
# S svojim programerskim znanjem pomagajte Albertu pri boju z obsedenim 
# merilnikom in izvedbi eksperimenta.
# 
# Nalogo rešujte brez uporabe zank.
# =====================================================================@039116=
# 1. podnaloga
# Za začetek moramo iz rešitev odstraniti oskrunjene vrednosti. Meritve z 
# manjkajočimi vrednostmi bi bile seveda neuporabne. Na srečo so sile v
# Albertovem eksperimentu dovolj majhne in vzorčenje dovolj hitro, da lahko 
# manjkajoče vrednosti kar linearno interpoliramo iz sosednjih vrednosti.
# 
# Definirajte funkcijo `razhudicene_hitrosti(hitrosti)`, ki sprejme `ndarray` 
# oblike `(3 x N)`. V prvi vrstici se nahajajo zaporedne meritve `x` komponente
# hitrosti, v drugi vrstici `y` komponente in v tretji `z` komponente. Časovni
# interval med zaporednimi meritvami je konstanten.
# 
# Funkcija naj vrne `ndarray` hitrosti, kjer so hudičeva števila (666) zamenjana
# z linearno interpoliranimi vrednostmi. Pri interpolaciji upoštevajte le
# sosednje hitrosti. Hudičeva števila se ne bodo pojavila na prvem, zadnjem ali
# zaporednih mestih.
# 
# Primer:
# 
#     >>> razhudicene_hitrosti(np.array([[1, 666, 3], [-2, 666, 2], [3, 4, 5]]))
#     array([[ 1.,  2.,  3.],
#            [-2.,  0.,  2.],
#            [ 3.,  4.,  5.]])
# =============================================================================
import numpy as np
def razhudicene_hitrosti(hitrosti):
    return np.where(hitrosti == 666, (np.roll(hitrosti, 1) + np.roll(hitrosti, -1)) / 2, hitrosti) # np.where(kriterij, če_je_true, če_je_false)
# =====================================================================@039117=
# 2. podnaloga
# Albert sicer potrebuje lokacije žogic, a ga nakup merilnika hitrosti sploh ne 
# skrbi, saj se zaveda, da ga od željenega rezultata loči le integral. Pomagajte
# Albertu pri numerični implementaciji.
# 
# Definirajte funkcijo `lokacije(zacetek, hitrosti, dt)`, ki sprejme začetne 
# pozicije `zacetek` (`ndarray` dolžine 3), izmerjene `hitrosti` (`ndarray`
# oblike `(3xN)`, vrstice enako kot v prejšnji podnalogi predstavljajo različne
# komponente) in časovni interval med meritvami `dt`.
# 
# Funkcija naj vrne `ndarray` oblike `(3xN)`, v katerem so komponente lokacije
# žogice izračunane z najpreprostejšo obliko numerične integracije
# $s_n = s_{začetek} + \sum_{i=0}^{n}v_i dt$.
# 
# Primer:
# 
#     >>> hitrosti = razhudicene_hitrosti(np.array([[1, 666, 3], [-2, 666, 2], [3, 4, 5]]))
#     >>> lokacije(np.array([0, 0, 0]), hitrosti, 1)
#     array([[ 1.,  3.,  6.],
#            [-2., -2.,  0.],
#            [ 3.,  7., 12.]])
# =============================================================================
import numpy as np
def lokacije(zacetek, hitrosti, dt):
    zacetek = zacetek.reshape(len(zacetek), 1) # naredi preoblikovanje 1D vektorja v 2D stolpčni vektor
    integral = np.cumsum (hitrosti * dt, axis=1) # ali zacetek [:, np.newaxis]
    return zacetek + integral
# =====================================================================@039118=
# 3. podnaloga
# Albert je s svojimi izračuni napovedal statistiko $\frac{r_{maksimalni}}{r_
# {končni}}$, kjer je $r$ razdalja od izhodišča ($r = \sqrt{x^2 + y^2 + z^2}$).
# $r_{maksimalni}$ predstavlja največjo razdaljo, ki jo doseže žogica,
# $r_{končni}$ pa razdaljo pri zadnji meritvi.
# 
# Pomagajte mu pri implementaciji, definirajte fukcijo  `razmerja(meritve)`, ki
# sprejme seznam  lokacij za `M` ponovitev eksperimenta (`ndarray`  dimenzije 
# `(Mx3xN)`, torej `M` ponovitev struktur, ki bi jih vrnila funkcija `lokacije`
# iz predhodne podnaloge) in vrne par, ki ima na prvem mestu 
# povprečno vrednost in na drugem standardni odklon $\frac{r_{maksimalni}}
# {r_{končni}}$ izračunana iz podanih `M` eksperimentov.
# 
# Primer:
# 
#     >>> hitrosti = razhudicene_hitrosti(np.array([[1, 666, 3], [-2, 666, 2], [3, 4, 5]]))
#     >>> pozicije = lokacije(np.array([0, 0, 0]), hitrosti, 1)
#     >>> razmerja(np.array([pozicije]))
#     (1., 0.)
# =============================================================================
import numpy as np
def razmerja(meritve):
    razdalje = np.sqrt(np.sum(np.square(meritve), axis = 1))
    razmerja = np.max(razdalje, axis = 1) / razdalje[:, -1]
    return np.average(razmerja), np.std(razmerja) # vrne dvojček

# Kvadratne funkcije
#
# To so naloge, ki jih moraš rešiti s knjižnico numpy. Vsaka uporaba `for` zanke
# ti bo zmanjšala število možnih točk, ki jih pri tej nalogi lahko dobiš. Za vse 
# podnaloge spodaj je privzeto, da se jih računa za $x$ na intervalu $[0, 9]$
# s korakom $1$.
# =====================================================================@039119=
# 1. podnaloga
# Napiši funkcijo `kvadratna_funkcija(a, b, c)`, ki bo vrnila numpy array vrednosti
# funkcije `a*x^2 + b*x + c` izračunane v točkah definiranih v uvodnem besedilu.
# 
# Primer:
# 
#     >>> kvadratna_funkcija(5, 2, -5)
#     array([ -5,   2,  19,  46,  83, 130, 187, 254, 331, 418])
#     >>> kvadratna_funkcija(1, 1, 1)
#     array([ 1,  3,  7, 13, 21, 31, 43, 57, 73, 91])
#     >>> kvadratna_funkcija(1, -8, 15)
#     array([15,  8,  3,  0, -1,  0,  3,  8, 15, 24])
# =============================================================================
import numpy as np
def kvadratna_funkcija(a, b, c):
    x_os = np.arange(0, 10, 1)  # np.arange(start, stop, step)
    return a * x_os ** 2 + b * x_os + c


# =====================================================================@039120=
# 2. podnaloga
# Definiraj funkcijo `maksimum_kvadratnih(a1, b1, c1, a2, b2, c2)`, ki bo prejela dve 
# kvadratni funkciji `a1 * x^2 + b1 * x + c1` in `a2 * x^2 + b2 * x + c2` in vrnila numpy array 
# maksimumov vrednosti teh dveh funkcij v posamezni točki.
# 
# Primer:
# 
#     >>> maksimum_kvadratnih(5, 2, -5, 1, 1, 1)
#     array([  1,   3,  19,  46,  83, 130, 187, 254, 331, 418])
# =============================================================================
def maksimum_kvadratnih(a1, b1, c1, a2, b2, c2):
    prva = kvadratna_funkcija(a1, b1, c1)
    druga = kvadratna_funkcija(a2, b2, c2)
    return np.maximum(prva, druga)  # np.maximum(prva, druga) v NumPy vrne elementno največje vrednosti med dvema tabelama


# =====================================================================@039121=
# 3. podnaloga
# Pri tej nalogi bomo poskusili narisati kvadratno funkcijo. Dobil boš podano
# kvadratno funkcijo, ti pa jo boš moral narisati na intervalu `[0, 9]`. Graf funkcije 
# si bomo predstavljali kot `10 x 10` numpy tabelo. Prvi stolpec tabele bo predstavljal
# koordinato `x = 0`, drugi stolpec `x = 1`, itd. Spodnja vrstica bo predstavljala vrednost
# `y = 0`, vrstica višje vrednost `y = 1` itd. Vsa polja v tabeli, ki so "pod" grafom označimo
# z  `1`, polja v tabeli nad grafom pa z `0`.
# 
# Definiraj funkcijo `narisi_graf(a, b, c)`, ki bo vrnila `10 x 10` numpy tabelo z grafom dane kvadratne
# funkcije, kot so primeri spodaj.
# 
# Primer:
# 
# Za primer si poglejmo, kako bi izgledal graf kvadratne funkcije `x^2 - 8*x + 15`:   
# <pre>
# array([[1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
#        [1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
#        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
#        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
#        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
#        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
#        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
#        [1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
#        [1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
#        [1, 1, 1, 0, 0, 0, 1, 1, 1, 1]])
# </pre>
# 
# Graf kvadratne funkcije `0.5 * x^2 - 4*x + 7.5` bi izgledal takole:
# <pre>
# array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
#        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
#        [1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
#        [1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
#        [1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
#        [1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
#        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
#        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
#        [1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
#        [1, 1, 1, 0, 0, 0, 1, 1, 1, 1]])
# </pre>
# **Opomba:**   
# Če boš pri tej nalogi uporabljal `for` zanko, lahko za to podnalogo dobiš maksimalno `3/9` točk.
# Če boš za vseh 100 vrednosti v tabeli ročno napisal vrednosti, je prav tako možnih `3/9` točk.
# =============================================================================
def narisi_graf(a, b, c):
    x, y = np.meshgrid(np.arange(0, 10, 1), np.arange(0, 10, 1))
    vrednosti = a*x**2 + b*x + c
    graf = np.flip(y < vrednosti, axis=0).astype(int)
    return graf
    
    """
    vrednosti = kvadratna_funkcija(a, b, c)
    xy_tabela = np.fromfunction(lambda i, j : i, (10, 10))
    graf = np.where(xy_tabela < vrednosti, 1, 0)
    graf = np.flip(graf, axis=0) # Obrnemo x in y os
    return graf
    """

# Popravljalec cevi
#
# Janov oče je vodovodar, zato se je tudi Jan odločil za ta poklic. Ker ga
# zanima tudi robotika, je ustvaril malega robotka, ki se lahko vozi gor in dol
# po ceveh. Hitro je ugotovil, da bo težko ugotovil kje se njegov robotek
# nahaja, zato je vanj vgradil še merilec hitrosti, ki mu preko oddajnika
# sporoča hitrost ob danem času. Hitrost določa iz hitrosti vrtenja "koles"
# brez spodrsavanja. Hitrost mu sporoči vsakih $0.01$ sekund.
# =====================================================================@039110=
# 1. podnaloga
# Napiši funkcijo `kje(hitrosti, t)`, ki za prvi argument sprejme hitrosti
# robotka v metrih na sekundo, za drugi argument pa čas `t` v sekundah in vrne
# oddaljenost od izhodišča (v metrih) ob času `t`. Če je čas $t$ prevelik, naj
# funkcija vrne `False`.
# 
# Kakršnakoli uporaba for ali while zanke bo kaznovana z nič točkami, kot da
# naloge nebi reševali.
# 
# Primer:
# 
#     >>> kje(array([1, 1, 1, 1]), 0.02)
#     0.02
# =============================================================================
import numpy as np
def kje(v, t):
    N = int(t // 0.01)  # Število časovnih korakov velikosti 0.01 s
    if N <= len(v):     # Če ne presežemo dolžine vektorja hitrosti (časovne intervale)
        return np.sum(v[:N] * 0.01)  # vsota v[i] * dt = približek poti (računamo do zadnega podatka glede čas)
    return False

# Ne dela:
# def kje(hitrosti, t):
    if t > len(hitrosti):
        return False
    else:
        index = int(np.floor(t))
        fraction = t - index
        return np.sum(hitrosti[:index]) + fraction * hitrosti[index]



# =====================================================================@039111=
# 2. podnaloga
# V resnici pa cevi niso ravne. Na vsake toliko časa robotek pride do zavoja.
# Kadar cev zavije se robotek prilagodi obliki in zabeleži pod kakšnim kotom je
# zavil. Cevi so na ravnini, zato se lahko zavrti samo okoli ene osi. Napiši
# funkcijo `kotopot(pot)`, ki za argument sprejme tabelo naslednje oblike.
# Tabela je iz kompleksnih števil. Vsaka vrstica v njej ima na prvem mestu
# število katerega realna komponenta je kot, na vseh ostalih pa števila, ki
# imajo za realno komponento hitrost, za imaginarno komponento pa $0$, če je
# to realna hitrost, ki jo je potrebno upoštevati, oziroma $1$, če je to
# imaginarna hitrost, ki je ne smemo upoštevati. Funkcija `kotopot(pot)` naj
# vrne novo tabelo, ki bo vrstice iz prejšnje spremenila tako, da
# bo prvi element predstavljal kot, drugi element pa prepotovano pot
# od enega do drugega ovinka.
# 
# Kakršnakoli uporaba for ali while zanke bo kaznovana tako, da se maksimalno
# število točk prepolovi.
# 
# Primer:
# 
#     >>> kotopot(array([[1 ,   1 + 0j, 1 + 0j, 0j],
#                        [0.5 , 1 + 1j, 2 + 0j, 0j]]))
#     array([[1.  , 0.02],
#            [0.5 , 0.02]])
# =============================================================================
import numpy as np
def kotopot(pot):
    novi = np.zeros((len(pot), 2))
    novi[:, 0] = np.real(pot[:, 0])
    resnica = np.imag(pot[:, 1:]) == 0
    novi[:, 1] = np.sum(np.real(pot[:, 1:]) * resnica * 0.01, axis = 1)
    return novi


# Ne dela:
# def kotopot(pot):
    koti = pot[:, 0].real
    poti = np.sum(pot[:, 1:].real * (pot[:, 1:].imag == 0), axis=1)
    return np.column_stack((koti, poti))



# =====================================================================@039112=
# 3. podnaloga
# Sedaj zapiši funkcijo `ogljisca(seznam)`, ki za argument sprejme rezultat
# funkcije `kotopot` (oblika tabele seznam je enaka kot oblika rezultata
# funkcije `kotopot`), vrne pa seznam koordinat zavojev, oblike `[[x_0, y_0],
# [x_1, y_1], ..., [x_N, y_N]]`, kjer indeks pove za kateri zavoj po vrsti gre.
# Privzemi, da so koti, ki jih sporoča robot absolutni koti glede na $x$ os
# zapisani v radianih.
# 
# Kakršnakoli uporaba for ali while zanke bo kaznovana z nič točkami, kot da
# naloge nebi reševali.
# 
# Primer:
# 
#     >>> ogljisca(np.array([[      0, 5],
#                            [np.pi/2, 2]]))
#     array([[5. , 0.],
#            [5. , 2.]])
# =============================================================================
import numpy as np
def ogljisca(seznam):
    koti = seznam[:, 0]
    razdalje = seznam[:, 1]

    x_koordinate = np.cumsum(np.cos(koti) * razdalje)
    y_koordinate = np.cumsum(np.sin(koti) * razdalje)
    
    koordinate = np.column_stack((x_koordinate, y_koordinate))
    return koordinate


# Uradna rešitev:
# def ogljisca(seznam):
    baza = np.zeros((len(seznam), 2))
    baza[:, 0] = np.cos(seznam[:, 0]) * seznam[:, 1]
    baza[:, 1] = np.sin(seznam[:, 0]) * seznam[:, 1]
    return np.cumsum(baza, axis=0)

def ogljisca(seznam):
    baza = np.zeros((len(seznam), 2))
    baza[:, 0] = np.cos(seznam[:, 0]) * seznam[:, 1]
    baza[:, 1] = np.sin(seznam[:, 0]) * seznam[:, 1]

    def maska(rob, baza):
        return np.fromfunction(lambda i, j: i < rob, np.shape(baza))
    velika_maska = np.fromfunction(lambda i, j, k: maska(i + 1, baza),
                                   (len(baza), len(baza), len(baza[0])))

    return np.sum(velika_maska * baza, axis=1)


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
NUMPY III.:
# Mafijski piknik
#
# Mafijski piknik je letno srečanje študentov in zaposlenih na FMF. Poleg žara in športnih aktivnosti se
# seveda prileže tudi pivo, ki se hrani v velikih sodih. Ker se dan po pikniku
# vsi sprašujejo kam so izginile enormne količine piva, so se organizatorji letos odločili,
# da na sode namestijo merilnike, ki merijo višino gladine piva. Poln sod ima gladino
# na višini 0, tako da morajo biti smiselni izmerki manjši ali enaki nič. Pomagaj
# organizatorjem napisati program, ki obdeluje podatke dobljene z merilnikom.
# 
# Pri tej nalogi je uporaba zank prepovedana. Če uporabljate zanke, lahko dosežete največ tretjino možnih točk.
# 
# Minister za zdravje opozarja: Prekomerno pitje alkohola škoduje zdravju!
# =====================================================================@039107=
# 1. podnaloga
# Merilnik proizvajalca A zajema meritve v enakomernih časovnih razmikih $\Delta t$, prva
# meritev je ob času $\Delta t$.
# Napiši program `povprecni_pretok_a(x, S, delta_t)`, ki za zaporedne meritve višine gladine soda
# s presekom `S` shranjene v 1D tabeli (`np.ndarray`) `x` izračuna povprečen pretok v času do začetka vsake meritve ter
# rezultate vrne v 1D tabeli.
# Povprečen pretok je enak celotnemu pretočenemu volumnu deljenemu s celotnim pretečenim časom.
# 
# Primer:
# 
#     >>> povprecni_pretok_a(np.array([0, -1.2, -2.5, -6, -12]), 1, 0.5)
#     array([0., -1.2, -1.66666667, -3., -4.8])
# =============================================================================
import numpy as np
def povprecni_pretok_a(x, S, delta_t):
    V =x* S
    return (V / np.arange(delta_t, delta_t *(np.size(x) +1), delta_t)) # np.arange(start, stop, korak)
# =====================================================================@039108=
# 2. podnaloga
# Merilnik proizvajalca B meritve zajema ob poljubnih časih, časovni interval med
# `(i - 1)`-to in `i`-to meritvijo podamo v 1D tabeli `delta_t` na mestu `i`. So pa nekatere
# meritve tega merilnika napačne, in sicer pokažejo višino, ki je večja od $0$. Te
# meritve izloči iz podatkov in jih ne uporabi v obdelavi. Napiši funkcijo
# `povprecni_pretok_b(x, S, delta_t)`, ki naredi enako kot prejšnja funkcija, le
# za merilnik proizvajalca B. Predpostaviš lahko, da je vsaj ena meritev veljavna.
# 
# *Namig*: Za izračun časa (kumulativnih vsot) utegne koristiti ena izmed [standardnih numpy funkcij](https://numpy.org/doc/stable/reference/arrays.ndarray.html).
# 
# Primer:
# 
#     >>> povprecni_pretok_b(np.array([0, -1.2, 3, -2.5, -6, -12]), 1, np.array([0.5, 1., 0.1, 0.5, 1., 0.2]))
#     array([0., -0.8, -1.19047619, -1.93548387, -3.63636364])
# 
# *Komentar*: V tem primeru meritve potekajo ob časih `[0.5, 1.5, 1.6, 2.1, 3.1, 3.3]`.
# =============================================================================
import numpy as np
def povprecni_pretok_b(x, S, delta_t):
    t = np.cumsum(delta_t)
    veljavni = x <= 0
    x = x [veljavni]
    t = t [veljavni]
    return (x * S / t)
# =====================================================================@039109=
# 3. podnaloga
# Po nekaj vrčkih piva so se študentje spomnili veliko zabavnejše
# uporabe nakupljenih senzorjev. Odločili so se, da bodo izmerili kako hitro
# (oziroma s kolikšnim največjim pretokom) lahko človek pije pivo. Vsakemu
# udeležencu eksperimenta so priredili sod z merilnikom proizvajalca
# A. Meritve za `i`-tega udeleženca shranimo v 2D tabelo `podatki` v `i`-to vrstico.
# Prav tako so določili, da je največji teoretični pretok skozi človeško
# grlo enak `phi_max` (`phi_max < 0`), torej vsi udeleženci, ki so ob katerem koli času pili
# s povprečnim pretokom po absolutni vrednosti večjim (zaradi negativnega znaka to pomeni manjšim) od `phi_max`, so
# goljufali.
# 
# Napiši funkcijo `najhitrejsi_pivec(podatki, S, delta_t, phi_max)`, ki vrne
# par (`tuple`), v katerem je na prvem mestu po absolutni vrednosti največji
# (ker so vsi smiselni pretoki negativni, to pomeni najmanjši) izmerjen povprečni
# pretok ob poljubnem času, pri čemer dosežki goljufivcev niso upoštevani,
# in na drugem mestu seznam (`list`) zaporednih števil udeležencev, ki so goljufali.
# Predpostaviš lahko, da vsaj en udeleženec ni goljufal.
# 
# Primer:
# 
#     >>> najhitrejsi_pivec(np.array([[0, -1.2, -2.5, -6, -12], [0, -0.6, -2, -3, -4.1], [0, -0.7, -2.3, -5.5, -8]]), 1, 0.5, -4.)
#     (-3.2, [0])
# =============================================================================
import numpy as np
def najhitrejsi_pivec(podatki, S, delta_t, phi_max):
    st_stolpcev = podatki.shape[1]
    t = np.arange(delta_t, delta_t *(st_stolpcev +1), delta_t) # velikosti matrike in velikost vektorja s katerim želimo množiti morata biti enako dolga
    V = podatki * S
    phi = V / t
    najboljsi_phi = np.min(phi, axis = 1) # axis = 1 - izpiše max v vodoravno, axis=0 - izpiše max navpično
    glojufi = najboljsi_phi < phi_max
    sez_glojufi = list(np.flatnonzero(glojufi)) # vrne tuple, flatnonezero pretvori v eno vrstico, nonezero pa pozicije
    negoljufi = najboljsi_phi >= phi_max 
    najboljsi_negoljuf = np.min(najboljsi_phi[negoljufi])
    return (najboljsi_negoljuf, sez_glojufi)

# Klada na klancu - numpy
#
# Pri tej nalogi je uporaba zank prepovedana. Če uporabljate zanke, lahko
# dosežete največ tretjino možnih točk.
# 
# Pri praktikumu merimo hitrost klade, ki drsi po klancu. Izvedli smo $N$
# ponovitev eksperimenta pri katerih smo z ultrazvočnim senzorjem razdalje
# merili položaj klade vzdolž klanca v odvisnosti od časa.
# 
# Ultrazvočni merilnik deluje preko odboja zvoka.
# Najprej z majhnim zvočnikom generira kratek ultrazvočni pulz, nato pa ga
# z vgrajenim mikrofonom zazna. Čas med poslanim paketom in zaznanim odbojem
# nam ta senzor vrne v enotah $\mathrm{ms}$. Izmerjeni časi se nahajajo v 2D tabeli
# (`np.ndarray`) oblike $(N, N_t)$, kjer je $N$ število ponovitev eksperimenta,
# $N_t$ pa število meritev razdalje med potekom vsakega eksperimenta.
# Prvo meritev položaja opravimo vedno pri času $t=0$, vse ostale pa pri časih,
# ki so za $dt=0.01 \ \mathrm{s}$ večji od prejšnjega časa.
# =====================================================================@039104=
# 1. podnaloga
# Če želimo čas potovanja sunka pretvoriti v razdaljo moramo rešiti preprosto
# enačbo $s = \frac12 c_{air} t$, kjer je $s$ razdalja od klade do senzorja,
# $c_{air}$ hitrost zvoka v zraku in $t$ čas potreben za odboj. Na žalost je
# hitrost zvoka v zraku odvisna od temperature, zato moramo upoštevati tudi
# to. Privzemi, da se hitrost zvoka v zraku (izražena v $\mathrm{\frac{m}{s}}$) izračuna kot
# $c_{air} = \sqrt{401.88 T}$; kjer je $T$ temperatura izražena v Kelvinih.
# Ob vsaki ponovitvi eksperimenta si v 1D tabelo `temperatura` zapišemo
# temperaturo zraka v kelvinih.
# 
# Sestavi funkcijo `pretvori_v_razdaljo(casi, temperatura)`, ki nam čase
# med poslanim pulzom (merjeno v $\mathrm{ms}$) in njegovo zaznavo pretvori v
# razdaljo izraženo v metrih.
# 
# Primer za eno ponovitev eksperimenta $(N=1)$ in dve ponovitvi:
# 
#     >>> pretvori_v_razdaljo(np.array([[10.1, 5.25, 0.4]]), np.array([294.30523903]))
#     array([[1.73675505 0.90276872 0.06878238]])
#     >>> pretvori_v_razdaljo(np.array([[10.1, 0.4],[10.0713254, 0.37488064]]), np.array([295.39220127, 296.57263143]))
#     array([[1.73995929, 0.06890928], [1.73848267, 0.0647108]])
# =============================================================================
import numpy as np


def pretvori_v_razdaljo(casi, temperature):
    return 0.5 * casi * 1e-3 * np.sqrt(401.88 * np.atleast_2d(temperature).T)
# =====================================================================@039105=
# 2. podnaloga
# Sedaj bi iz dobljenih položajev klade radi izračunali hitrosti.
# Sestavi funkcijo `povprecne_hitrosti(polozaji)`, ki sprejme
# prej izračunane položaje oblike $(N, N_t)$ vrne pa tabelo,
# ki na prvem mestu vsake vrstice vsebuje povprečno hitrost
# ponovitve, na nadaljnjih mestih pa izračunane trenutne hitrosti
# med eksperimenti v enotah $\mathrm{\frac{m}{s}}$. Časi med posameznimi meritvami položaja so
# konstantni in znašajo $0.01 \ \mathrm{s}$. Izhodna tabela bo torej oblike
# $(N, N_t)$ ($N_t - 1$ trenutnih hitrosti $+1$ za povprečno
# hitrost).
# 
# Primer:
# 
#     >>> povprecne_hitrosti(np.array([[1.71962294, 0.06810388], [1.75406856, 0.06371724]]))
#     array([[-165.151906, -165.151906], [-169.035132, -169.035132]])
#     >>> povprecne_hitrosti(np.array([[1.70044888, 0.88389669, 0.06734451]]))
#     array([[-81.6552185, -81.655219 , -81.655218 ]])
# =============================================================================
import numpy as np


def povprecne_hitrosti(polozaji):
    vs = (polozaji[:, 1:] - polozaji[:, :-1]) / 0.01
    vs_avg = np.atleast_2d(np.average(vs, axis=1))
    return np.concatenate((vs_avg.T, vs), axis=1)


# alternativa
def povprecne_hitrosti(polozaji):
    vs = (polozaji[:, 1:] - polozaji[:, :-1]) / 0.01
    return np.pad(vs, ((0, 0), (1, 0)), "mean")
# =====================================================================@039106=
# 3. podnaloga
# Pri obdelavi podatkov opaziš, da imajo nekateri eksperimenti veliko
# večjo razpršenost rezutatov kot drugi - razpršenost merimo s standarno
# deviacijo, ki jo za določen eksperiment izracunamo kot
# $\sqrt{\frac{1}{N} \sum_i \left(v_i - v_{average}\right)^2}$.
# Zaveš se, da obstaja možnost, da si med pripravo posameznih ponovitev
# eksperimenta po pomoti pritisnil na gumb, ki preklaplja med visoko in
# nizko časovno ločljivostjo senzorja. Pokvarjene ponovitve si se odločil
# odstraniti iz seta meritev, tako da jih ne boš upošteval.
# 
# Sestavi funkcijo `koncno_povprecje(polozaji, meja_std)`, ki sprejme
# položaje klade za vse ponovitve eksperimenta ter mejo standardne deviacije.
# Funkcija naj izračuna standardno deviacijo hitrosti za vsako ponovitev, ter
# izloči vse eksperimente, kjer ta vrednost znaša več kot določena meja.
# Na preostalih eksperimentalnih ponovitvah naj nato izračuna in vrne
# povprečno hitrost povrečnih hitrosti zaokroženo na 2 decimalki.
# 
# Namig: Za zaokroževanje uporabi funkcijo [round](https://www.w3schools.com/python/ref_func_round.asp).
# 
# Primer:
# 
#     >>> koncno_povprecje(np.array([[1.70902097, 0.88835248, 0.067684], [1.7191911, 0.89788999, 0.07649603]]), 0.5)
#     -82.10
# =============================================================================
import numpy as np


def koncno_povprecje(polozaji, meja_std):
    povp = povprecne_hitrosti(polozaji)
    vs_avg = povp[:, 0]
    vs = povp[:, 1:]
    sigmas = np.sqrt((1 / (len(polozaji[0]) - 1)) * np.sum(np.square(vs.T - vs_avg).T, axis=1))
    return round(np.average(vs[np.where(sigmas < meja_std)]), 2)

# alternativa - uporabimo vgrajeno funkcijo std()
def koncno_povprecje(polozaji, meja_std):
    hitrosti = povprecne_hitrosti(polozaji)[:, 1:]
    return round(hitrosti[np.where(hitrosti.std(axis=1) < meja_std)].mean(), 2)

# Viseči most
#
# Če staknemo $n$ palic (na stikih je prosto gibljivo) in skrajni palici
# pritrdimo na dve krajišči in spustimo, se oblikuje tako imenovana [diskretna
# verižnica ali viseči most](https://physics.stackexchange.com/questions/82870/a-discrete-approach-to-the-catenary/364081).
# Koordinate  $x$ in $y$ je za vas poračunal
# že asistent, za vas pa je pripravil nekaj drugih vprašanj.
# 
# Viseči most predstavimo kot tabelo z dvema vrsticama. V prvi vrstici se
# nahajajo $x$ koordinate, v drugi vrstici pa $y$ koordinate krajišč
# vseh palic. En primer je naveden spodaj.
# 
# 
# Primer:
# 
#     ver = np.array(
#         [
#             [0,    0.3025,    1.8705,    2.9579,    5.3692,   11.3572,   17.4031,   17.9169, 19.4162,   20.0000],
#             [0,   -0.9531,   -4.6330,   -6.3116,   -8.0964,   -7.7182,   -2.4792,   -1.6213,  2.0871,    4.0000],
#         ]
#     )
# 
# Pri tej nalogi je uporaba zank prepovedana. Če jih uporabljate, lahko dosežete
# kvečjemu tretjino točk.
# =====================================================================@039100=
# 1. podnaloga
# Reka se nahaja na $y$ koordinati `y_r`. Napiši funkcijo `je_poplavljen(ver, y_r)`, ki
# sprejme viseči most `ver` in $y$ koordinato reke `y_r` ter vrne `True`, če
# most sega v reko in `False` sicer.
# 
# Primer:
# 
#     >>> je_poplavljen(ver, -7)
#     True
# =============================================================================
import numpy as np

def je_poplavljen(ver, y_r):
    return np.min(ver[1, :]) < y_r
# =====================================================================@039101=
# 2. podnaloga
# Napiši funkcijo `lahko_sestavi(ver, l, delta)`, ki sprejme
# viseči most `ver`, kot je opisano zgoraj, dolžine palic `l`, ki jih imamo
# na razpolago. Tabela `l` ima enako dolžino, kot je dolžina vrstice v tabeli
# `ver` manj 1, tj. $len(l) = len(ver[0]) - 1$. Zadnji vhodni parameter `delta`
# pove, za koliko največ palice lahko odstopajo
# od točnih dolžin.
# 
# Primer:
# 
#     >>> lahko_sestavim(ver, np.array([1, 1, 2, 2, 3, 4, 4, 6, 8]), 0.001)
#     True
#     >>> lahko_sestavim(ver, np.array([8, 0.9, 6, 2, 9, 4, 4, 2, 1]), 0.1)
#     False
# =============================================================================
def lahko_sestavim(ver, l, delta):
    dx = ver[0, 1:] - ver[0, :-1]
    dy = ver[1, 1:] - ver[1, :-1]
    return np.alltrue(np.abs((np.sort(np.sqrt(dx ** 2 + dy ** 2)) - np.sort(l))) <= delta)
# =====================================================================@039102=
# 3. podnaloga
# Žogo poševno vržemo iz točke $(x, y)$ z začetno hitrostjo $(vx, vy)$.
# Napiši funkcijo `presecisce(x, y, vx, vy, k, n)`, ki sprejme `x` in `y`
# koordinato začetne točke, `vx` in `vy` komponenti začetne hitrosti in
# `k`, ki je vrstica smernih koeficientov premic z začetnimi vrednostmi `n`
# in vrne tabelo $x$ koordinat in $y$ koordinat presečišč trajektorije
# žoge in premic (v prvi vrsti naj bodo $x$ koordinate, v drugi pa $y$
# koordinate). Če se premica in parabola ne sekata, naj bosta koordinati
# presečišč `np.nan` (seveda so vrednosti `np.nan` tudi v vseh presečiščih pri
# negativnem času), če pa se sekata v več točkah, naj bosta koordinati
# kasnejši, tj. tisti kjer se sekata ob kasnejšem času. Za gravitacijski
# pospešek vzemi $g = \pi^2$.
# 
# Primer:
# 
#     >>> presecisce(2, 5, 0, 0, np.array([-1.75622079,  0.96173056,  3.13605442,  6.12625698]), np.array([  5., -5.75901044, -23.76915238, -51.26256983]))
#     array([[  2., 2., 2., 2.], [  1.48755842,  -3.83554931, -17.49704354, -39.01005587]])
#     >>> presecisce(2, 5, 2, 1, np.array([-1.75622079,  0.96173056,  3.13605442,  6.12625698]), np.array([  5., -5.75901044, -23.76915238, -51.26256983]))
#     array([[  4.83358535,   4.49556127,   5.33355537,   6.11293874], [ -3.48884308,  -1.43549177,  -7.04283247, -13.81313618]])
# =============================================================================
def presecisce(x, y, vx, vy, k, n):
    """
    - položaj točke P(t) = (x + vx*t, y + vy*t - gt²/2), vstavimo v Y = kX + n
    - dobimo kvadratno enačbo.
    """
    g = np.pi ** 2
    a = g / 2
    b = k * vx - vy
    c = n - y + k * x
    D = b ** 2 - 4 * a * c
    D = np.where(D < 0, np.nan, D)
    t1 = (-b + np.sqrt(D)) / (2 * a)
    t2 = (-b - np.sqrt(D)) / (2 * a)
    t = np.maximum(t1, t2)
    t = np.where(t < 0, np.nan, t)
    x = x + vx * t
    y = k * x + n
    return np.array([x, y])
# =====================================================================@039103=
# 4. podnaloga
# **Dodatna naloga**
# 
# Napiši funkcijo `kje_odboj(x, y, vx, vy, ver)`, ki sprejme začetno lego
# in hitrost žoge ter koordinate visečega mostu `ver` enako kot zgoraj,
# vrne pa indeks členka, na katerem se zgodi odboj (če pade točno na dva
# členka, naj vrne manjši indeks). Če do odboja ne pride,
# naj funkcija vrača `-1`.
# 
# Primer:
# 
#     >>> kje_odboj(6, 100, 0, 0, ver)
#     4
#     >>> kje_odboj(6, 2, -3, -1, ver)
#     2
# =============================================================================
def kje_odboj(x, y, vx, vy, ver):
    ver_x = ver[0, :]
    ver_y = ver[1, :]
    k = ((ver_y - np.roll(ver_y, 1)) / (ver_x - np.roll(ver_x, 1)))[1:]
    n = (ver_y[:-1] - k * ver_x[:-1])
    presecisca = presecisce(x, y, vx, vy, k, n)[0]
    kateri_clenki = np.nonzero(np.less_equal(ver_x[:-1], presecisca) & np.less_equal(presecisca, ver_x[1:]))
    if np.size(kateri_clenki):
        return np.min(kateri_clenki)
    else:
        return -1

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
KOLOKVIJ 2019/20 (1. termin):
# 1. naloga - Družabne igre
#
# Urška se rada igra družabno igro A, ki jo lahko igra natanko `a` ljudi, in
# družabno igro B, ki jo lahko igra natanko `b` ljudi. Vsak človek lahko igra
# samo eno igro. Po izpitu iz Računalniškega praktikuma Urška planira zabavno,
# na kateri bodo igrali omenjeni družabni igri. Urška ima doma neomejeno zalogo
# iger A in B ter želi, da se na zabavi naenkrat igra samo igro A ali samo igro
# B.  Prav tako želi, da se nihče ne bo dolgočasil, torej da bodo vsi ves čas
# igrali družabne igre.  Sigurno tudi želi igrati obe družabni igri. Pomagaj
# Urški ugotoviti največje število ljudi, ki jih lahko povabi na zabavo.
# =====================================================================@022616=
# 1. podnaloga
# Definiraj funkcijo `lahko_igrajo(n, a, b)`, ki vrne `True`, če lahko `n` ljudi
# igra igro A za natanko `a` igralcev in igro B za natanko `b` igralcev.
# 
# Primer:
# 
#     >>> lahko_igrajo(30, 3, 5)
#     True
#     >>> lahko_igrajo(40, 2, 7)
#     False
# =============================================================================
def lahko_igrajo(n, a, b):
    if n % a == 0 and n % b == 0:
        return True
    else:
        return False
# =====================================================================@022617=
# 2. podnaloga
# Urška pozna `k` ljudi. Napiši funkcijo `najvecja_zabava(k, a, b)`, ki vrne
# največje število ljudi, ki jih lahko Urška povabi na zabavo.
# 
# Primer:
# 
#     >>> najvecja_zabava(36, 3, 5)
#     30
# =============================================================================
def najvecja_zabava(k, a, b):
    n = k
    while lahko_igrajo(n, a, b) == False:
        n -= 1
    return n
# =====================================================================@022618=
# 3. podnaloga
# Urška sovraži igrati igro C za natanko `c` igralcev, vendar ve, da se jo nekateri
# njeni prijatelji zelo radi igrajo. Zaradi tega želi povabiti toliko ljudi, da se
# igre C sigurno ne bodo mogli igrati. Predpostavi, da ima Urška neomejeno zalogo
# iger C in da želi, da se nihče ne bo dolgočasil, torej da bodo vsi ves čas igrali
# družabne igre. Napiši funkcijo `optimalna_zabava(k, a, b, c)`, ki vrne največje
# število ljudi, ki jih Urška lahko povabi na zabavo, če upoštevamo, da ne želi
# igrati igre C. Ostale oznake so enake kot pri prejšnjih podnalogah.
# 
# Primer:
# 
#     >>> optimalna_zabava(36, 3, 5, 6)
#     15
# =============================================================================
def optimalna_zabava(k, a, b, c):
    for i in range(k, -1, -1):
        if lahko_igrajo(i, a, b) and i % c != 0:
            return i
    return 0


# Narobe: potreben je fo loop
#def optimalna_zabava(k, a, b, c):
    n = k
    while (lahko_igrajo(n, a, b) == False) or (n % c == 0):
        n -= 1
    return n

# 2. naloga - Ljubezenska sporočila
#
# Zaljubljenca Mitja in Nina si med vajami rada pišeta ljubezenska sporočila,
# vendar ju je strah, da bi jih lahko prebral kdo drug, zato sta se odločila, da
# jih zakodirata. Odločila sta se, da bosta vse samoglasnike v sporočilih
# zamenjala z nekim v naprej določenimi nizom. Tako gotovo nihče drug ne bo razumel
# sporočil, njima pa razvozlavanje ne bo povzročalo večjih težav.
# =====================================================================@022601=
# 1. podnaloga
# Sestavite funkcijo `je_samoglasnik(s)`, ki vrne `True`, če je podan niz `s`
# samoglasnik in `False` sicer. Če je niz `s` daljši od 1, naj funkcija prav
# tako vrne `False`.
# 
# Primer:
# 
#     >>> je_samoglasnik('a')
#     True
#     >>> je_samoglasnik('b')
#     False
# =============================================================================
def je_samoglasnik(s):
    samoglasniki = ['a', 'e', 'i', 'o', 'u']
    if len(s) > 1:
        return False
    else:
        if s in samoglasniki:
            return True
        else:
            return False
    
# =====================================================================@022602=
# 2. podnaloga
# Sestavite funkcijo `zakodiraj(sporocilo, koda)`, ki zakodira niz `sporocilo`
# tako, da vsak samoglasnik v nizu `sporocilo` zamenja z nizom `koda`, in rezultat
# vrne. Dolžina niza `koda` ni nujno enaka 1.
# 
# Primer:
# 
#     >>> zakodiraj('Ali imas cas danes popoldne?', ' ')
#     'Al   m s c s d n s p p ldn ?'
# =============================================================================
def zakodiraj(sporocilo, koda):
    nov_niz = []
    for i in sporocilo:
        if je_samoglasnik(i):
            nov_niz += koda
        else:
             nov_niz += i
    return ''.join(nov_niz)


# Uradna rešitev: bolje ker ni poterben .join
#def zakodiraj(sporocilo, koda):
    rezultat = ''

    for c in sporocilo:
        if je_samoglasnik(c):
            rezultat += koda
        else:
            rezultat += c

    return rezultat


# =====================================================================@022603=
# 3. podnaloga
# Sošolci so kmalu ugotovili način kodiranja ljubezenskih pisem, zato sta se Mitja
# in Nina odločila za novo strategijo. Sedaj bosta `i`-ti samoglasnik v nizu
# `sporocilo` zamenjala z `i`-tim znakom v nizu `koda`. Sestavite funkcijo
# `zakodiraj_novo(sporocilo, koda)`, ki vrne niz `sporocilo` zakodiran po novem
# algoritmu.
# 
# Vedno bo veljalo, da je število samoglasnikov v nizu `sporocilo` manjše ali
# enako številu znakov v nizu `koda`.
# 
# Primer:
# 
#     >>> zakodiraj_novo('beseda', 'xyz')
#     'bxsydz'
# =============================================================================
def zakodiraj_novo(sporocilo, koda):
    nov_niz = ''
    sam = 0
    for i in sporocilo:
        if je_samoglasnik(i):
            nov_niz += koda[sam]
            sam += 1
        else:
             nov_niz += i
    return nov_niz

# 3. naloga - Merilec dežja
#
# Študent meteorologije Štefan se je odločil, da bo spremljal padavine v svojem
# domačem kraju, zato si je kupil enostaven senzor za dež. Senzor razdeli uro na
# `d` časovnih intervalov in za vsak časovni interval sporoči meritev `'+'`, če
# je v tem intervalu deževalo in `'-'`, če ni.
# Pomagaj Štefanu napisati program za obdelovanje podatkov, ki jih izmeri
# senzor.
# =====================================================================@022605=
# 1. podnaloga
# Senzor vrne niz meritev `meritve`, ki je sestavljen samo iz znakov `'+'` in `'-'`.
# Sestavite funkcijo `obdelaj(meritve, d)`, ki vrne seznam dvojic `(a, b)`, v kateri
# vsaka dvojica predstavlja padavine v eni uri. Število `a` naj bo enako številu
# deževnih minut v neki uri in `b` številu suhih minut v neki uri.
# Predpostavi, da je en interval lahko samo v celoti deževen ali suh in da niz
# `meritve` vsebuje meritve iz celega števila ur.
# 
# Primer:
# 
#     >>> obdelaj('+-+---+++', 3)
#     [(40.0, 20.0), (0.0, 60.0), (60.0, 0.0)]
# =============================================================================
def obdelaj(meritve, d):
    inti = d
    a = 0
    b = 0
    niz = []
    for i in meritve:
        if i == '+':
            a += 60/d
        elif i == '-':
            b += 60/d
                
        inti -= 1
        if inti == 0: 
            niz.append((a, b))
            inti = d
            a = 0
            b = 0

    return niz
    


# =====================================================================@022607=
# 2. podnaloga
# V prihodnosti želi Štefan razširiti svojo meteorološko postajo na poljubno
# število krajev v Sloveniji in jih med seboj primerjati.
# Sestavite funkcijo `najdezevnejsi(kraji, d)`, ki sprejme seznam meritev `kraji`
# (vsak element je niz `meritve` iz prejšnjih podnalog) iz različnih krajev in
# vrne zaporedno število (indeks) kraja, ki ima v povprečju največ padavin na uro.
# Če imata dva kraja enako povprečno količino padavin, naj funkcija vrne najmanjšega
# izmed teh indeksov. Kraje začnemo številčiti z indeksom 0.
# 
# Primer:
# 
#     >>> najdezevnejsi(['+-+---+++', '+-+---+--'], 3)
#     0
# =============================================================================
def najdezevnejsi(kraji, d):
    mx = 0
    ind = 0

    for i in range(len(kraji)):
        l = obdelaj(kraji[i], d)
        avg = 0

        for ura in l:
            avg += ura[0]

        avg /= len(l)

        if avg > mx:
            mx = avg
            ind = i

    return ind

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
KOLOKVIJ 2019/20 (2. termin):
# 1. naloga - Deljenje torte
#
# Janez ima veliko prijateljev, s katerimi bi rad praznoval rojstni dan, in še
# več znancev.  Babica mu je prijazno spekla torto, a ima le ta več kosov, kot
# Janez prijateljev. Janez je okoljsko ozaveščen in ne želi zavreči popolnoma
# dobrih kosov, obenem pa želi, da vsi udeleženci zabave prejmejo enako število
# kosov.
# =====================================================================@022608=
# 1. podnaloga
# Napišite funkcijo `je_deljivo(kosi, gosti)`, ki sprejme število kosov torte in
# število povabljenih gostov ter vrne `True`, če lahko kose razdelimo med goste
# brez ostanka in `False` v nasprotnem primeru.
# 
# Primer:
# 
#     >>> je_deljivo(10, 7)
#     False
#     >>> je_deljivo(2, 1)
#     True
# =============================================================================
def je_deljivo(kosi, gosti):
    if kosi % gosti == 0:
        return True
    else:
        return False

# =====================================================================@022609=
# 2. podnaloga
# Napišite funkcijo `stevilo_znancev(kosi, prijatelji)`, ki sprejme število kosov
# torte in število povabljenih prijateljev ter vrne najmanjše število znancev,
# ki jih mora Janez povabiti, da zagotovi pravično delitev torte.
# 
# Primer:
# 
#     >>> stevilo_znancev(10, 7)
#     3
# =============================================================================
def stevilo_znancev(kosi, prijatelji):
    znanci = 0
    while not je_deljivo(kosi, prijatelji + znanci):
        znanci += 1
    return znanci


# =====================================================================@022610=
# 3. podnaloga
# Janez je ugotovil, da je za sklepanje novih prijateljstev optimalno, če je na
# zabavi tretjina ali več znancev. Sestavite funkcijo
# `optimalno_razmerje(max_kosi, prijatelji)`, ki sprejme maksimalno število kosov
# torte in število povabljenih prijateljev ter vrne za koliko različnih števil
# kosov manjših od `max_kosi` je razmerje izpolnjeno. Za določanje razmerja pri 
# posameznem številu kosov upoštevajte rezultat za minimalno število povabljenih
# znancev, ki ste ga že izračunali pri prejšnji podnalogi.
# Vsak gost mora prejeti vsaj en kos!
# 
# Primer:
# 
#     >>> optimalno_razmerje(10, 3)
#     3
# =============================================================================
def optimalno_razmerje(max_kosi, prijatelji):
    ponovitve = 0
    for kosi in range(prijatelji, max_kosi + 1):
        if 2 * stevilo_znancev(kosi, prijatelji) >= prijatelji:
            ponovitve += 1
    return ponovitve


# 2. naloga - Delo s seznami
# =====================================================================@022611=
# 1. podnaloga
# Sestavite funkcijo `index_maksimuma(s)`, ki sprejme neprazen seznam števil
# in vrne indeks maksimalne vrednosti. Če je več istih maksimalnih vrednosti
# upoštevajte zadnjo.
# =============================================================================
def index_maksimuma(s):
    ind_max = 0
    for i in range(0, len(s)):
        if s[i] >= s[ind_max]:
            ind_max = i
    return ind_max


# =====================================================================@022612=
# 2. podnaloga
# Sestavite funkcijo `povprecna_vrednost(s)`, ki sprejme seznam števil
# in vrne njihovo povprečno vrednost. Za prazen seznam se smatra, da ima povprečno
# vrednost 0.
# =============================================================================
def povprecna_vrednost(s):
    sk = 0
    if len(s) == 0:
        return 0
    for i in s:
        sk += i
    return (sk / int(len(s)))



# =====================================================================@022613=
# 3. podnaloga
# Sestavite funkcijo `razlika_povprecij(s)`, ki sprejme neprazen seznam števil.
# Funkcija naj izračuna in vrne absolutno vrednost razlike med povprečno vrednostjo
# seznama levo od maksimuma in seznama desno od maksimuma, kjer sam maksimum ni vključen
# v kateregakoli od seznamov. Maksimum naj bo določen na način opisan v prvi podnalogi,
# povprečna vrednost pa na način v drugi podnalogi.
# =============================================================================
def razlika_povprecij(s):
    st = index_maksimuma(s)
    pred = povprecna_vrednost(s[0:st]) # ta ne vpošteva končnega elementa
    za = povprecna_vrednost(s[st+1:]) # samo ta vpošteva začetni element
    return (abs(pred - za))

# 3. naloga - Skoraj sudoku
#
# Miha ne mara pravil in rad rešuje logične uganke. Sudoku se mu je vedno zdel
# preveč omejujoč, zato se je spomnil svoje verzije, kjer je spustil del
# pravil. V njegovi verziji igre je velikost igralne mreže poljubna (število
# stolpcev je še vedno enako številu vrstic), v poljih pa se lahko pojavljajo
# poljubna cela števila. Edino ohranjeno pravilo je, da morajo biti števila
# znotraj vsake vrstice in znotraj vsakega stolpca enolična.
# 
# Miha je nad svojo igro navdušen in veselo rešuje probleme, vaša naloga pa je,
# da sestavite funkcijo, ki mu bo pomagala pri preverjanju rešitev.
# 
# Rešitve bodo podane kot $n \times n$ razpredelnice, kar v Pythonu predstavimo kot
# seznam v katerem se nahaja $n$ seznamov dolžine $n$. Seznam, ki se v zunanjem
# seznamu nahaja na prvem mestu (torej indeks 0) predstavlja prvo vrstico,
# vrednost na prvem mestu tega seznama (torej indeks 0) pa vrednost v prvem
# stolpcu prve vrstice.
# =====================================================================@022689=
# 1. podnaloga
# Sestavite funkcijo `stolpec(razpredelnica, i)`, ki sprejme $n \times n$
# razpredelnico in indeks stolpca ter vrne njen `i`-ti stolpec kot seznam.
# Število `i` bo vedno veljaven indeks stolpca.
# 
# Primer:
# 
#     >>> stolpec([[1, 1], [1, 1]], 1)
#     [1, 1]
# =============================================================================
def stolpec(razpredelnica, i):
    stolp = []
    for vrstica in razpredelnica:
        stolp.append(vrstica[i])
    return stolp


# =====================================================================@022672=
# 2. podnaloga
# Sestavite funkcijo `delez_pravilnih(seznam_resitev)`, ki sprejme seznam rešitev
# predstavljenih v obliki $n \times n$ razpredelnic in vrne delež pravilnih rešitev.
# Seznam rešitev bo vedno vseboval vsaj eno rešitev.
# 
# Primer:
# 
#     >>> delez_pravilnih([[[1, 2], [2, 1]], [[1, 1], [1, 1]], [[1]]])
#     0.6666666666666666
# =============================================================================
def delez_pravilnih(seznam_resitev):
    pravilne = 0
    for res in seznam_resitev:
        for i in range(len(res)):
            vrstica = []
            stolpec = []
            for j in range(len(res)):
                if res[i][j] in vrstica or res[j][i] in stolpec:
                    break
                vrstica.append(res[i][j])
                stolpec.append(res[j][i])
            else:
                continue
            break
        else:
            pravilne += 1
    return pravilne / len(seznam_resitev)


???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
KOLOKVIJ 2019/20 (3. termin):
# 1. naloga - Sveto število
#
# Alekdander de Popov je pravi verski entuziast, zato bi rad ustanovil novo
# religijo, ki bi častila najsvetejše število. Ne ve pa še, kakšno to število je.
# Da bi si olajšal delo, te je prosil, da mu napišeš nekaj algoritmov.
# =====================================================================@022619=
# 1. podnaloga
# Napiši funkcijo `vsota_deliteljev(n)`, ki sprejme pozitivno celo število
# $n$ in vrne vsoto pozitivnih celih deliteljev števila $n$. Pozitivni
# delitelj števila $n$ je število, ki deli število $n$ brez ostanka.
# 
# Primer:
# 
#     >>> vsota_deliteljev(6)
#     12
#     >>> vsota_deliteljev(100)
#     217
# =============================================================================
def vsota_deliteljev(n):
    vsota = 0
    for delitelj in range(1, n+1):
        if n % delitelj == 0:
            vsota += delitelj
    return vsota

# ali

def vsota_deliteljev(n):
    return sum(d for d in range(1, n+1) if n % d == 0)
# =====================================================================@022638=
# 2. podnaloga
# Napiši funkcijo `je_kristalno_stevilo(n)`, ki sprejme pozitivno celo število
# $n$ in vrne `True`, če je število $n$ kristalno število in `False`, če število $n$
# ni kristalno število. Kristalno število je število, katerega vsota pozitivnih
# celih deliteljev je enaka dvakratniku števila.
# $$ \sigma(n) = 2n,$$
# kjer je $\sigma(n)$ vsota pozitivnih celih deliteljev števila $n$.
# 
# Primer:
# 
#     >>> je_kristalno_stevilo(6)
#     True
#     >>> je_kristalno_stevilo(100)
#     False
# =============================================================================
def je_kristalno_stevilo(n):
    return vsota_deliteljev(n) == 2*n
# =====================================================================@022640=
# 3. podnaloga
# Napiši funkcijo `je_sveto_stevilo(n)`, ki sprejme pozitivno celo število
# $n$ in vrne `True`, če je število $n$ sveto število in `False`, če število $n$
# ni sveto število. Sveto število je število, katerega število pozitivnih
# deliteljev (vključno s številom samim) je kristalno število in katerih vsota
# je spet kristalno število.
# 
# Število 20 ni sveto, ker je število pozitivnih celih deliteljev $(1, 2, 4, 5, 10, 20)$
# kristalno število, ampak njihova vsota $42$ ni kristalno število.
# 
# Primer:
# 
#     >>> je_sveto_stevilo(12)
#     True
#     >>> je_sveto_stevilo(20)
#     False
# =============================================================================
def je_sveto_stevilo(n):
    vsota = 0
    stevilo = 0
    for delitelj in range(1, n+1):
        if n % delitelj == 0:
            stevilo += 1
            vsota += delitelj
    return je_kristalno_stevilo(stevilo) and je_kristalno_stevilo(vsota)

## ali

def je_sveto_stevilo(n):
    delitelji = [d for d in range(1, n+1) if n % d == 0]
    return je_kristalno_stevilo(len(delitelji)) and je_kristalno_stevilo(sum(delitelji))
# =====================================================================@022641=
# 4. podnaloga
# Zdaj lahko končno pomagaš Aleksandru. Povej mu katero število je sveto število
# tako, da ga napišeš v prostor spodaj. Pri iskanju si lahko pomagaš s
# funkcijo `je_sveto_stevilo` in for zanko. Če program napiše `4. podnaloga ima veljavno rešitev.`
# to še ne pomeni, da je rešitev pravilna.
# 
# Namig: sveto število je manjše od 10000
# =============================================================================
12

# 2. naloga - Seznami
# =====================================================================@022669=
# 1. podnaloga
# Definiraj funkcijo `razbij_na_tri(seznam)`, ki sprejme seznam poljubne dolžine
# in vrne tri sezname enake dolžine. Če je ostanek pri deljenju dolžine s tri
# ena, naj bo zadnji seznam daljši za ena, če je ostanek dva, pa naj bosta zadnja
# dva seznama oba daljša za ena. Če je dolžina seznama manj od $3$, naj funkcija
# vrne `None`.
# 
# Primer:
# 
#     >>> razbij_na_tri([3, 7, 'a', 5, 8, 9])
#     ([3, 7], ['a', 5], [8, 9])
#     >>> razbij_na_tri([3, 7, 'a', 5, 8, 9, 4])
#     ([3, 7], ['a', 5], [8, 9, 4])
#     >>> razbij_na_tri([3, 7, 'a', 5, 8, 9, 4, 10])
#     ([3, 7], ['a', 5, 8], [9, 4, 10])
# =============================================================================
def razbij_na_tri(seznam):
    n = len(seznam)
    if n >= 3:
        return seznam[:n//3], seznam[n//3 : 2*n//3], seznam[2*n//3:]
# =====================================================================@022670=
# 2. podnaloga
# Definiraj funkcijo `zdruzi(seznam1, seznam2, seznam3)`, ki sprejme tri sezname
# poljubne dolžine in vrne en seznam, ki vsebuje elemente iz vseh treh seznamov
# v pravem vrstnem redu.  Če so vsi seznami prazni, naj vrne seznam z elementom
# $0$.
# 
# Primer:
# 
#     >>> zdruzi([3, 7, 'a', 5, 8, 9], [4], [])
#     [3, 7, 'a', 5, 8, 9, 4]
#     >>> zdruzi([3, 7], ['a', 5], [8, 9, 4])
#     [3, 7, 'a', 5, 8, 9, 4]
#     >>> zdruzi([], [], [])
#     [0]
# =============================================================================
def zdruzi(prvi, drugi, tretji):
    if len(prvi) or len(drugi) or len(tretji):
        return prvi + drugi + tretji
    return [0]
# =====================================================================@022671=
# 3. podnaloga
# Definiraj funkcijo `zamenjaj(seznam_seznamov, i , j)`, ki sprejme seznam seznamov
# in prestavi podseznam na `i`-tem mestu na `j`-to mesto in podseznam na `j`-tem mestu
# na `i`-to mesto. Če je katerikoli izmed indeksov `i` ali `j` večji od seznama, vrni
# nespremenjen seznam seznamov.
# 
# Primer:
# 
#     >>> zamenjaj([[2, 3, 4], [1, 1, 1, 1], [1, 2, 1], [43, 2, 3], [0, 2, 1]], 1, 3)
#     [[2, 3, 4], [43, 2, 3], [1, 2, 1], [1, 1, 1, 1], [0, 2, 1]]
#     >>> zamenjaj([[], [1, 1, 1], [1, 2, 1], [43, 2, 3], [0, 2, 1]], 1, 0)
#     [[1, 1, 1], [], [1, 2, 1], [43, 2, 3], [0, 2, 1]]
# =============================================================================
def zamenjaj(seznam, i, j):
    if i < len(seznam) and j < len(seznam):
        seznam[i], seznam[j] = seznam[j], seznam[i]
    return seznam

# 3. naloga - Računalniški kriptograf Andraž
#
# Računalniški kriptograf Andraž je zaposlen na kiribatskem oddelku skrivne
# vojaške obveščevalne službe ZNOJ. Poleg 32 kiribatskih atolov (koralnih otokov)
# njegov oddelek pokriva še nekaj drugih okoliških otokov. Njegova naloga je
# da razvije program, ki uspešno prepozna v katerem jeziku je napisano presteženo
# zakodirano sporočilo. Do sedaj je ugotovil, da na območju prevladuje šest
# jezikov, od katerih ima vsak jezik različno število znakov v abecedi.
# 
# - Angleško: 26
# - Rusko: 33
# - Špansko: 32
# - Kiribatsko: 15
# - Bislamsko: 22
# - Francosko: 40
# =====================================================================@022614=
# 1. podnaloga
# Pomagaj Andražu in definiraj funkcijo `kateri_jezik(sporocilo)`, ki za argument
# sprejme niz znakov z zgolj tremi ločili - `','`,`'.'`, `' '`. Besedilo je
# zakodirano tako, da vsak znak, ki ni ločilo, predstavlja prav določeno malo
# črko iz abecede. Funkcija naj pove v katerem jeziku je sporočilo napisano (
# v vsakem sporočilu so uporabljene vse črke abecede), oziroma vrne `None` če je niz
# napisan v nekem drugem jeziku.
# 
# Primer:
# 
#     >>> kateri_jezik(niz_iz_26_znakov)
#     'Angleško'
#     >>> kateri_jezik(niz_iz_30_znakov)
#     None
# =============================================================================
def kateri_jezik(sporocilo):
    abecednik = []  # bolje je, ce je set()
    for i in sporocilo:
        if i not in ",. ":
            if i not in abecednik:
                abecednik.append(i)

    n = len(abecednik)
    jeziki = [('Angleško', 26), ('Rusko', 33), ('Špansko', 32), ('Kiribatsko', 15), ('Bislamsko', 22), ('Francosko', 40)]
    for jezik, stevilo in jeziki:  # lahko tudi 6 if-ov, oz. kasneje je prava izbira slovar
        if stevilo == n:
            return jezik
# =====================================================================@022615=
# 2. podnaloga
# Da bi opravil posebno statistično analizo, Andraž potrebuje funkcijo, ki
# izračuna povprečno dolžino besed med ločili. Napiši funkcijo
# `povprecna_dolzina_besed(seznam_besed)`, ki sprejme seznam besed v besedilu
# in vrne `'Besedilo je prekratko za frekvenčno analizo'`, če je število
# besed manjše od $100$, `'Neznan jezik'`, če besedilo ni napisano v enem izmed zgornjih
# jezikov in `(jezik, povprecna dolzina besed)`, če ima besedilo dovolj besed in
# je napisano v znanem jeziku. Če je besedilo prekratko in napisano v neznanem jeziku,
# naj funkcija vrne `'Besedilo je prekratko za frekvenčno analizo'`.
# Primer:
# 
#     >>> povprecna_dolzina_besed(['who', 'is', 'this'])
#     'Besedilo je prekratko za frekvenčno analizo'
#     >>> povprecna_dolzina_besed(dolg_seznam_z_besedami_iz_12_znakov)
#     'Neznan jezik'
#     >>> povprecna_dolzina_besed(dolg_seznam_z_besedami_iz_33_znakov)
#     ('Rusko', 5.4)
# =============================================================================
def povprecna_dolzina_besed(seznam_besed):
    n = len(seznam_besed)
    if n < 100: 
        return 'Besedilo je prekratko za frekvenčno analizo'
    jezik = kateri_jezik(''.join(i for i in seznam_besed))
    if jezik:
        celotna_vsota = sum(len(i) for i in seznam_besed)
        return jezik, celotna_vsota / n
    else: 
        return 'Neznan jezik'

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
KOLOKVIJ 2019/20 (4. termin):
# 1. naloga - Srečne številke
#
# Jure je malo vraževeren in verjame, da se števila delijo na srečna in nesrečna
# števila.  Nesrečna števila so vsa števila, ki so pozitivna, cela in deljiva s
# 13, srečna števila pa so vsa preostala pozitivna cela števila. Pomagaj mu
# rešiti naslednje že znane naloge, le da se tokrat izogibaj nesrečnim številom.
# =====================================================================@022585=
# 1. podnaloga
# Napiši funkcijo `je_srecno(stevilo)`, ki bo kot argument dobila pozitivno celo
# število in vrnila `True`, če je število srečno (če ni deljivo s 13) in `False`
# v primeru, da je nesrečno (deljivo s 13).
# 
# Primer:
# 
#     >>> je_srecno(13)
#     False
# =============================================================================
def je_srecno(stevilo):
    return not (stevilo % 13 == 0)
# =====================================================================@022586=
# 2. podnaloga
# Napiši funkcijo `vsota_srecnih_stevil_do_n(n)`, ki bo kot argument dobila
# pozitivno celo število število `n`, vrnila pa vsoto vseh srečnih števil od `1`
# do vključno `n`.
# 
# Primer:
# 
#     >>> vsota_srecnih_stevil_do_n(12)
#     78
# =============================================================================
def vsota_srecnih_stevil_do_n(n):
    return sum(i for i in range(1, n + 1) if je_srecno(i))
# =====================================================================@022587=
# 3. podnaloga
# Napiši funkcijo `vsota_prvih_n_srecnih_stevil(n)`, ki bo kot argument dobila
# nenegativno število `n`, vrnila pa bo vsoto prvih $n$ srečnih števil.
# 
# Primer:
# 
#     >>> vsota_prvih_n_srecnih_stevil(13)
#     92
# =============================================================================
def vsota_prvih_n_srecnih_stevil(n):
    stevec_srecnih = 0
    stevilo = 1
    vsota = 0
    while stevec_srecnih < n:
        if je_srecno(stevilo):
            vsota += stevilo
            stevec_srecnih += 1
        stevilo += 1
    return vsota


# 2. naloga - Napredno delo s seznami in nizi
#
# Jasmin je bil navdušen nad sklopom "Seznami in nizi". Vseeno pa se mu zdi, da
# se s seznami in nizi da početi še marsikaj drugega, kot to, kar se je počelo v
# nalogah, zato se je odločil in sestavil dodatne naloge. Naloge je poslal
# demonstratorjem, oni pa ne vejo, če so te naloge za študente pretežke.
# Odločili so se, da bodo to preverili tako, da jih bodo dali kot naloge v
# naslednji kolokvij.
# =====================================================================@022673=
# 1. podnaloga
# Sestavi funkcijo `obrni_seznam(seznam)`, ki bo kot argument prejela seznam, vrnila
# pa naokoli obrnjen seznam.
# 
# Primeri:
# 
#     >>> obrni_seznam([1, 2, 3])
#     [3, 2, 1]
#     >>> obrni_seznam([5, 5, 5, 6])
#     [6, 5, 5, 5]
# =============================================================================
def obrni_seznam(s):
    return s[::-1]
# =====================================================================@022674=
# 2. podnaloga
# Sestavi funkcijo `razdeli_na_3_kose(seznam, i, j)`, ki bo prejela seznam in
# indeksa $i$ in $j$ ter vrnila seznam treh seznamov. Prvi seznam bo seznam vseh
# elementov do $i$-tega indeksa, drugi seznam bo imel elemente od $i$-tega pa do
# $j$-tega indeksa, tretji seznam pa bo imel elemente seznama od $j$-tega
# indeksa dalje. Oba indeksa $i$ in $j$ bosta manjša od dolžine seznama. Zgornja
# meja ni vključujoča, torej vsi elementi do $i$-tega indeksa pomenijo vsi
# elementi v seznamu, ki imajo indeks strogo manjši kot $i$.
# 
# Primer:
# 
#     >>> razdeli_na_3_kose([1, 2, 3, 4, 5, 6, 7, 8], 2, 4)
#     [[1, 2], [2, 3], [4, 5, 6, 7, 8]]
#     >>> razdeli_na_3_kose([1, 2, 3, 4, 5, 6, 7, 8], 5, 5)
#     [[1, 2, 3, 4, 5], [], [6, 7, 8]]
# =============================================================================
def razdeli_na_3_kose(seznam, i, j):
    return [seznam[:i], seznam[i:j], seznam[j:]]
# =====================================================================@022675=
# 3. podnaloga
# Sestavi funkcijo `zamenjaj_elementa_v_nizu(niz, i, j)`, ki bo kot argument dobila
# niz in dva indeksa $i$ in $j$ in vrnila nov niz, ki bo enak prvotnemu, le da bo imel
# zamenjana znaka na indeksih $i$ in $j$. Če je kateri izmed indeksov prevelik, naj funkcija
# ne naredi ničesar in samo vrne prvotni niz.
# 
# Primer:
# 
#     >>> zamenjaj_elementa_v_nizu("hello", 0, 4)
#     oellh
#     >>> zamenjaj_elementa_v_nizu("jLubljana", 0, 1)
#     Ljubljana
# =============================================================================
def zamenjaj_elementa_v_nizu(niz, i, j):
    if i >= len(niz) or j >= len(niz):
        return niz

    string_as_list = list(niz)
    string_as_list[i], string_as_list[j] = string_as_list[j], string_as_list[i]
    return "".join(string_as_list)

# 3. naloga - Tekmovanje "Naj Fizik"
#
# Zadnjih nekaj dni je potekalo telefonsko glasovanje za tekmovanje "Naj Fizik".
# Na tekmovanju sodelujejo 4 osebe in sicer Anton, Boštjan, Cvetko in Dunja.
# Vsak študent je lahko oddal glas s tem, da je poklical in povedal za koga
# glasuje. Žal pa tako kot pri vsakem tekmovanju se najdejo nekateri, ki bi radi
# goljufali in pomagali svojemu favoritu. Tvoja naloga je, da pregledaš
# rezultate tekmovanja, izločiš goljufive glasove in ugotoviš kdo dobi naziv
# "Naj Fizik 2019".
# =====================================================================@022604=
# 1. podnaloga
# Goljufi na srečo niso ravno prebrisani in se jih z lahkoto odkrije, saj
# oddajajo glasove z neveljavnih telefonskih številk.  Veljavne telefonske
# številke v Sloveniji so (za nas) vse tiste, ki vsebujejo samo številke, so dolge točno
# `9` znakov in se začnejo z `031`, `041` ali `068`. Prav tako pa ne smejo
# vsebovati dveh zaporednih `9` (torej ne smejo vsebovati podniza `99`).
# 
# Napiši funkcijo `je_veljavna_telefonska_stevilka(stevilka)`, ki bo sprejela
# niz in vrnila `True` v primeru, da je številka veljavna, oziroma `False` v
# primeru da ni.
# 
# Primeri:
# 
#     >>> je_veljavna_telefonska_stevilka("041")
#     False  # vsebuje le 3 znake
#     >>> je_veljavna_telefonska_stevilka("068123456")
#     True  # vse ok
#     >>> je_veljavna_telefonska_stevilka("068129999")
#     False  # vsebuje 99
#     >>> je_veljavna_telefonska_stevilka("012345678")
#     False  # neveljaven začetek
#     >>> je_veljavna_telefonska_stevilka("068xyz1-3")
#     False  # vsebuje druge znake
# =============================================================================
def je_veljavna_telefonska_stevilka(niz):
    if len(niz) != 9:
        return False
    if niz[:3] not in ["068", "031", "041"]:
        return False
    if "99" in niz:
        return False
    for znak in niz:
        if znak not in "0123456789":
            return False
    return True
# =====================================================================@022676=
# 2. podnaloga
# Podatki so podani kot seznam seznamov. Vsak notranji seznam je sestavljen iz dvojice
# `(ime_osebe_za_katero_glasujem, moja_telefonska_stevilka)`.
# 
# Primer vhodnih podatkov:
# 
#     >>> [('Anton', '123456789'), ('Anton', '068068068'), ('Dunja', '041999123')]
# 
# Sestavi funkcijo `prestej_veljavne_glasove(rezultati, tekmovalec)`, ki bo preštela koliko
# `veljavnih` glasov je dobil tekmovalec.
# 
# Primer:
# 
#     >>> prestej_veljavne_glasove([('Anton', '123456789'), ('Anton', '068068068'), ('Dunja', '041999123')], 'Anton')
#     1
#     >>> prestej_veljavne_glasove([('Anton', '123456789'), ('Anton', '068068068'), ('Dunja', '041999123')], 'Dunja')
#     0
# =============================================================================
def prestej_veljavne_glasove(rezultati, tekmovalec):
    stevilo_glasov = 0
    for ime, telefonska_stevilka in rezultati:
        if ime == tekmovalec and je_veljavna_telefonska_stevilka(telefonska_stevilka):
            stevilo_glasov += 1
    return stevilo_glasov
# =====================================================================@022677=
# 3. podnaloga
# Sestavi funkcijo `naj_fizik_2019(rezultati)`, ki bo prejela rezultate in
# vrnila ime tistega tekmovalca, ki je prejel največje število veljavnih glasov.
# V primeru da ima dva tekmovalca enako število veljavnih glasov, naj vrne ime
# tistega katerega ime se začne s črko, ki se v abecedi pojavi prej.
# 
# Primer:
# 
#     >>> naj_fizik_2019([('Anton', '123456789'), ('Anton', '068068068'), ('Dunja', '041999123')])
#     Anton
#     >>> naj_fizik_2019([('Anton', '123456789'), ('Anton', '068abc123'), ('Dunja', '041999123')])
#     Anton
# =============================================================================
def naj_fizik_2019(rezultati):

    trenutni_najboljsi = -1
    ime_zmagovalca = None

    for tekmovalec in ['Anton', 'Boštjan', 'Cvetko', 'Dunja']:
        st_glasov = prestej_veljavne_glasove(rezultati, tekmovalec)
        if st_glasov > trenutni_najboljsi:
            trenutni_najboljsi = st_glasov
            ime_zmagovalca = tekmovalec

    return ime_zmagovalca

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1. IZPIT 2021/2022:
# Mornar Filip
#
# Mornar Filip rad zahaja na kozarec ruma na bližnji otok. Zadnjič pa ga je ob
# vračanju z enega njegovih izletov ujela nevihta, ki mu je močno poškodovala
# barko. Na srečo je opazil, da skozi nastalo luknjo v barki padajo različni
# predmeti.  Kljub rumu je zbral dovolj koncentracije in si v zvezek začel
# pisati koordinate, kjer so določeni predmeti padli z barke. Poleg predmeta si
# je v zvezek napisal tudi vrednost, ki mu določen predmet pomeni.  Pomagaj
# mornarju Filipi rešiti predmete, preden jih odnesejo morski tokovi.
# =====================================================================@030011=
# 1. podnaloga
# Najprej je treba, za boljšo preglednost, sestaviti seznam koordinat, ki
# označujejo mesta predmetov. Napišite funkcijo `koordinate(slovar)`. Sprejme
# naj slovar, ki ima za ključe koordinate in za vrednosti pare (ime, vrednost),
# vrne pa naj seznam koordinat, urejene padajoče po vrednosti predmetov, ki se
# tam nahajajo. V primeru, da ima več predmetov enako vrednost, jih uredite po
# abecednem vrstnem redu po imenih. Predpostavite, da ne moreta biti dva enaka
# predmeta z isto vrednostjo na dveh različnih koordinatah.
# 
# Primer:
# 
#     >>> koordinate({(1, 4) : ("kipec", 14),
#                     (8, 7) : ("zoga", 55),
#                     (3, 1) : ("vrv", 1),
#                     (11, 6) : ("sotor", 27),
#                     (7, 10) : ("abakus", 27),
#                     (5, 3) : ("rum", 78)})
#     [(5, 3), (8, 7), (7, 10), (11, 6), (1, 4), (3, 1)]
# =============================================================================
def koordinate(slovar):
    sez = []
    for (x, y), (ime, vrednost) in slovar.items():
        sez.append((-vrednost, ime, (x, y))) # minus pred vrednostjo, da jih željeno potem uredi
    sez.sort() # sortira seznam po vrednostih
    sez_koordinat = []
    for _, _, (x, y) in sez:
        sez_koordinat.append((x, y))
    return sez_koordinat

# ali krajše
def koordinate(slovar):
    return sorted(slovar.keys(), key=(lambda x: (-slovar[x][1], slovar[x][0])))


# =====================================================================@030012=
# 2. podnaloga
# Sedaj je pa treba te predmete tudi pobrati. Sestavite funkcijo `pot(slovar)`,
# ki bo sprejela enak slovar kot zgoraj, vrne pa skupno dolžino Filipove
# poti, če želi pobrati vse predmete. Njegova pot se začne v domačem
# pristanišču (na koordinatah (0, 0)), gre do najvrednejšega predmeta, nato do
# drugega najvrednejšega in tako dalje, na koncu pa se spet vrne v domače
# pristanišče.
# 
# Razdaljo med dvema točkama izračunamo po običajni formuli:
# 
# razdalja med `(x1, y1)` in `(x2, y2)` je
# enaka `((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5.`
# 
# Primer:
# 
#     >>> pot({(1, 4): ("kipec", 14),
#              (8, 7): ("zoga", 55),
#              (3, 1): ("vrv", 1),
#              (11, 6): ("sotor", 27),
#              (7, 10): ("abakus", 27),
#              (5, 3): ("rum", 78)})
#     36.615951767324
# =============================================================================
def pot(slovar):
    sk_pot = 0
    x1 = 0
    y1 = 0
    koor = koordinate(slovar)
    for (x2, y2) in koor:
        sk_pot += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
        x1 = x2
        y1 = y2
    sk_pot += ((x1 - 0) ** 2 + (y1 - 0) ** 2) ** 0.5
    return sk_pot

# Uradna rešitev:
#def pot(slovar):
    tocke = koordinate(slovar)
    prejsnja = (0, 0)
    dolzina = 0
    for tocka in tocke:
        x1, y1 = prejsnja
        x2, y2 = tocka
        dolzina += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
        prejsnja = tocka

    x1, y1 = tocka
    x2, y2 = (0, 0)
    dolzina += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
    return dolzina

# =====================================================================@030013=
# 3. podnaloga
# Ta naivna pot je že skoraj prava, ampak Filip te predmete pobira s
# prijateljevo barko, ki je manjša od njegove. Zato je prostorsko omejen in se
# mora vmes vračati domov. Napišite funkcijo `pot_omejena(slovar, kapaciteta)`,
# ki sprejme slovar predmetov in največjo kapaciteto barke. Filip bo začel
# svojo pot enako kot prej, le da bo moral, preden bo kapaciteta barke
# presežena, nazaj v domače pristanišče odložit predmete. Vsak predmet ima
# velikost enako dolžini njegovega imena. Na primer, velikost predmeta "sodcek"
# je 6. Predpostavite, da je kapaciteta barke večja od vseh velikosti
# posameznih predmetov.
# 
# Primer:
# 
#     >>> pot_omejena({(1, 4): ("kipec", 14),
#              (8, 7): ("zoga", 55),
#              (3, 1): ("vrv", 1),
#              (11, 6): ("sotor", 27),
#              (7, 10): ("abakus", 27),
#              (5, 3): ("rum", 78)}, 8)
#     85.50490368290278
# =============================================================================
def pot_omejena(slovar, kapaciteta):
    tocke = koordinate(slovar)
    prejsnja = (0, 0)
    dolzina = 0
    zasedenost = 0
    for tocka in tocke:
        velikost = len(slovar[tocka][0])
        if velikost + zasedenost <= kapaciteta:
            x1, y1 = prejsnja
            x2, y2 = tocka
            dolzina += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
            prejsnja = tocka
            zasedenost += velikost
        else:
            x1, y1 = prejsnja
            x2, y2 = (0, 0)
            dolzina += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
            zasedenost = 0

            x1, y1 = (0, 0)
            x2, y2 = tocka
            dolzina += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
            zasedenost += velikost
            prejsnja = tocka


    x1, y1 = tocka
    x2, y2 = (0, 0)
    dolzina += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
    return dolzina


# Druga rešitev:
def pot_omejena(slovar, kapaciteta):
    sez = []
    for (x, y), (ime, vrednost) in slovar.items():
        sez.append((-vrednost, ime, (x, y)))  # sort po vrednosti
    sez.sort()

    sk_pot = 0
    x1, y1 = 0, 0
    tovor = 0

    for _, ime, (x2, y2) in sez:
        velikost = len(ime) # Če ne gre v barko, se vrne domov
        if tovor + velikost > kapaciteta:
            # vračanje domov
            sk_pot += ((x1 - 0)**2 + (y1 - 0)**2)**0.5
            x1, y1 = 0, 0
            tovor = 0

        # gre po predmet
        sk_pot += ((x1 - x2)**2 + (y1 - y2)**2)**0.5
        x1, y1 = x2, y2
        tovor += velikost

    # zadnji povratek domov
    sk_pot += ((x1 - 0)**2 + (y1 - 0)**2)**0.5
    return sk_pot

# Formula E gre visss! - Numpy
#
# Formula E je najprestižnejše tekmovanje dirkalnikov na električni pogon na 
# svetu. Sedaj prosijo vas za pomoč. V zameno za nekaj točk na izpitu jim 
# pomagajte napisati program, ki bo določil razvrstitev dirkalnikov v 
# kvalifikacijskem krogu. Vsak dirkalnik prevozi en tak krog. Dirkalniki 
# imajo vgrajen števec za hitrost, katerega vrednosti si vsako sekundo 
# shranjujemo v tabelo.
# 
# Kot primer tabele hitrosti definirajmo:
# 
#     primer_hitrosti = np.array([[4.11, 52.54, 79.04, 82.01],
#                                 [4.14, 53.41, 81.34, 90.23],
#                                 [5.33, 50.01, 90.81, 92.24]])
# 
# V vsaki vrstici so podatki pripadajoči posameznemu drikalniku, v stolpcih 
# pa so njihove hitrosti ob različnih časovnih intervalih.
# Prva meritev hitrosti je narejena 1s po začetku, vse ostale ji sledijo 
# s časovnimi zamiki 1s. Vse hitrosti so merjene v m/s.
# 
# Za reševanje naloge uporabite knjižnjico numpy, zanke so prepovedane. 
# Če ne gre brez uporabe zank, poskusite nalogo rešiti z uporabo zank,
# saj vam taka rešitev še vedno lahko prinese 1/2 vseh možnih točk.
# 
# Pri nalogi vam bodo v pomoč tudi funkcije na [povezavi](https://numpy.org/doc/stable/reference/routines.sort.html).
# =====================================================================@030017=
# 1. podnaloga
# Najprej moramo iz podatkov o hitrostih dirkalnikov ugotoviti njihovo 
# prevoženo razdaljo ob vsakem času. To naredimo s preprostim "integralom" 
# (dejansko gre za diskretno vsoto), kjer predpostavimo, da je bila hitrost 
# na preteklem intervalu konstantna, prevožena pot na intervalu pa se tako 
# izračuna po enačbi
# 
# $$ s = v \cdot \Delta t $$
# 
# Sestavite funkcijo `prevozena_razdalja(hitrosti)`, ki sprejme tabelo 
# `hitrosti`, ter vrne tabelo prevožene razdalje do vsakega časovnega intervala.
# 
#     >>> prevozena_razdalja(primer_hitrosti)
#     np.array([[4.11, 56.65, 135.69, 217.7 ]
#               [4.14, 57.55, 138.89, 229.12]
#               [5.33, 55.34, 146.15, 238.39]])
# =============================================================================
import numpy as np
def prevozena_razdalja(hitrosti):
    return np.cumsum(hitrosti * np.ones_like(hitrosti), axis=1) # axis=1 pomeni delovanje po vrsticah

# np.ones_like(...): Ustvari novo matriko, ki ima: isto obliko kot hitrosti, vse vrednosti nastavljene na 1

# =====================================================================@030018=
# 2. podnaloga
# Za primerjavo med različnimi načini vožnje skozi ovinke, je zanimivo 
# pogledati, kakšna je bila razvrstitev mest v vsakem trenutku med
# kvalifikacijskim krogom.
# 
# Sestavite funkcijo `trenutni_vodilni(hitrosti)`, ki sprejme tabelo `hitrosti`,
# ter izračuna indeks vodilnega dirkača ob vsakem času. Indekse vrne v 1D tabeli.
# 
#     >>> trenutni_vodilni(primer_hitrosti)
#     np.array([2, 1, 2, 2])
# =============================================================================
import numpy as np
def trenutni_vodilni(hitrosti):
    razdalje = prevozena_razdalja(hitrosti)
    max_razd = np.max(razdalje, axis=0)
    max_razdalje = np.ones(razdalje.shape) * max_razd
    return (razdalje == max_razdalje).argmax(axis=0)

# Z zanko:
def trenutni_vodilni(hitrosti):
    razdalje = prevozena_razdalja(hitrosti)
    vodilni = []
    
    for t in range(razdalje.shape[1]):  # greš čez vsak časovni trenutek (stolpce)
        max_razdalja = -1
        index_vodilnega = -1
        for i in range(razdalje.shape[0]):  # greš čez vsakega dirkalnika (vrstico)
            if razdalje[i, t] > max_razdalja:
                max_razdalja = razdalje[i, t]
                index_vodilnega = i
        vodilni.append(index_vodilnega)

    return np.array(vodilni)



# =====================================================================@030019=
# 3. podnaloga
# Seveda pa organizatorje najbolj zanima končna razporeditev dirkalnikov 
# od najhitrejšega do najpočasnejšega. Dirkalnikov čas je merjen od začetka 
# tabele, pa do časovnega intervala, pri katerem doseže ali pa preseže 
# dolžino kroga. V nalogi lahko privzamete, da nobena dva dirkalnika cilja 
# ne dosežeta ob istem času. Števec hitrosti preneha beležiti hitrosti 
# šele, ko se dirkalnik pripelje nazaj v bokse, zato konec dirke nikoli 
# ni na koncu tabele, ampak že nekje vmes.
# 
# Sestavite funkcijo `koncna_razporeditev(hitrosti, dolzina_proge)`, ki 
# sprejme tabelo `hitrosti` in `dolzina_proge` v metrih, ter vrne 2D 
# tabelo, kjer so v prvem stolpcu zapisani indeksi dirkalnikov od 
# najhitrejšega do napočasnejšega, v drugem stolpcu pa so zapisani 
# njihovi časi v sekundah.
# 
#     >>> koncna_razporeditev(primer_hitrosti, 137)
#     np.array([[1, 3]
#               [2, 3]
#               [0, 4]])
# 
# Namig: Prav vam lahko pride numpy funkcija po imenu `argsort()`.
# =============================================================================
import numpy as np
def koncna_razporeditev(hitrosti, dolzina_proge):
    razdalje = prevozena_razdalja(hitrosti)
    finish_casi = np.argmin(razdalje < dolzina_proge, axis=1) + 1
    sorting_order = np.argsort(finish_casi)
    sorted_idxs = np.arange(hitrosti.shape[0])[sorting_order]
    sorted_casi = finish_casi[sorting_order]
    return np.array([sorted_idxs, sorted_casi]).T


# Izpiti
#
# Svetovno znani profesor Leopold Poldi je tako pameten gospod, da se mu vse
# naloge na izpitih zdijo trivialne. Raziskave pa so pokazale, da je smiselno
# naloge na izpitu razvrstiti po težavnosti. Ker on ne ve, kaj je težko,
# potrebuje vašo pomoč (očitno le ne zna vsega ;) ).
# 
# *OPOMBA*: Pri nalogah uporabljaj kodiranje "utf-8".
# =====================================================================@030014=
# 1. podnaloga
# Vaša prva naloga je, da iz besedila naloge odstranite vse matematične/fizikalne
# formule in izraze. Vsaka formula se začne z znakom `$` in konča z znakom `$`.
# Predpostavite lahko, da pred znakom `$` ni nikoli presledka.
# 
# Primer naloge:
# 
#       .)1.) Določi nihajni čas matematičnega nihala z maso$m = 10g$, ki visi
#       na vrvici dolžine$10cm$.
# 
# Napišite funkcijo `odstrani_formule(naloga)`, ki iz naloge `naloga` odstrani
# vse formule in vrne novo besedilo naloge v eni vrstici (brez znakov za 
# novo vrstico `\n`), torej `\n` zamenjaj s `" "`. Po klicu funkcije na zgornji 
# nalogi, naša funkcija torej vrne:
# 
#       .)1.) Določi nihajni čas matematičnega nihala z maso, ki visi na vrvici dolžine.
# =============================================================================
def odstrani_formule(naloga):
    nal = ""
    v_formuli = False # stikalo
    for znak in naloga.replace("\n", " "): # zamenja \n
        if znak == "$":
            v_formuli = not v_formuli
        elif not v_formuli:
            nal += znak
    return nal


# =====================================================================@030015=
# 2. podnaloga
# Leopold ima naloge shranjene v tekstovni datoteki `ZAUPNO.txt`, ki zgleda
# takole:
# 
#       .)1.) Izračunaj nihajni čas matematičnega nihala z maso$m = 10g$, ki visi
#       na vrvici dolžine$10cm$.
#       .)*2.) Dokaži, da barvo krave, če je glasnost njenega zvonca izračunana
#       po formuli$c = \pi * 9 - 6 \psi^2$, izračunamo kot$a^2 + b^2 = c^2$.
#       .)3.) Izračunaj današnji datum v Inkovskem koledarskem načinu.
#       .)*4.) Pokaži, da si je besedilo naslednje naloge težko izmisliti na$3$
#       decimalke natančno.
#       .)5.) Pokaži, da mi je ime$Leopold Poldi$.
# 
# Sestavite funkcijo `loci_po_nalogah(vhodna)`, ki sprejme ime vhodne datoteke
# in vrne seznam nalog, ki ne vsebujejo več formul (namesto `\n`, pa vsebuje `" "`). 
# Klic funkcije naj torej na datoteki `vhodna = "ZAUPNO.txt"` vrne naslednji seznam:
# 
#       ['.)1.) Izračunaj nihajni čas matematičnega nihala z maso, ki visi na vrvici dolžine.',
#       '.)*2.) Dokaži, da barvo krave, če je glasnost njenega zvonca izračunana po formuli, izračunamo kot.',
#       '.)3.) Izračunaj današnji datum v Inkovskem koledarskem načinu.',
#       '.)*4.) Pokaži, da si je besedilo naslednje naloge težko izmisliti na decimalke natančno.',
#       '.)5.) Pokaži, da mi je ime.']
# 
# Predpostavite, da se nikjer v besedilu, razen pred in za zaporedno številko naloge, ne pojavi `.)`.
# =============================================================================
def loci_po_nalogah(vhodna):
    with open(vhodna, "r", encoding="utf-8") as f:
        naloge = f.read().split(".)")
        loceno = []
        for i in range(1, len(naloge), 2): # skače za 2, ker jesepariral še številke, mi pa potrebujemo text
            loceno.append((".)" + naloge[i] + ".)" + odstrani_formule(naloge[i + 1])).strip())
    return loceno


# =====================================================================@030016=
# 3. podnaloga
# Za konec je vaša naloga, da uredite naloge po težavnosti. Težavnost naloge
# določamo na treh nivojih. Najprej najtežje naloge pred zaporedno številko
# naloge vsebujejo `*`, potem se težavnost določa na podlagi besed, ki jih
# naloga vsebuje. Če navodilo naloge vsebuje besedo `dokazi`, je naloga težja,
# kot če vsebuje besedo `pokazi`, najlažja pa je naloga, ki ne vsebuje nobene 
# od teh besed.
# Predpostavite, da ti besedi upoštevamo samo v imenovalniku (nominativu),
# torej le dobesedno tako, kot sta napisani v navodilu te naloge (lahko spreminjamo
# le velike in male črke), nadalje gledamo zaporedno številko naloge (večja številka, 
# težja naloga). 
# Ni nujno, da naloga vsebuje besede "dokazi" ali "pokazi", nobena naloga pa ne
# vsebuje več teh besed.
# 
# Napišite funkcijo `uredi_po_tezavnosti(vhodna, izhodna)`, ki sprejme vhodno datoteko
# v taki obliki, kot je napisano zgoraj (v daoteki `ZAUPNO.txt`) in v izhodno
# datoteko `izhodna` zapiše zaporedne številke nalog, vsako v svojo vrstico, od
# najlažje do najtežje.
# 
# Po klicu `uredi_po_tezavnosti("ZAUPNO.txt", "test.txt")` se torej v datoteki
# `test.txt` nahaja:
# 
#     1
#     3
#     5
#     4
#     2
# 
# 
# namig: Vsaki od besed, ki določa težavnost, priredite ustrezno številko in
# si v slovar za vsako nalogo zabeležite, katero od besed vsebuje.
# =============================================================================
def uredi_po_tezavnosti(vhodna, izhodna):
    naloge = loci_po_nalogah(vhodna)
    tezavnost = {}
    for nal in naloge:
        teza = 0
        if "dokazi" in nal.lower():
            teza = 2
        elif "pokazi" in nal.lower():
            teza = 1
        _, st, _ = nal.split(".)")
        tezavnost[st] = (st.startswith("*"), teza, int(st.strip("*")))
    naloge = [(v, k) for k, v in tezavnost.items()]
    naloge.sort()
    with open(izhodna, "w", encoding="utf-8") as f:
        for _, nal in naloge:
            print(nal.strip("*"), file=f)

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2. IZPIT 2021/2022:
# Beleženje prisotnosti
#
# V današnjem času je pomembno, da beležimo, kdo hodi na predavanja, saj se je 
# pokazalo, da to vpliva na znanje. Tvoja naloga je, da sestaviš nekaj funkcij,
# ki bodo pri tem pomagale.
# =====================================================================@030020=
# 1. podnaloga
# Dan je seznam seznamov, ki vsebuje imena študentov, ki so bili na določen dan
# prisotni na predavanjih.
# 
#     prisotnost = [
#         ["Ana", "Metka", "Janez", "Luka"],
#         ["Ana", "Bernard", "Jaka", "Mojca", "Ferdi"],
#         ["Lan", "Tia", "Jerca", "Luka"]
#     ]
# 
# V seznamu `prisotnost` torej pomeni, da so na dan 1 pri predavanjih bili prisotni
# Ana, Metka, Janez in Luka. Žal pa po več dneh seznam postane predolg in ni
# pregleden. Napiši funkcijo `pregledni_zapis(seznam)`, ki sprejme seznam seznamov
# (tak kot je seznam `prisotnost`) in vrne slovar, kjer so ključi zaporedni dnevi,
# vrednosti pa so seznami prisotnih ljudi.
# 
# Primer:
# 
#     >>>pregledni_zapis(prisotnost)
#     {"dan 1": ["Ana", "Metka", "Janez", "Luka"],
#     "dan 2": ["Ana", "Bernard", "Jaka", "Mojca", "Ferdi"],
#     "dan 3":["Lan", "Tia", "Jerca", "Luka"]}
# =============================================================================
def pregledni_zapis(seznam):
    slovar = {}
    dan = 1
    for imena in seznam:
        naslov = 'dan ' + str(dan)
        slovar [naslov] = imena
        dan += 1
    return slovar


# Uradna rešitev:
#def pregledni_zapis(sez):
    slovar = {}
    for i, s in enumerate(sez):
        slovar[f"dan {i + 1}"] = s
    return slovar

# =====================================================================@030021=
# 2. podnaloga
# Profesorji pa so začeli prisotnost na predavanjih upoštevati tudi pri oceni,
# zato jih zanima, kdo je bil kolikokrat prisoten na faksu. Napiši funkcijo
# `vsi_prisotni(seznam)`, ki sprejme seznam seznamov in vrne
# množico parov vseh študentov, ki so bili kadarkoli na predavanjih. Prvi
# element para naj bo ime študenta, drugi pa število obiskanih predavanj.
# 
# Primer:
# 
#     >>>vsi_prisotni([["Ana", "Metka", "Luka", "Janez", "Bernard", "Jaka", "Ferdi"], ["Ana", "Metka", "Luka", "Janez", "Bernard", "Jerca"]])
#     {("Ana", 2), ("Metka", 2), ("Janez", 2), ("Luka", 2), ("Bernard", 2), ("Jaka", 1), ("Ferdi", 1), ("Jerca", 1)}
# =============================================================================
def vsi_prisotni(seznam):
    prisotni = set()
    slo = {}
    for sez in seznam:
        for ime in sez:
            if ime in slo.keys():
                slo[ime] += 1
            else:
                slo[ime] = 1

    for ime, stevilo in slo.items():
        prisotni.add((ime, stevilo)) # ker zapisujemo v množico, .add
    return prisotni


# Uradna rešitev:
#def vsi_prisotni(sez):
    sl = {}
    for pod_sez in sez:
        for oseba in pod_sez:
            sl[oseba] = sl.get(oseba, 0) + 1 # preveri, če je oseba v slovarju ji zapiše vrednost
    return set(sl.items()) # zapiše vsak entry kot par


# =====================================================================@030022=
# 3. podnaloga
# Napiši funkcijo `prvak_prisotnosti(seznam)`, ki sprejme seznam seznamov,
# takega kot je seznam `prisotnost` in vrne množico študentov, ki so prvaki 
# v prisotnosti. Študent je prvak v prisotnosti, če je bil med najbolj neobiskanimi
# dnevi prisoten največkrat. Predpostaviš lahko, da imamo podatke o prisotnosti 
# za vsaj en dan.
# 
# Primer:
# 
#     >>> prvak_prisotnosti([["Ana", "Metka", "Janez"],["Ana", "Janez"],["Ana", "Metka"]])
#     {'Ana'}
#     >>> prvak_prisotnosti([["Ana", "Metka", "Janez"],["Janez"],["Ana", "Metka"],["Cene"]])
#     {'Janez', 'Cene'}
# 
# *Razlaga*: v prvem primeru je prvak v prisotnosti Ana, saj je bilo najmanj obiska 
# na dan 2 in dan 3, kjer je bila Ana prisotna dvakrat.
# 
# V drugem primeru sta prvaka Janez  in Cene, saj je bila najmanjša prisotnost 
# na dan 2 in dan 4, kjer sta bila Janez in Cene prisotna po enkrat.
# 
# Namig: Najprej izlušči dneve z najmanjšo prisotnostjo, nato pa si pomagaj 
# s funkcijo `vsi_prisotni`.
# =============================================================================
def prvak_prisotnosti(seznam):
    # Najdi najmanjši obisk
    min_obisk = len(seznam[0])
    for sez in seznam:
        if len(sez) < min_obisk:
            min_obisk = len(sez)

    # Izberi vse dneve z najmanjšim obiskom
    min_dan = []
    for dan in seznam:
        if len(dan) == min_obisk:
            min_dan.append(dan)

    # Zgradi slovar prisotnosti (zmanjšujemo, da bo najbolj prisoten najbolj negativen)
    sl = {}
    for pod_sez in min_dan:
        for oseba in pod_sez:
            sl[oseba] = sl.get(oseba, 0) - 1

    # Najdi najmanjšo vrednost (največkrat prisoten)
    naj = min(sl.values())

    # Zberi vsa imena z enako minimalno vrednostjo
    imena = set()
    for pridni in sl:
        if sl[pridni] == naj:
            imena.add(pridni)  # dodaš v izhodni slovar

    return imena


# Uradna rešitev:
# def prvak_prisotnosti(sez):
    l = len(min(sez, key=len))
    najmanj_obiskani_dnevi = []
    for dan in sez:
        if len(dan) == l:
            najmanj_obiskani_dnevi.append(dan)   
    kolikokrat_prisotni = vsi_prisotni(najmanj_obiskani_dnevi)
    najvec = max(kolikokrat_prisotni, key=lambda x : x[1])[1]
    prvaki = set()
    for oseba, kolikokrat in kolikokrat_prisotni:
        if kolikokrat == najvec:
            prvaki.add(oseba)
    return prvaki

# Ali brez "key"

#def prvak_prisotnosti(sez):
    l = len(sez[0])
    najmanj_obiskani_dnevi = []
    for dan in sez:
        if len(dan) < l:
            l = len(dan)
            najmanj_obiskani_dnevi = []    
        if len(dan) == l:
            najmanj_obiskani_dnevi.append(dan)   
    kolikokrat_prisotni = vsi_prisotni(najmanj_obiskani_dnevi)
    najvec = 0
    prvaki = set()
    for oseba, kolikokrat in kolikokrat_prisotni:
        if kolikokrat > najvec:
            najvec = kolikokrat
            prvaki = set()
        if najvec == kolikokrat:
            prvaki.add(oseba)
    return prvaki

# Vremenska postaja
#
# Nadebudnega študenta Teota, so že v osnovni šoli zanimali računalniki, zato si je doma postavil vremensko postajo, ki
# vsake toliko časa beleži nekaj različnih izmerkov. V srednji šoli je Teo pošteno zabušil, sedaj
# pa je ugotovil, da ima zbrano goro neobdelanih podatkov. Prosi te, da mu pomagaš obdelati to gmoto podatkov.
# 
# Podatki so v vhodni datoteki razvrščeni po naraščujočem času, v vsaki vrstici pa se nahaja en izmerek v obliki:
# `predpona vrednost leto-mesec-dan ura-minuta-sekunda`
# 
# Predpona "WX-T" označuje meritev temperature, obstajajo pa tudi ostale predpone, ki nas pri nalogi ne bodo zanimale.
# 
# Primer datoteke short_sample.txt:
# 
#     WX-T 18.33 2019-06-23 23-00-05
#     WX-T 26.8 2019-06-24 16-30-10
#     WX-H 51.58 2019-06-24 17-45-04
#     WX-Pasl 10196.66 2019-06-24 17-45-04
#     WX-T 26.42 2019-06-24 17-45-04
#     WX-Tdp 15.75 2019-06-24 17-45-04
#     WX-D 1.11 2019-06-24 18-10-04
#     WX-T 26.0 2019-06-24 19-00-10
#     WX-T 14.5 2020-04-23 19-30-04
# =====================================================================@030023=
# 1. podnaloga
# Najprej nas zanima vsaka meritev temperature.
# 
# Sestavi funkcijo `temperature(vhodna)`, ki iz datoteke po imenu `vhodna` prebere
# vse meritve temperature in jih vrne zapisane v seznamu v enakem vrstem redu.
# 
#     >>> temperature("short_sample.txt")
#     [18.33, 26.8, 26.42, 26.0, 14.5]
# =============================================================================
def temperature(vhodna): 
    niz = []   
    with open(vhodna, 'r') as doc:
        for vrstica in doc.readlines(): # readline - ena vrstica; readlines() - več jih prebere
            novo = vrstica.split(' ') 
            if novo[0] == 'WX-T':
                niz.append(float(novo[1])) # floar se zneli ''
    return niz

# Uradna rešitev:
#def temperature(vhodna):
    temps = []
    with open(vhodna, "r") as f:
        for line in f.readlines():
            parts = line.split(" ")
            if parts[0] == "WX-T":
                temps.append(float(parts[1]))

    return temps

# =====================================================================@030024=
# 2. podnaloga
# Teo je seveda zadovoljen s tvojim delom, a ga podrobni podatki od leta 2014 res ne zanimajo tako zelo.
# 
# Zapiši funkcijo `temperature_med_datumi(vhodna, zacetni, koncni)`, ki sprejme ime vhodne datoteke `vhodna`, ter `zacetni` in `koncni`
# datum zapisana v obliki (leto, mesec, dan). Vrne naj vse izmerjene temperature za datume med vključno začetnim in vključno
# končnim datumom.
# 
#     >>> temperature_med_datumi("short_sample.txt", (2019, 6, 23), (2019, 7, 30))
#     [18.33, 26.8, 26.42, 26.0]
# =============================================================================
def temperature_med_datumi(vhodna, zacetni, koncni):
    niz = []  
    with open(vhodna, 'r') as doc:
        for vrstica in doc.readlines(): # readline - ena vrstica; readlines() - več jih prebere
            novo = vrstica.split(' ')
            datum = tuple(int(i) for i in novo[2].split('-')) # primerjamo vrednosti, kar v oklepajih, int - potrebujemo številke
            if novo[0] == 'WX-T':
                if  zacetni <= datum and koncni >= datum:
                    niz.append(float(novo[1])) # floar se zneli ''
    return niz

# =====================================================================@030025=
# 3. podnaloga
# Kljub temu, da si naš dragi Teo želi postati fizik, pa dvomi v globalno segrevanje. Na srečo imaš dostop do podatkov, ki mu
# lahko spremenijo pogled na celotno stvar, a jih je potrebno najprej filtrirati.
# 
# Zapiši funkcijo `povprecne_mesecne_temperature(vhodna, izhodna)`, ki sprejme imeni datotek `vhodna` in `izhodna`. V vhodni datoteki se kot prej
# nahajajo vremenski podatki, funkcija pa naj v izhodno datotko izpiše povprečne mesečne temperature za vsak mesec med vključno 
# letom 2015 in letom 2020 (od začetka 2015 do konca 2020). Temperature naj bodo v izhodno datoteko zapisane vedno z dvema
# decimalnima mestoma natančnosti (3.10 in ne 3.1), vsaka povprečna temepratura pa naj bo zapisana v svojo novo vrstico.
# V prvi vrstici naj se nahaja povprečna temperatura Januraja 2015, v drugi Februarja 2015, itd..
# Če za kakšen mesec ni podatkov, zapiši za tisti mesec vrednost -300.00,
# sicer pa povpreči podatke ki so za tisti mesec na voljo. Pri reševanju ti lahko pride prav funkcija iz prejšnje podnaloge.
# =============================================================================
def povprecne_mesecne_temperature(vhodna, izhodna):
    with open(izhodna, "w") as f: # pišemo v novo datoteko
        for leto in range(2015, 2021): # gledamo samo ta leta
            for mesec in range(1, 13):
                zacetek = (leto, mesec, 1) # nastavimo parametre
                konec = (leto, mesec, 31)
                T = temperature_med_datumi(vhodna, zacetek, konec) # iz prejšnjih nastavkov parametrov, uporabimo prekjšnjo funkcijo
                if len(T) > 0:
                    povp = sum(T) / len(T) # sum - sešteje vse
                else:
                    povp = -300
                print(f"{povp:.2f}", file=f) # {povp:.2f} - zapiše na dve decimalni mesti

# Korona bus
#
# Vsem je dobro znano, da se fiziki zelo bojijo okužbe s korona virusom, zato
# ste se odločili, da si napišete nekaj funkcij, ki vam bodo pomagale ugotoviti
# kakšne so možnosti za okužbo.
# 
# *OPOMBA*: Pri tej nalogi je uporaba zank prepovedana. Če uporabljate zanke,
# lahko dosežete kvečjemu tretjino vseh možnih točk.
# =====================================================================@030026=
# 1. podnaloga
# Napiši funkcijo `koliko_mimo(arr, i)`, ki sprejme zasedenost sedežev v
# avtobusu, tj. enodimenzionalen numpy arrayu `arr`, ki vsebuje vrednosti
# `True`, če je sedež zaseden in `False`, če je sedež prost ter `i`, ki
# predstavlja mesto, na katerega želimo sesti (štetje začnemo z vrsto 0).
# Funkcija naj vrne vsoto, mimo koliko potnikov smo morali iti in koliko
# potnikov bo šlo mimo nas, če se avtobus zapolni tj. v arrayu so na koncu
# vse vrednosti `True`. Če je naš izbrani sedež že zaseden, naj funkcija
# vrne `-1`.
# 
# Primer:
# 
#     >>> koliko_mimo(np.array([False, False, False, False, False]), 4)
#     0
#     >>> koliko_mimo(np.array([False, True, False, False,  True,  True]), 2)
#     2
#     >>> koliko_mimo(np.array([False, False, False, False,  True,  True]), 4)
#     -1
# =============================================================================
import numpy as np
def koliko_mimo(arr, i):
    if not arr[i]: # preverimo ali je sedež prost - torej False
        return np.sum(arr[:i]) + (len(arr) - i - 1 - np.sum(arr[i + 1:])) # zamimajo nas False sedeži za nami
                                # len(arr) - i - 1 → število vseh sedežev za tabo; np.sum(arr[i+1:]) → kolikšnih od teh je že zasedenih 
                                # torej: koliko jih bo še zasedenih v prihodnosti, če se avtobus popolnoma napolni
    else:
        return -1


# =====================================================================@030027=
# 2. podnaloga
# Seveda pa avtobusi nimajo v vrsti le enega sedeža, pač pa imajo lahko tudi
# več sedežev. Posploši prejšnjo funkcijo in napiši funkcijo
# `koliko_mimo_n(arr, i)`, ki sprejme zasedenost sedežev v
# avtobusu, tj. dvodimenzionalen numpy array `arr`, ki vsebuje vrednosti
# `True`, če je sedež zaseden in `False`, če je sedež prost ter `i`,
# ki predstavlja vrsto v katero želimo sesti. Prva vrstica v arrayu 
# predstavlja prvo vrsto v avtobusu. Funkcija naj vrne vsoto,
# mimo koliko potnikov smo morali iti in koliko potnikov bo šlo mimo nas,
# če se avtobus zapolni. Če v naši izbrani vrsti ni prostega sedeža, naj
# funkcija vrne `-1`.
# 
# *Pozor*: ne pozabi tistih, ki že sedijo v naši izbrani vrsti oz. se bodo
# tja še usedli.
# 
# Primer:
# 
#     >>> koliko_mimo_n(np.array([
#                           [False  True]
#                           [False False]
#                           [ True False]
#                           [False False]
#                           [ True False]
#                               ]), 3)
#     4
# =============================================================================
import numpy as np
def koliko_mimo_n(arr, i):
    n = len(arr[0]) # število sedežev v vrstici
    arr = np.sum(arr, axis=1) # arr iz 2D tabele v 1D array, kjer vsaka vrednost pomeni: prešteje folk v eni vrstici (kot bi imeli en podatek)
    if arr[i] < n: # i ni še vse zasedeno
        return np.sum(arr[:i]) + (n * (len(arr) - i - 1) - np.sum(arr[i + 1:])) + n - 1
    return -1


# =====================================================================@030028=
# 3. podnaloga
# Tveganje, ki ga predstavlja vožnja z avtobusom, je odvisno od tega, koliko
# ljudi je na avtobusu in kako daleč stran od nas sedijo. Strokovnjaki so
# izračunali, da je formula, po kateri se računa stopnjo nevarnosti enaka
# $$ \text{nevarnost}(t, a) = \frac{e}{S\cdot\pi} \cdot t \cdot \sum_p d(a, p), $$
# Kjer je $S$ število sedežev v avtobusu, $d(a, p)$ je razdalja med
# potnikoma $p$ in $a$ ($d(a, p) = \sqrt{(a[0] - p[0]) ^2 + (a[1] - p[1]) ^2}$)
# število `e` pa je Eulerjeva konstanta.
# 
# Napišite funkcijo `analiza(t, delta_t, avtobus, a, kriticna_vr)`, ki sprejme
# čas `t`, ki pove, ob katerem času prispemo na želeno postajo, `delta_t`, ki
# predstavlja čas med vsakima zaporednima postajama (med vsakima dvema postajama
# preteče torej `delta_t` časa), `avtobus`, ki je kot prej dvodimenzionalni numpy
# array, ki vsebuje `True`, če je sedež zaseden in `False`, če je sedež prazen,
# `a` je urejeni par indeksov kjer sedimo, `kriticna_vr` pa predstavlja najmanjšo
# vrednost, pri kateri zapustimo avtobus, tudi če še nismo na cilju. Funkcija
# naj vrne čas ob katerem izstopimo. Če prej pridemo na cilj (tj. nikoli do časa
# `t` nismo presegli kritične vrednosti), naj funkcija
# vrne neskončno.
# 
#     A = np.array([
#       [True, True,  True],
#       [False, False, True],
#       [True,  False, True]
#       ])
#     >>> analiza(10, 0.24, A, (1, 2), 3)
#     4.08
#     >>> analiza(10, 0.396, A, (0, 0), 7)
#     7.524
# =============================================================================
# Uradna rešitev:
import numpy as np
def analiza(t, delta_t, avtobus, a, kriticna_vr):
    cas = np.arange(0, t + delta_t, delta_t)
    nevarnosti = np.fromfunction(lambda i, j: np.sqrt((i - a[0]) ** 2 + (j - a[1]) ** 2), np.shape(avtobus)) * avtobus
    tveganje = np.e / (np.pi * np.size(avtobus)) * np.sum(nevarnosti) * cas
    indeksi = np.flatnonzero(tveganje >= kriticna_vr)
    if np.size(indeksi):
        return indeksi[0] * delta_t
    return np.inf


# ALI
def analiza(t, delta_t, avtobus, a, kriticna_vr):
    inds = np.indices(avtobus.shape)
    polozaji_oseb = np.where(avtobus != 0)
    pxs = inds[0][polozaji_oseb]
    pys = inds[1][polozaji_oseb]
    sum_of_distances = np.sum(np.sqrt(np.square(a[0] - pxs) + np.square(a[1] - pys)))
    nevarnosti = np.e / (np.pi * np.size(avtobus)) * np.arange(0, t + delta_t, delta_t) * sum_of_distances
    kje_izstop = np.flatnonzero(nevarnosti >= kriticna_vr)
    if np.size(kje_izstop) == 0:
        return np.inf
    else:
        return kje_izstop[0]*delta_t

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3. IZPIT 2021/2022:
# Kolesarjenje je kul!
#
# Športna fizičarka Manca je letos ponosno gledala naše kolesarje. To jo je 
# tako navdušilo, da se želi v šport pognati tudi sama, vendar pa nima kolesa. 
# Iz seznama koles in njihovih lastnosti, ji pomagaj izbrati najboljše kolo za njo!
# Dvodimenzionalni seznam koles, ki ga je sestavila z izčrpnim iskanjem po 
# internetu, je oblike
# 
#     seznam_koles = [["Huffy", 500, 19.4, 0.45],
#                     ["Hiland", 360, 16.2, 0.40],
#                     ["AVASTA", 275, 12.7, 0.44]]
# 
# kjer vrstice predstavljajo različna kolesa v stolpcih pa so podatki o: 
# ime kolesa, cena, masa, koeficient zračnega upora * površina
# =====================================================================@030029=
# 1. podnaloga
# Manca je ugotovila, da je po seznamu težko iskati. Sestavi funkcijo 
# `slovar_koles(seznam)`, ki sprejme `seznam` koles, vrne pa slovar 
# slovarjev koles. V vrnjenem slovarju predstavljajo imena koles ključe, 
# vrednosti pa so slovarji, v katerih so shranjene lastnosti kolesa. 
# Če kot primer uporabimo zgoraj definirani `seznam_koles`, dobimo:
# 
#     >>> slovar_koles(seznam_koles)
#     {'Huffy': {'m': 19.4, 'cA': 0.45, 'cena': 500}, 'Hiland': {'m': 16.2, 'cA': 0.4, 'cena': 360}, 'AVASTA': {'m': 12.7, 'cA': 0.44, 'cena': 275}}
# 
# Za lažje razumevanje prihodnjih nalog definiramo primer slovarja koles
# 
#     slovar_k = slovar_koles(seznam_koles)
# =============================================================================
def slovar_koles(seznam):
    return {el[0]: {"m": el[2], "cA": el[3], "cena": el[1]} for el in seznam}
# =====================================================================@030030=
# 2. podnaloga
# Sedaj je Manca ugotovila, da bo zaradi dragih inštrukcij morala zmanjšati denar
# ki je bil namenjen za kolo. Prav tako je ob ponovnem pogledu na spletno stran 
# ugotovila, da nekaterih koles ni več na zalogi.
# 
# Napiši funkcijo `cenovno_sprejemljivi(slovar, max_cena, stock)`, ki prejme 
# `slovar` slovarjev koles (kakršnega vrača funkcija `slovar_koles`), najvišjo 
# sprejemljivo ceno `max_cena`, ter seznam imen koles `stock`, ki so še na zalogi. 
# Funkcija naj vrne množico (set) imen koles, ki so hkrati na zalogi in je 
# njihova cena nižja ali enaka najvišji sprejemljivi ceni.
# 
# Za primer uporabimo `seznam_k` definiran zgoraj.
# 
#     >>> cenovno_sprejemljivi(slovar_k, 450, ["Huffy", "AVASTA"])
#     {'AVASTA'}
#     >>> cenovno_sprejemljivi(slovar_k, 450, ["Huffy", "AVASTA", "Hiland"])
#     {'AVASTA', 'Hiland'}
# =============================================================================
def cenovno_sprejemljivi(slovar, max_cena, stock):
    razvrsceni = []
    for kolo, stats in slovar.items():
        if stats["cena"] <= max_cena and kolo in stock:
            razvrsceni.append(kolo)
    return set(razvrsceni)
# =====================================================================@030031=
# 3. podnaloga
# Manco pri kolesarjenju najbolj navduši cestno kolesarjenje v hrib, 
# zato bo svoje novo kolo izbrala za najhitrejšo vožnjo v hrib.
# Glede na svoje fizične lastnosti in moč je napisala enačbo za 
# izračun povprečne hitrosti v hrib
# $$ v = 3.6 \sqrt{\frac{1}{cA} \left( 80 - 0.1 \cdot 9.8 \cdot (m + 60) \right)} $$
# 
# kjer je $cA$ koeficient zračnega upora * površina, $m$ pa masa kolesa.
# 
# Napiši funkcijo `najhitrejse_v_klanec(slovar, max_cena, stock)`, ki 
# sprejme `slovar` slovarjev koles, najvišjo sprejemljivo ceno `max_cena`
# in seznam koles `stock` na zalogi. Funkcija naj vrne seznam naborov, 
# kjer je prvi element nabora ime kolesa, drugi njegova hitrost v klanec 
# in tretji cena. Vrne naj le nabore za kolesa, ki so na zalogi in so 
# cenovno sprejemljivi. Nabori koles naj bodo razvrščeni od najhitrejšega 
# do najpočasnejšega.
# 
# Za primer uporabimo `slovar_k` definiran zgoraj.
#  
#     >>> najhitrejse_v_klanec(slovar_k, 450, ["Huffy", "AVASTA", "Hiland"])
#     [('AVASTA', 16.057555570792545, 275), ('Hiland', 13.133834169807363, 360)]
# =============================================================================
import math as m

def najhitrejse_v_klanec(slovar, max_cena, stock):
    cenovno_ugodna = cenovno_sprejemljivi(slovar, max_cena, stock)
    seznam = []
    for kolo in cenovno_ugodna:
        hitrost = 3.6 * m.sqrt(1/slovar[kolo]["cA"] * (80 - 0.1*9.8*(60 + slovar[kolo]["m"])))
        seznam.append((kolo, hitrost, slovar[kolo]["cena"]))

    koncna_razvrstitev = sorted(seznam, key= lambda el: (-el[1], el[2]))

    return koncna_razvrstitev

# Sončev mrk
#
# Fizičarko Laro zanima, kdaj se bodo v naslednjih letih zgodili Sončevi mrki,
# da bi jih opazovala.
# Ker je na samotnem otoku brez interneta in astronomskih knjig, se je odločila, 
# da bo čas mrkov izračunala sama. Po astronomskem naključju ima na računalniku 
# dve datoteki, v katerih so zapisane lege Zemlje in Lune za naslednjih nekaj 
# let, ki jih je izračunala NASA. 
# Iz leg lahko Lara izračuna kote med telesi in iz tega kdaj bo Luna prekrila Sonce.
# 
# Pri teh podatkih je koordinatni sistem kartezičen ($x$, $y$, $z$) in 
# postavljen v središče Sonca ter se s časom ne spreminja. Smer osi 
# koordinatnega sistema za izračune ni pomembna. Koordinate predstavljajo 
# lego središč teles.
#  
# Za reševanje naloge uporabi paket numpy.
# Uporaba zank je dovoljena le pri prvi podnalogi, pri drugi in tretji pa je 
# prepovedana! Če pri teh dveh podnalogah uporabljate zanke, lahko dosežete 
# kvečjemu polovico vseh možnih točk.
# =====================================================================@030032=
# 1. podnaloga
# Lara potrebuje tvojo pomoč, da prebere vsebino datotek z legami Zemlje in 
# Lune, da bo lahko z njimi računala. Spodaj je prvih nekaj vrstic datoteke s 
# koordinatami Lune. Datoteka s koordinatami Zemlje ima enako strukturo.
# 
#      2023-Jan-01-00:00:00.0000 -25129553.45596025 145099502.5166023 -12274.15376421064
#      2023-Jan-01-00:15:00.0000 -25156842.40849337 145095529.9104352 -12195.75662122667
#      2023-Jan-01-00:30:00.0000 -25184132.29065364 145091551.2496294 -12117.33238326758
#      2023-Jan-01-00:45:00.0000 -25211423.09839294 145087566.5305725 -12038.881494008
#      2023-Jan-01-01:00:00.0000 -25238714.82767072 145083575.7496591 -11960.40439691395
#      2023-Jan-01-01:15:00.0000 -25266007.47441782 145079578.9032956 -11881.9015353024
#      2023-Jan-01-01:30:00.0000 -25293301.03457631 145075575.9878950 -11803.37335225195
# 
# Prvi stolpec vsebuje datum in uro, drugi stolpec koordinato $x$, tretji 
# koordinato $y$ in četrti koordinato $z$ telesa (Luna oz. Zemlja). 
# 
# Definiraj funkcijo `preberi(pot_do_datoteke)`, ki prebere vsebino podane 
# datoteke in vrne nabor (tuple) z dvema elementoma. Prvi element naj bo Numpy 
# seznam datumov in ur, drugi element pa naj bo Numpy seznam treh seznamov 
# koordinat (po eden za vsako koordinato). Števila v seznamih koordinat naj 
# bodo tipa `float`. 
# 
# **Pri tej podnalogi lahko uporabljaš zanke.**
# 
# Primer nabora, ki naj ga funkcija vrne (*za lažjo 
# berljivost so seznami okrajšani s ... in razdeljeni v vrstice*):
# 
#      >>> preberi("lega-luna.txt")
#      (
#          ['2023-Jan-01-00:00:00.0000' '2023-Jan-01-00:15:00.0000'
#           '2023-Jan-01-00:30:00.0000' ... '2024-Dec-31-23:15:00.0000'
#           '2024-Dec-31-23:30:00.0000' '2024-Dec-31-23:45:00.0000']
#      ,
#          [[-2.51295535e+07 -2.51568424e+07 -2.51841323e+07 ... -2.64865734e+07
#            -2.65125445e+07 -2.65385155e+07]
#           [ 1.45099503e+08  1.45095530e+08  1.45091551e+08 ...  1.44325961e+08
#             1.44321396e+08  1.44316827e+08]
#           [-1.22741538e+04 -1.21957566e+04 -1.21173324e+04 ... -3.84288584e+04
#            -3.83948938e+04 -3.83607495e+04]]
#      )
# =============================================================================
import numpy as np


def preberi(pot_do_datoteke):
    casi = []
    podatki = [[], [], []]
    with open(pot_do_datoteke, "rt", encoding="utf-8") as f:
        for line in f:
            stripped = line.strip().split()
            casi.append(stripped[0])
            podatki[0].append(float(stripped[1]))
            podatki[1].append(float(stripped[2]))
            podatki[2].append(float(stripped[3]))

    casi = np.array(casi)
    podatki = np.array(podatki)

    return (casi, podatki)
# =====================================================================@030033=
# 2. podnaloga
# Sedaj, ko ima koordinate, lahko izračuna, kje na Zemljinem nebu se nahajata 
# Sonce in Luna. Za opis lege Sonca in Lune na nebu bo uporabila sferični
# koordinatni sistem. V takem sistemu si predstavljamo, da telesa ležijo 
# na površini krogle, opazovalec pa se nahaja v središču krogle. Lego točke 
# na površini krogle podamo z dvema koordinatama $(\theta, \varphi)$. Ti dve
# koordinati sta analogni geografski širini in geografski dolžini.
# Sonce in Luna se seveda ne nahajata na sferi okrog Zemlje, a nas zanima 
# le, kdaj se prekrivata, zato se z razdaljami ne bomo ukvarjali, le s 
# smerjo teles.
# 
# Z nekaj računanja in geometrije, je Lara izpeljala spodnje formule za izračun 
# koordinat ($\theta$, $\varphi$) iz ($x$, $y$, $z$).
# 
# $$
# \theta_S = \arcsin{\frac{z_Z}{\sqrt{x_Z^2+y_Z^2+z_Z^2}}}
# $$
# $$
# \varphi_S = \arctan_2{(-y_Z, -x_Z)}
# $$
# $$
# \theta_L = \arcsin{\frac{z_Z-z_L}{\sqrt{ (x_L-x_Z)^2 + (y_L-y_Z)^2 + (z_L-z_Z)^2 }}}
# $$
# $$
# \varphi_L = \arctan_2{(y_L-y_Z, x_L-x_Z)}
# $$
# 
# kjer sta $\theta_S$ in $\varphi_S$ koordinati Sonca na Zemljinem nebu, 
# $\theta_L$ in $\varphi_L$ pa koordinati Lune; $x_Z$, $y_Z$ in $z_Z$ so 
# koordinate Zemlje, $x_L$, $y_L$ in $z_L$ pa koordinate Lune.
# 
# Tvoja naloga je, da Lari pomagaš napisati funkcijo 
# `poracunaj(datoteka_zemlja, datoteka_luna)`, ki kot parametra prejme pot do 
# datoteke s koordinatami Zemlje in pot do datoteke s koordinatami Lune ter 
# s pomočjo zgornjih formul izračuna sferične koordinate Sonca in Lune.
# Koordinate $x$, $y$, $z$ in čase lahko dobiš s klicem funkcije `preberi`.
# 
# Funkcija `poracunaj` mora vrniti 
# nabor s petimi elementi. Prvi naj bo Numpy seznam časov, kot ga vrne funkcija 
# `preberi`. Časi so za Zemljo in Luno enaki, zato lahko vrne le enega od njiju. 
# Ostali elementi nabora naj bodo Numpy seznami izračunanih koordinat.
# Drugi element naj bo $\theta_S$ ob vseh časih, tretji $\varphi_S$, 
# četrti $\theta_L$ in peti $\varphi_L$. Koordinate naj bodo v radianih.
# 
# Pri izračunu uporabi matematične funkcije s seznama
# [https://numpy.org/doc/stable/reference/routines.math.html](https://numpy.org/doc/stable/reference/routines.math.html)
# 
# **Pozor: Uporabi funkcijo `arctan2` in NE `arctan`!**
# 
# **Podnalogo rešujte s pomočjo paketa numpy. Uporaba zank je prepovedana.
# Če uporabljate zanke, lahko dosežete kvečjemu polovico vseh možnih točk.**
# =============================================================================
def poracunaj(datoteka_zemlja, datoteka_luna):
    casi_z, zemlja = preberi(datoteka_zemlja)
    casi_l, luna = preberi(datoteka_luna)

    theta_s = np.arcsin(-zemlja[2] / \
        np.sqrt(zemlja[0]**2 + zemlja[1]**2 + zemlja[2]**2))

    fi_s = np.arctan2(-zemlja[1], -zemlja[0])

    theta_l = np.arcsin(-(luna[2] - zemlja[2]) / \
    np.sqrt((luna[0] - zemlja[0])**2 \
        + (luna[1] - zemlja[1])**2 \
            + (luna[2] - zemlja[2])**2))

    fi_l = np.arctan2(luna[1] - zemlja[1], luna[0] - zemlja[0])

    return casi_z, theta_s, fi_s, theta_l, fi_l
# =====================================================================@030034=
# 3. podnaloga
# Sedaj, ko smo izračunali koordinate Sonca in Lune na Zemljinem nebu, je treba 
# le še preveriti, kdaj sta Sonce in Luna dovolj blizu, da Luna prekrije del Sonca.
# 
# Do mrka pride, ko je razlika v obeh koordinatah manjša od $1.4^{\circ}$
# 
# $$
# \mid \theta_S - \theta_L \mid < 1.4^{\circ} \text{ in hkrati } \mid \varphi_S - \varphi_L \mid < 1.4^{\circ}
# $$
# 
# Napiši funkcijo `casmrka(datoteka_zemlja, datoteka_luna)`. Parametra 
# `datoteka_zemlja` in `datoteka_luna` podaj klicu funkcije `poracunaj`, da 
# dobiš čase in sferične koordinate Sonca in Lune. Preveri, kdaj sta izpolnjena
# zgornja pogoja, in izračunaj ob katerih časih Luna zakriva Sonce. Funkcija 
# mora vrniti Numpy seznam časov, za katere je pogoj izpolnjen.
# 
# **Pozor: Pri zgornjih pogojih morajo biti koordinate v stopinjah. Iz radianov 
# jih lahko pretvorite v stopinje z množenjem s $\frac{180}{\pi}$.**
# 
# **Podnalogo rešujte s pomočjo paketa numpy. Uporaba zank je prepovedana.
# Če uporabljate zanke, lahko dosežete kvečjemu polovico vseh možnih točk.**
# =============================================================================
def casmrka(datoteka_zemlja, datoteka_luna):
    casi, theta_s, fi_s, theta_l, fi_l = poracunaj(datoteka_zemlja, datoteka_luna)

    theta_k = np.abs(theta_s - theta_l) < 1.4 * np.pi/180
    fi_k = np.abs(fi_s - fi_l) < 1.4 * np.pi/180
    pogoj = theta_k & fi_k # izpolnjena morata biti oba pogoja

    indeksi = np.flatnonzero(pogoj) # indeksi, kjer Luna prekriva Sonce

    return casi[indeksi] # časi, kjer Luna prekriva Sonce

# Pasti
#
# Pri iskanju zaklada starodavnega egipčanskega faraona
# [Škorpijona I.](https://sl.wikipedia.org/wiki/%C5%A0korpijon_I.) sta se ti in
# tvoj prijatelj Kozmijan Buta iz Butal znašla v težki situaciji. Kozmijan je
# ujet sredi sobe polne pasti, vaju pa lovi mumija! Ampak ne paničari,
# tvoje predhodne izkušnje pri pobegih iz starodavnih egipčanskih piramid ti
# bodo v pomoč.
# =====================================================================@030035=
# 1. podnaloga
# Najprej moraš najti, kje so sploh pasti. Iz izkušenj hitro prepoznaš, katere
# pasti so prisotne. To so skrite sulice(`'^'`) in prekrite jame(`'#'`). Ostala
# polja(`'.'`) so varna. Najprej definiraj funkcijo `najdi_pasti(niz)`, ki vrne
# seznam indeksov v črkovnem nizu, na katerih se nahajajo pasti. V primeru, da
# pasti ni, vrni `None`.
# 
#     >>> najdi_pasti('...#.^..^..')
#     [3, 5, 8]
#     >>> najdi_pasti('....')
#     None
# =============================================================================
def najdi_pasti(niz):
    pasti = []
    for indeks, polje in enumerate(niz):
        if polje in '#^':
            pasti.append(indeks)
    if len(pasti) != 0:
        return pasti
# =====================================================================@030036=
# 2. podnaloga
# Kozmijan začne pobeg izven niza in kot prvi korak stopi na prvo polje na
# levi ter se nato pomika proti desni. Ko pride do pasti z zaletom, jo preskoči
# in pristane na polju direktno za pastjo (stara egipčanska pravila zatrjujejo,
# da nikoli nista dve pasti ena za drugo, to bi bilo kruto). Zalet se izračuna
# na nasleden način:
# 
# `zalet` = število praznih polj, na katera stopi Kozmijan po pristanku pred pastjo
# 
# Ko Kozmijan preskoči past, se zalet začne šteti od začetka, začenši
# z naslednjim poljem. V primeru, da je past na prvem mestu, ima zalet
# enak $0$.
# 
# Napiši funkcijo `zalet(niz)`, ki vrne seznam naborov, kjer je prvi element
# tip pasti, drugi indeks mesta, na katerem leži past, tretji pa zalet. V
# primeru praznega niza vrni prazen seznam. Oglejmo si primer.
# 
# `niz = '..^..#....^.#.'`
# 
# Kozmijan stopi na prvo polje `'.'`. Pomika se desno, dokler ne pride do
# prve pasti, to je `'^'`. Stopil je na dve prazni polji pred pastjo, zato ima
# zalet $2$. Preskoči past in pristane na polju `'.'` za pastjo in zalet se mu
# nastavi nazaj na $0$. Nato gre v desno do `'#'` z zaletom $1$, ker je po
# pristanku tekel le preko enega praznega polja. Podobno pride do pasti `'^'`
# z zaletom $3$ in jo preskoči ter zalet se mu nastavi na $0$. Naslednje polje je
# past `'#'`, torej do nje pride z zaletom $0$. Zadnje polje je varno in Kozmijan
# pobegne.
# 
# Kot rezultat tako dobimo
# 
#     >>> zalet('..^..#....^.#.')
#     [('^', 2, 2), ('#', 5, 1), ('^', 10, 3), ('#', 12, 0)]
# =============================================================================
def zalet(niz):
    sez = []
    trenutni_zalet = 0
    for indeks, polje in enumerate(niz):
        if polje == '.':
            trenutni_zalet += 1
        else:
            sez.append((polje, indeks, trenutni_zalet))
            trenutni_zalet = -1
    return sez
# =====================================================================@030037=
# 3. podnaloga
# Z vsemi informacijami lahko sedaj pripraviš načrt pobega. Ker se mumija nevarno
# bliža po hodniku, moraš hitro najti najkrajšo pot do varnosti, ki jo lahko
# razložiš Kozmijanu. Tako kot v drugem delu, se lahko Kozmijan zažene le v
# ravni črti. Kot vsak dober raziskovalec/raziskovalka egipčanskih piramid veš,
# koliko zaleta je potrebno, da lahko oseba preskoči vsak tip pasti. To imaš
# zapisano v priročnem slovarju `potreben_zalet`, kjer so ključi tipi pasti
# in vrednosti potrebni zaleti.
# 
# V ta namen napiši funkcijo `pobeg(vhodna, potreben_zalet)`. V datoteki z imenom
# `vhodna` se bodo nahajala v pravokotni mreži znana polja `'.'`, `'#'`, `'^'`,
# poleg tega pa bo eno izmed polj enako `'K'`, to bo Kozmijanov trenuten položaj.
# Primer datoteke `vhodna` je
# 
#     ............
#     ...#.#.^..^.
#     .#..#.^.^...
#     ..^..K.#....
#     .#..#.^...#.
#     ..^....#..^.
#     .#...#..^...
#     ...^..#..^..
#     .#.....^..#.
#     ..#..^..#...
#     ............
# 
# Funkcija naj vrne slovar, kjer so ključi smeri neba, v katere se lahko zažene
# Kozmijan. Torej `'S'` (sever/gor), `'J'` (jug/dol), `'V'` (vzhod/desno), `'Z'`
# (zahod/levo). Vrednost pa naj bo dolžina poti, če je le ta varna, sicer pa
# naj bo enaka `None`.
# 
# Za primer vhodne datoteke iz navodil imamo za Kozmijana naslednje izbire:
# 
# `'S'`: `'.#.'`
# 
# `'J'`: `'..#..^.'`
# 
# `'V'`: `'.#....'`
# 
# `'Z'`: `'..^..'`
# 
# Zato pri `potreben_zalet = {'^': 1, '#': 2}` dobimo za rezultat
# 
#     >>> pobeg(vhodna, potreben_zalet)
#     {'S': None, 'J': 7, 'V': None, 'Z': 5}
# =============================================================================
def pobeg(vhodna, potreben_zalet):
    polja = []
    zacetna_vrsta, zacetni_stolpec = None, None
    with open(vhodna) as f:
        for i, vrstica in enumerate(f):
            vrsta = []
            for j, znak in enumerate(vrstica.strip()):
                if znak == 'K':
                    zacetna_vrsta, zacetni_stolpec = i, j
                vrsta.append(znak)
            polja.append(vrsta)

    st_vrstic = len(polja)
    st_stolpcev = len(polja[0])

    pot_sever = ''.join(polja[x][zacetni_stolpec] for x in range(zacetna_vrsta-1, -1, -1))
    pot_jug = ''.join(polja[x][zacetni_stolpec] for x in range(zacetna_vrsta+1, st_vrstic))
    pot_vzhod = ''.join(polja[zacetna_vrsta][y] for y in range(zacetni_stolpec+1, st_stolpcev))
    pot_zahod = ''.join(polja[zacetna_vrsta][y] for y in range(zacetni_stolpec-1, -1, -1))

    pari = list(zip('SJVZ', [pot_sever, pot_jug, pot_vzhod, pot_zahod]))
    slovar = {}
    for smer, pot in pari:
        slovar[smer] = len(pot)
        for tip, _, dolzina_zaleta in zalet(pot):
            if dolzina_zaleta < potreben_zalet[tip]:
                slovar[smer] = None

    return slovar
'''
[
'.................',
'..#..#..^.^..^.#.',
'.#..^.#..#.^..^..',
'..^.^..^.K#.#..#.',
'.#....^..^...#...',
'...^.^.#...#..^..',
'.................'
]
'''

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1. IZPIT 2022/2023:
# Datumi
#
# Vsak povprečen državljan Lensemštajna si želi, da bi čim več praznikov bilo med 
# tednom, saj so med vikendom že prosti. Ker planirate na naslednjih volitvah
# v državni zbor kandidirati tudi sami, bi si radi pripravili dober program. 
# Ena izmed obljub je, da boste uvedli nov zakon, in sicer, da boste lahko sami
# izbrali, kateri dan v tednu se je začelo leto 0. Da boste to storili čimbolje,
# si pomagajte tako, da rešite spodnje naloge.
# 
# V nalogah vedno začnemo šteti z 0. To pomeni, da je prvi dan v tednu 0, prav
# tako sta prvi mesec in prvo leto 0. Torej prvi datum koledarja, ki ga Lensemštajn
# uporablja, je datum (0, 0, 0).
# =====================================================================@033007=
# 1. podnaloga
# Sestavite funkcijo `kateri_dan_v_tednu(meseci, dolzina_tedna, datum)`. 
# Funkcija sprejme seznam `meseci`, ki za zaporedne mesece vsebuje 
# število dni v mesecu, in `dolzina_tedna`, ki pove, koliko dni traja en teden.
# Funkcija sprejme tudi `datum`, ki je urejena trojka `(dan, mesec, leto)`.
# Funkcija naj sprejme še neobvezen argument `prvi_dan`, ki pove, kateri
# dan v tednu je bil na datum (0, 0, 0). Če tega argumenta ne podamo, naj 
# funkcija predpostavi, da je bil prvi dan 0. Funkcija naj vrne, kateri dan v
# tednu predstavlja `datum`.
# 
# Primer:
# 
#       >>> kateri_dan_v_tednu([8, 7, 34, 7, 1, 36, 2], 7, (1, 3, 5))
#       0
#       >>> kateri_dan_v_tednu([12, 30, 18, 37], 6, (1, 0, 0), 3)
#       4
# 
# Namig: Pomisli, za koliko dni se v enem letu zamakne isti datum (dan in mesec) (+1)
# in kateri zaporedni dan v letu predstavlja datum.
# =============================================================================
def kateri_dan_v_tednu(m, dt, datum, prvi_dan=0):
    dolzina_leta = sum(m)
    zamik_na_leto = dolzina_leta % dt # ostanek pove kolikšen je zamik
    zacetek_leta = prvi_dan + (datum[2] * zamik_na_leto) % dt
    dan_v_tednu = zacetek_leta + sum(m[:datum[1]]) + datum[0]
    return dan_v_tednu % dt


# Ne dela:
#def kateri_dan_v_tednu(meseci, dolzina_tedna, datum, prvi_dan=0):
    dni_pred = sum(meseci[:datum[1]]) + datum[0]
    dan_v_tednu = (prvi_dan + dni_pred) % dolzina_tedna
    return dan_v_tednu


# =====================================================================@033008=
# 2. podnaloga
# Sestavite funkcijo `koliko_praznikov_na_dan`, ki sprejme argumenta `meseci` 
# in `dolzina_tedna` tako kot zgoraj in argument `prazniki`, ki je seznam 
# datumov praznikov. Vrne pa naj slovar, ki ima za ključe letnice, vrednosti 
# pa so slovarji, ki imajo za ključe dneve v tednu, za vrednosti pa število 
# praznikov na dan v tem letu. Če se na kak dan praznik nikoli ne pojavi, naj
# tega dneva ne bo v slovarju. Tudi ta funkcija naj sprejme neobvezen argument 
# `prvi_dan`, ki ima privzeto vrednost 0.
# 
# 
# Primer:
# 
#       >>>  koliko_praznikov_na_dan([30, 27, 30, 29, 30, 29], 7, [(0, 1, 2049), (20, 4, 2050), (7, 4, 2050), (9, 0, 2050), (15, 3, 2050)])
#       {2049: {2: 1}, 2050: {3: 1, 4: 2, 2: 1}}
#       >>> koliko_praznikov_na_dan([23, 23, 12, 23, 12], 5, [(14, 0, 2049)], 2)
#       {2049: {3: 1}}
# =============================================================================
def koliko_praznikov_na_dan(meseci, dolzina_tedna, prazniki, prvi_dan=0):
    rez = {}
    for dan, mesec, leto in prazniki:
        dan_v_tednu = kateri_dan_v_tednu(meseci, dolzina_tedna, (dan, mesec, leto), prvi_dan)
        rez[leto] = rez.get(leto, {}) # dopolnjuješ slovar
        rez[leto][dan_v_tednu] = rez[leto].get(dan_v_tednu, 0) + 1
    return rez


# Ne dela:
#def koliko_praznikov_na_dan(meseci, dolzina_tedna, prazniki, prvi_dan=0):
    prazniki_na_dan = {}

    for datum in prazniki:
        dan, mesec, leto = datum
        dan_v_tednu = kateri_dan_v_tednu(meseci, dolzina_tedna, datum, prvi_dan)
        
        if leto not in prazniki_na_dan:
            prazniki_na_dan[leto] = {}
        
        if dan_v_tednu not in prazniki_na_dan[leto]:
            prazniki_na_dan[leto][dan_v_tednu] = 0
        
        prazniki_na_dan[leto][dan_v_tednu] += 1

    return prazniki_na_dan


# =====================================================================@033009=
# 3. podnaloga
# Sestavite funkcijo, `najboljsi_zacetek`, ki sprejme argumente `meseci`, 
# `dolzina_tedna` in `prazniki` tako kot zgoraj, vrne pa množico dni v tednu, 
# ko bi se moralo začeti leto 0, da bo čimveč praznikov padlo na delovne dneve.
# Ker bo vaš potencialni mandat samo v letu 2048, se na praznike v ostalih letih
# ne ozirajte. Delovni dnevi so vedno dnevi 0, 1, 2, 3, 4 neglede na dolžino tedna.
# 
# Primer:
# 
#       >>> najboljsi_zacetek([12, 12, 12, 12], 6, [(1, 0, 2048), (1, 1, 2048), (1, 2, 2048)])
#       {0, 1, 2, 3, 5}
# =============================================================================
def najboljsi_zacetek(meseci, dolzina_tedna, prazniki):
    naj_dan, koliko = 0, -1
    rez = set()
    for i in range(dolzina_tedna):
        prazniki_leto = koliko_praznikov_na_dan(meseci, dolzina_tedna, prazniki, prvi_dan=i)
        leto2048 = prazniki_leto.get(2048, {})
        st_praznikov = 0
        for dan, st_praznikov_na_dan in leto2048.items():
            if dan < 5:
                st_praznikov += st_praznikov_na_dan
        if st_praznikov > koliko:
            naj_dan, koliko = i, st_praznikov
            rez = {naj_dan}
        elif st_praznikov == koliko:
            rez.add(i)
    return rez

# Prašah
#
# Malokdo pozna prvotno različico šaha. 
# Prašah se igra na črno beli $N\texttt{x}N$ šahovnici z $2N$ figurami za $N > 2$.
# Ker se v pradavnini malokdo spozna na python, vas praljudje prosijo za pomoč.
# 
# Če pri tej nalogi uporabljate zanke, lahko dosežete le polovico možnih točk!
# =====================================================================@033001=
# 1. podnaloga
# Na začetku je $N$ figur na prvi vrstici in $N$ na zadnji. 
# Vrednosti figur so v obeh vrsticah simetrične, robne figure so vredne 1, vsaka sosednja (do polovice) pa je vredna za 1 več.
# Začetna pozicija figur za $N=6$ je na primer
# 
#     np.array([[1., 2., 3., 3., 2., 1.]
#               [0., 0., 0., 0., 0., 0.]
#               [0., 0., 0., 0., 0., 0.]
#               [0., 0., 0., 0., 0., 0.]
#               [0., 0., 0., 0., 0., 0.]
#               [1., 2., 3., 3., 2., 1.]])
# 
# Napišite funkcijo `zacetek(N)`, ki vrne začetno pozicijo figur, kot je opisana zgoraj.
# 
#     >>> zacetek(3)
#     [[1., 2., 1.]
#      [0., 0., 0.]
#      [1., 2., 1.]]
#     >>> zacetek(6)
#     [[1., 2., 3., 3., 2., 1.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [1., 2., 3., 3., 2., 1.]]
# =============================================================================
import numpy as np


def zacetek(N):
    tab = np.zeros((N, N))
    vrstica = np.arange(1, N + 1)
    obrnjena = vrstica[::-1]
    vrstica[N//2:] = obrnjena[N//2:]
    tab[0, :] = vrstica
    tab[-1, :] = vrstica
    return tab
# =====================================================================@033002=
# 2. podnaloga
# V vsakem krogu igre en igralec odloči, katera vrstica/stolpec se ciklično premakne ("zrola") 
# za koliko ter kam.
# 
# Napišite funkcijo `igra`, ki sprejme ploščo s figurami v nekem trenutku ter potezo.
# Poteza je sestavljena iz dveh elementov. Prvi je `'stolpec'`, če se premika stolpec, ali `'vrstica'`, če se premika vrstica.
# Drugi je par `(i, n)`, kjer je `i` indeks vrstice oz. stolpca, torej število med 0 in $N-1$, `n` pa
# celo število, ki pomeni premik. Če je število pozitivno, se stolpec premakne dol, vrstica pa desno. Če je
# število negativno, se stolpec premakne gor, vrstica pa levo.
# 
# Funkcija `igra` naj vrne ploščo po opravljeni potezi.
# 
#     >>> igra(zacetek(6), ['stolpec',  (2,  2)])
#     [[1., 2., 0., 3., 2., 1.]
#      [0., 0., 3., 0., 0., 0.]
#      [0., 0., 3., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [1., 2., 0., 3., 2., 1.]]
# 
#     >>> igra(zacetek(6), ['vrstica',  (5, -1)])
#     [[1., 2., 3., 3., 2., 1.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [2., 3., 3., 2., 1., 1.]]
# =============================================================================
def igra(plosca, poteza):
    vr_ali_st, (i, n) = poteza
    if vr_ali_st == 'vrstica':
        plosca[i, :] = np.roll(plosca[i, :], n)
    else:
        plosca[:, i] = np.roll(plosca[:, i], n)
    return plosca
# =====================================================================@033003=
# 3. podnaloga
# Igro igrata 2 igralca, en je bel in en črn. Točke črnega igralca se izračunajo kot vsota vrednosti figur na črnih poljih, 
# točke belega pa kot vsota vrednosti figur na belih poljih. Zmaguje tisti igralec, ki ima več točk. Polje zgoraj levo na šahovnici
# je ne glede na velikost belo.
# 
# Beli je z vašo pomočjo iz prejšnje naloge že ugotovil, katera polja so možna po njegovi potezi. Pomagajte mu izbrati med njimi.
# Napišite funkcijo `najboljsa`, ki iz tabele, ki ima po ničti osi razporejene možne plošče, izbere tisto, ki je belemu najbolj po godu. To je tista, 
# pri kateri je razlika med točkami belega in točkami črnega največja. Če je takih plošč več, naj izbere prvo po vrsti.
# 
#     >>> plosce = np.array([[[1., 2., 0., 3., 2., 1.]
#                             [0., 0., 3., 0., 0., 0.]
#                             [0., 0., 3., 0., 0., 0.]
#                             [0., 0., 0., 0., 0., 0.]
#                             [0., 0., 0., 0., 0., 0.]
#                             [1., 2., 0., 3., 2., 1.]],
#                            [[1., 2., 3., 3., 2., 1.]
#                             [0., 0., 0., 0., 0., 0.]
#                             [0., 0., 0., 0., 0., 0.]
#                             [0., 0., 0., 0., 0., 0.]
#                             [0., 0., 0., 0., 0., 0.]
#                             [2., 3., 3., 2., 1., 1.]]])     
#     >>> najboljsa(plosce)
#     [[1., 2., 0., 3., 2., 1.]
#      [0., 0., 3., 0., 0., 0.]
#      [0., 0., 3., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [0., 0., 0., 0., 0., 0.]
#      [1., 2., 0., 3., 2., 1.]]
# 
# **Namig:** Šahovnico lahko predstavite kot $N\texttt{x}N$ tabelo, ki ima na belih mestih 1, na črnih pa -1, za kar je 
# koristna funkcija `np.fromfunction`. Prav lahko prideta tudi funkciji `np.sum` in `np.argmax`.
# =============================================================================
def f(i, j):
    return (-1) ** (i + j)

def najboljsa(plosce):
    sahovnica = np.fromfunction(f, plosce[0].shape)
    vrednosti = plosce * sahovnica
    vrednosti = np.sum(np.sum(vrednosti, axis=1), axis=1)
    i = np.argmax(vrednosti)
    return plosce[i]


# Polinomi
#
# Vaš mlajši brat vas je prosil, če mu lahko pomagate pri testu iz polinomov. 
# Ker pa ne želite, da bi vas zalotili, se domislite načina, kako boste to izpeljali.
# 
# *POZOR: Pri celotni nalogi predpostavi, da so koeficienti cela števila, stopnje pa 
# pozitivna cela števila.*
# =====================================================================@033010=
# 1. podnaloga
# Napišite funkcijo `koeficient_stopnja`, ki sprejme monom v obliki niza `"ax^n"`,
# kjer je `a` koeficient (pozitivno število), `n` stopnja monoma (prav tako 
# pozitivno število, ker gre za polinom) in `x`, ki predstalja spremenljivko.
# Predpostaviš lahko, da je spremenljivka vedno črka angleške abecede. Funkcija
# naj vrne urejen par, kjer je na prvem mestu koeficient, na drugem mestu pa stopnja.
# 
# _Pozor_: Monom stopnje 0 ali 1 lahko zapišemo brez potence, npr. $3x$ je monom stopnje 
# 1 in $6$ je monom stopnje 0.
# 
# Primer:
# 
#     >>> koeficient_stopnja("2x^3")
#     (2, 3)
#     >>> koeficient_stopnja("9")
#     (9, 0)
# =============================================================================
def koeficient_stopnja(niz):
    if '^' not in niz:
        if niz.isnumeric():
            return int(niz), 0
        elif niz.isalpha():
            return 1, 1
        else:
            return int(niz[:-1]), 1
    koef, stop = niz.split('^')
    koef = int(koef[:-1])
    stop = int(stop)
    return koef, stop
# =====================================================================@033011=
# 2. podnaloga
# Napišite funkcijo `pretvori_polinom`, ki sprejme niz oblike `"p(x) = x^2 + 2x - 3"`
# in ga pretvori v slovar, kjer je ključ stopnja monoma v polinomu `p`, vrednost pa 
# koeficient v monomu te stopnje. Predpostaviš lahko, da  pred in za vsakim členom 
# stoji presledek in da se monom iste stopnje ne pojavi več kot enkrat (lahko pa se 
# ne pojavi).
# 
# Primer:
# 
#     >>> pretvori_polinom("p(x) = - 7x^5 - 2x - 1 + 3x^3")
#     {5: -7, 1: -2, 0: -1, 3: 3}
#     >>> pretvori_polinom("q(y) = 2y - 3y^2022")
#     {1: 2, 2022: -3}
# =============================================================================
def pretvori_polinom(p):
    # p razbijemo na monome in predznake
    cleni = p.split(" ")
    cleni = cleni[cleni.index("=") + 1:]
    # če nimamo predznaka pri vodilnem členu, ga dodamo
    if cleni[0] not in "+-":
        cleni = ["+"] + cleni
    polinom = {}
    for predznak, monom in zip(cleni[::2], cleni[1::2]):
        if predznak == "+":
            predznak = 1
        else:
            predznak = -1
        koef, st = koeficient_stopnja(monom)
        polinom[st] = koef * predznak
    return polinom
# =====================================================================@033012=
# 3. podnaloga
# Da vas ne bi zasačili, polinom spremenite v besedo tako, da vse številke zamenjate
# z rimskimi števkami, znak `+` zamenjate z besedo `plus`, znak `-` z besedo `minus`
# potenco `^` pa z besedo `potenca`.
# 
# Napišite funkcijo `vbesedi_polinom`, ki sprejme ime vhodne datoteke, kjer se 
# nahajajo polinomi (vsak polinom v svoji vrstici), ime datoteke, kjer se nahajajo
# rimske števke (vsaka vrstica vsebuje zaporedno rimsko števko) prva vrstica vsebuje
# `O`, druga `I`, tretja `II` in tako naprej, kjer `O` (velika tiskana črka o) predstavlja 
# število 0 (rimljani še niso poznali znaka za število 0, zato si ga izmislimo sami).
# in ime izhodne datoteke, kamor zapišite pretvorjen polinom, vsakega v svojo vrsto.
# 
# Vsak polinom naj bo v spremenljivki `x`, ima monome urejene po stopnji padajoče 
# in naj ne vsebuje presledkov. V rezultatu, naj vsi polinomi vsebujejo koeficient in 
# stopnjo. Naprimer `"p(x) = x + 1"`, naj se prepiše v `IxpotencaIplusIxpotencaO`.
# 
# Pomoč: poskusi ugotoviti kaj počne spodnja funkcija in jo uporabi, če želiš.
# 
# 
#       def pomoc(izhodna, polinomi_po_stopnjah_padajoce, stevke):
#           """
#           polinomi_po_stopnjah_padajoce je seznam elementov oblike: 
#           [(2, 3), (1, -3), (0, 4)]
#           Ta element predstavlja naprimer polinom 3x^2 - 3x + 4  
#           """
#           with open(izhodna, "w") as dat:
#               for polinom in polinomi_po_stopnjah_padajoce:
#                   p = ""
#                   for i, (st, koef) in enumerate(polinom):
#                       if koef < 0:
#                           p += "minus"
#                       elif i != 0:
#                           p += "plus"
#                       p += f"{stevke[abs(koef)]}xpotenca{stevke[abs(st)]}"
#                   print(p, file=dat)
# =============================================================================
def pomoc(izhodna, polinomi_po_stopnjah_padajoce, stevke):
    """
    polinomi_po_stopnjah_padajoce je seznam elementov oblike: 
    [(2, 3), (1, -3), (0, 4)]
    Ta element predstavlja naprimer polinom 3x^2 - 3x + 4  
    """
    with open(izhodna, "w") as dat:
        for polinom in polinomi_po_stopnjah_padajoce:
            p = ""
            for i, (st, koef) in enumerate(polinom):
                if koef < 0:
                    p += "minus"
                elif i != 0:
                    p += "plus"
                p += f"{stevke[abs(koef)]}xpotenca{stevke[abs(st)]}"
            print(p, file=dat)

def vbesedi_polinom(polinomi, rimske_stevke, izhodna):
    pretvorjeni = []
    with open(polinomi, "r") as dat:
        for polinom in dat:
            pretvorjeni.append(sorted(pretvori_polinom(polinom.strip()).items(), reverse=True))
    with open(rimske_stevke, "r") as dat:
        stevke = dat.read().split("\n")
    pomoc(izhodna, pretvorjeni, stevke)

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2. IZPIT 2022/2023:
# Taksist Miran
#
# Mladi taksist Miran je zelo hiter voznik, žal pa nekoliko peša njegovo fizikalno
# znanje, zato vas prosi za pomoč.
# =====================================================================@033016=
# 1. podnaloga
# Ker je Miran plačan na število strank, ki jih na dan razvozi, ga najprej zanima
# katera stranka mu je najbližje, zato najprej potrebuje funkcijo `najblizja(zac, loc)`,
# ki sprejme točko `zac`, kjer je centrala Miranove taksi službe podana kot par
# s koordinatama `(x, y)` in seznam parov (strank), ki so prav tako predstavljeni
# s parom koordinat. Funkcija naj vrne točko, ki je najbližja centrali Miranove
# taksi službe. Če ni nobene stranke, naj funkcija ne vrne ničesar. Predpostaviš
# lahko, da nobeni stranki nista enako oddaljeni.
# 
# Primer:
# 
#       >>> najblizja((1, 1), [(2, 4), (1, 4), (4, 9)])
#       (1, 4)
#       >>> najblizja((2, 8), [])
#       None
# =============================================================================
def najblizja(zac, loc):
    if not loc:
        return None
    zx, zy = zac
    x_min, y_min = loc[0]
    d_min = ((x_min - zx) ** 2 + (y_min - zy) ** 2) ** (1 / 2) # razdalja
    for x, y in loc:
        d = ((x - zx) ** 2 + (y - zy) ** 2) ** (1 / 2)
        if d < d_min:
            x_min, y_min = x, y # če je krajša, na novo postavimo koordinate
            d_min = d # nova minimalna razdalja
    return x_min, y_min


# =====================================================================@033017=
# 2. podnaloga
# Žal pa so zaradi pomanjkanja denarja v taksi službi morali odpustiti gospoda,
# ki je iz zemljevida prepisoval koordinate in mora Miran sedaj točke poiskati
# sam. Seveda prosi vas, da to storite namesto njega. Napišite funkcijo
# `preberi_lokacije(vhodna)`, ki sprejme ime vhodne datoteke in vrne seznam
# lokacij strank. Vhodna datoteka je oblike:
# 
#       ...#....
#       .#.....#
#       ........
#       ........
#       .#......
# 
# kjer, `#` predstavlja stranko in `.` prazen prostor. Koordinate
# posamezne stranke so indeksi vrstice in stolpca. Za zgornji preimer torej
# funkcija vrne:
# 
#       >>> preberi_lokacije("zemljevid.txt")
#       [(0, 3), (1, 1), (1, 7), (4, 1)]
# =============================================================================
def preberi_lokacije(vhodna):
    loc = []
    with open(vhodna) as dat:
        for i, vr in enumerate(dat): # i je št. vrstice
            for j, znak in enumerate(vr.strip()): # j je številka koordinate v vrstici(stolpec)
                if znak == "#":
                    loc.append((i, j)) # dodamo koordinate
    return loc


# =====================================================================@033018=
# 3. podnaloga
# Ker Miran želi pobrati vse stranke, vas prosi, da mu sestavite vrstni red
# pobiranja strank. Vrstni red je seznam vseh točk, urejenih po oddaljenosti
# od centrale (pomislite, kako vam tu pomaga funkcija iz prve podnaloge).
# Napišite funkcijo `koliko_razdalje(zac, vhodna, izhodna)`, ki sprejme `zac`,
# ki je lokacija centrale, `vhodna`, ki je datoteka take oblike kot zgoraj in
# `izhodna`, kamor naj funkcija zapiše v vsako vrstico najprej koordinate
# centrale, potem puščico z razdaljo na dve decimalki ("=d.dd=>") in na koncu
# še ciljno točko. Po klicu funkcije
# `koliko_razdalje((4, 5), "zemljevid.txt", "izhod.txt")` se v datoteki
# `izhod.txt` nahaja:
# 
#       (4, 5) =3.61=> (1, 7)
#       (4, 5) =4.47=> (0, 3)
#       (4, 5) =5.00=> (1, 1)
#       (4, 5) =5.00=> (4, 0)
# =============================================================================
def koliko_razdalje(zac, vhodna, izhodna):
    loc = preberi_lokacije(vhodna)
    urejene = []
    xz, yz = zac
    while loc:
        tmp = najblizja(zac, loc)
        urejene.append(tmp)
        loc.remove(tmp)
    with open(izhodna, "w") as dat:
        for x, y in urejene:
            d = ((x - xz) ** 2 + (y - yz) ** 2) ** (1 / 2)
            print(f"({xz}, {yz}) ={d:.2f}=> ({x}, {y})", file=dat)


# ali


def koliko_razdalje(zac, vhodna, izhodna):
    loc = preberi_lokacije(vhodna)
    xz, yz = zac
    urejene = sorted(
        loc, key=lambda x: ((x[0] - xz) ** 2 + (x[1] - yz) ** 2) ** (1 / 2)
    )
    with open(izhodna, "w") as dat:
        for x, y in urejene:
            d = ((x - xz) ** 2 + (y - yz) ** 2) ** (1 / 2)
            print(f"({xz}, {yz}) ={d:.2f}=> ({x}, {y})", file=dat)

# Darila
#
# Ni več skrivnost, da si Božiček zapomni želje za vse ljudi, ker si jih celo
# leto beleži v slovarju. Na primer slovar
# 
#     darila = {'Ana': ['racunalnik', 'tablica'],
#               'Bine': ['cokolada', 'piskoti', 'caj'],
#               'Cene': [],
#               'Davorka': ['peresnica', 'svincnik'],
#               'Eva': ['majica']}
# 
# pove, da si Ana najbolj želi računalnik, potem tablico. Bine si najbolj
# želi čokolado, potem piškote, potem šele čaj. Cene si ne želi ničesar in
# tako naprej.
# 
# Pomagajte Božičku raznositi darila.
# =====================================================================@032995=
# 1. podnaloga
# Napišite funkcijo `spisek`, ki iz slovarja želenih daril vrne slovar daril,
# ki jih bo Božiček prinesel. Ta slovar ima za ključe darila, za vrednosti pa
# njihovo količino. Božiček prinese vsakemu najbolj želeno darilo, če pa kdo
# nima želje, mu prinese čokolado (**napisano cokolada!**).
# 
#     >>> spisek(darila)
#     {'racunalnik': 1, 'cokolada': 2, 'peresnica': 1, 'majica': 1}
# =============================================================================
def spisek(darila):
    slo = {}
    for sez in darila.values():
        darilo = "cokolada" if len(sez) == 0 else sez[0] # Če seznam ni prazen, potem sez[0] izbere prvo darilo na seznamu.
        slo[darilo] = slo.get(darilo, 0) + 1
    return slo


# =====================================================================@032996=
# 2. podnaloga
# Božičku se je posvetilo, da so nekatere izmed želja za darila že stare in da
# so ta darila že bila podarjena. Zato si Božiček napiše še slovar prijateljev,
# ki so si že podarili darila, na primer:
# 
#     prijatelji = {'Ana': ['Davorka'],
#                   'Bine': ['Ana', 'Davorka'],
#                   'Cene': ['Ana', 'Bine'],
#                   'Davorka': ['Bine'],
#                   'Eva': []}
# 
# To pomeni, da je Ana že obdarovala Davorko, Bine Ano in Davorko in tako
# naprej. Prijatelji si zmeraj podarijo najbolj želeno darilo. To pomeni,
# da je Ana Davorki podarila peresnico, Bine Ani računalnik ter Davorki svinčnik
# in tako naprej. Predpostevite lahko, da bo vsaka oseba dobila največ toliko
# daril, kot ima želja.
# 
# Napišite funkcijo `nov_spisek`, ki sprejme slovar daril in slovar prijateljev
# in vrne slovar daril, ki jih Božiček prinese, če nobenemu ne bo prinesel tistih
# daril, ki so mu že bila podarjena od koga drugega.
# 
#     >>> nov_spisek(darila, prijatelji)
#     {'cokolada': 3, 'caj': 1, 'majica': 1}
# =============================================================================
def nov_spisek(darila, prijatelji):
    nova_darila = darila
    for sez in prijatelji.values():
        for oseba in sez:
            nova_darila[oseba] = nova_darila[oseba][1:]
    return spisek(nova_darila)


# =====================================================================@032997=
# 3. podnaloga
# Zdaj, ko Božiček ve, kaj bo vsakemu prinesel, si lahko začrta pot.
# Problem je, da se je čez praznike zredil in ne more nesti vseh daril naenkrat,
# saj bi bile njegove sani potem pretežke in jih magični vzgon ne bi držal v zraku.
# Zato bo njegova pot sestavljena iz več potovanj.
# 
# Vsako darilo je težko $2 \ \texttt{kg}$ na črko (torej je čokolada težka
# $16 \ \texttt{kg}$, čaj pa $6 \ \texttt{kg}$), naenkrat pa lahko nese le
# $30 \ \texttt{kg}$. Darila želi nositi razvrščena po abecedi.
# 
# Napišite funkcijo `pot`, ki sprejme slovar daril, ki jih bo božiček raznosil,
# ter vrne seznam seznamov, ki opisuje Božičkovo pot. V prvem seznamu so darila,
# ki jih nese na prvem potovanju, v drugem darila, ki jih nese na drugem in tako
# naprej. V vsakem seznamu naj bodo darila razvrščena po abecednem vrstnem redu.
# 
#     >>> pot({'cokolada': 3, 'caj': 1, 'majica': 1})
#     [['caj', 'cokolada'], ['cokolada'], ['cokolada', 'majica']]
# 
# **Namig:** Najprej sestavite po abecedi urejen seznam vseh daril s ponovitvami, na primer `['caj', 'cokolada', 'cokolada', 'cokolada', 'majica']`.
# Pomagate si lahko z metodo .sort(), ki seznam nizov razvrsti po abecedi.
# =============================================================================
def pot(slo):
    darila_brez_ponovitve = list(slo.keys())
    darila_brez_ponovitve.sort()
    darila = []
    for darilo in darila_brez_ponovitve:
        darila += [darilo] * slo[darilo]
    sez = []
    trenutna_pot = []
    skupna_teza = 0
    for darilo in darila:
        teza = 2 * len(darilo)
        if teza + skupna_teza > 30:
            sez.append(trenutna_pot)
            skupna_teza = teza
            trenutna_pot = [darilo]
        else:
            skupna_teza += teza
            trenutna_pot.append(darilo)
    sez.append(trenutna_pot)
    return sez

# Vročinski valovi
#
# Meteorologi na ARSO so vas prosili za pomoč pri obdelavi meritev. Zanimajo
# jih vročinski valovi v Ljubljani. Poslali so vam dve datoteki: eno z dnevnimi
# povprečnimi temperaturami zraka in eno s temperaturami v tleh na različnih
# globinah. Datoteki vsebujeta meritve od 29.7.1992 do 31.12.2016.
# =====================================================================@033013=
# 1. podnaloga
# Datoteka s temperaturami zraka vsebuje dva stolpcea: datum in temperaturo
# zraka. Datoteka s temperaturami vsebuje štiri stolpce: leto, mesec, dan in
# temperaturo tal na globini 50 cm. Vrstice v obeh datotekah se časovno
# ujemajo.
# 
# Primer začetka datoteke s temperaturami zraka:
# 
#       datum,temp
#       29/07/1992,20.9
#       30/07/1992,22.8
#       31/07/1992,26
#       01/08/1992,26.6
#       02/08/1992,25.1
#       03/08/1992,26.2
#       04/08/1992,23.5
#       05/08/1992,23.1
#       06/08/1992,24.7
#       07/08/1992,25.6
#       08/08/1992,25.5
#       09/08/1992,26.5
#       10/08/1992,22.9
#       11/08/1992,21.1
#       12/08/1992,21.8
#       13/08/1992,22.3
#       14/08/1992,23.1
#       15/08/1992,18.9
#       16/08/1992,21
# 
# Primer začetka datoteke s temperaturami tal:
# 
#       leto,mesec,dan,Ttla50cm
#       1992,7,29,22.4
#       1992,7,30,22.6
#       1992,7,31,22.8
#       1992,8,1,23.5
#       1992,8,2,24
#       1992,8,3,24.1
#       1992,8,4,24.3
#       1992,8,5,24.1
#       1992,8,6,23.9
#       1992,8,7,24.1
#       1992,8,8,24.3
#       1992,8,9,24.5
#       1992,8,10,24.6
#       1992,8,11,23.9
#       1992,8,12,23.7
#       1992,8,13,23.4
#       1992,8,14,23.6
#       1992,8,15,23.4
#       1992,8,16,22.5
# 
# Napišite funkcijo `temperature(vhodna_zrak, vhodna_tla)`, ki sprejme ime
# datoteke, kjer so podatki o temperaturah zraka in ime datoteke, kjer so
# podatki o temperaturah tal.
# 
# Funkcija naj vrne nabor (*tuple*) z dvema elementoma. Prvi element naj bo
# Numpy seznam datumov v obliki niza dd/mm/yyyy (kot so v datoteki s
# temperaturami zraka). Drugi element naj bo Numpy tabela, kjer so v prvem
# stolpcu meritve temperature zraka in v drugem stolpcu meritve temperature
# tal na globini 50 cm. Elementi te tabele naj bodo tipa *float*. Primer:
# 
#     >>> temperature("zrak.txt", "tla.txt")
#       (
#           ['29/07/1992', '30/07/1992', '31/07/1992', ..., '29/12/2016',
#            '30/12/2016', '31/12/2016']
#           [[20.9, 22.4],
#            [22.8, 22.6],
#            [26. , 22.8],
#            ...,
#            [-0.5,  3.3],
#            [-2.9,  3.2],
#            [-3.5,  3.1]]
#       )
# 
# Pri tej podnalogi lahko uporabljate zanke, pri drugi in tretji podnalogi
# pa ne.
# =============================================================================
import numpy as np


def temperature(vhodna_zrak, vhodna_tla):
    datumi = []
    tempzrak = []
    temptla50 = []

    with open(vhodna_zrak, encoding="utf-8") as filezrak:
        vsebina = filezrak.readlines()

        for line in vsebina[1:]:
            vrstica = line.strip().split(",")
            datumi.append(vrstica[0])
            tempzrak.append(float(vrstica[1]))

    with open(vhodna_tla, encoding="utf-8") as filetla:
        vsebina = filetla.readlines()

        for line in vsebina[1:]:
            vrstica_tla = line.strip().split(",")
            temptla50.append(float(vrstica_tla[3]))

    return np.array(datumi), np.array([tempzrak, temptla50]).T


# =====================================================================@033500=
# 2. podnaloga
# Vročinski val v Ljubljani definirajo kot obdobje, ko je izmerjena povprečna
# dnevna temperatura zraka višja od 24.0°C tri dni zapored ali dlje. Vaša naloga
# je, da določite začetke vročinskih valov.
# 
# Napišite funkcijo `valovi(nabor)`, ki sprejme tak nabor, kot ga vrne funkcija
# temperature iz prejšnje podnaloge (z datumi in meritvami). Funkcija
# `valovi(nabor)` naj vrne Numpy seznam datumov začetkov vročinskih valov.
# (to je prvi datum, ko je preseženih 24.0°C v posameznem vročinskem valu,
# ki traja vsaj tri zaporedne dni). Primer:
# 
#      >>> valovi(temperature("zrak.txt", "tla.txt"))
#      ['31/07/1992' '06/08/1992' '18/08/1992' ... '30/06/2016' '08/07/2016' '20/07/2016']
# 
# **Uporaba zank pri tej podnalogi ni dovoljena. Če podnalogo rešite z zankami,
# lahko dosežete le polovico možnih točk.**
# *Namig:* Pomaga vam lahko funkcija
# [roll](https://numpy.org/doc/stable/reference/generated/numpy.roll.html).
# =============================================================================
def valovi(nabor):
    datumi, temps = nabor[0], nabor[1]
    tempzrak = temps[:, 0]
    maska = (
        (np.roll(tempzrak, 1) <= 24.0)
        * (tempzrak > 24.0)
        * (np.roll(tempzrak, -1) > 24.0)
        * (np.roll(tempzrak, -2) > 24.0)
    )
    return datumi[np.flatnonzero(maska)]


# =====================================================================@033501=
# 3. podnaloga
# Agrometeorologe zanima še, kako vročinski valovi vplivajo na temperaturo tal,
# ker to vpliva na rast rastlin. Ker jih zanima, kako se običajno spreminja
# temperatura v tleh, vas prosijo, da temperature tal povprečite po
# vročinskih valovih.
# 
# Napišite funkcijo `povprecja(nabor)`, ki sprejme tak nabor, kot pri prejšnji
# podnalogi (z datumi in meritvami). Funkcija naj vrne nabor, ki vsebuje tri
# števila: povprečno temperaturo tal na globini 50 cm na dan začetka vročinskega
# vala, naslednji dan in še na dan za tem. Poenostavljen primer:
# 
#      >>> povprecja((['01/08/1992', '02/08/1992', '03/08/1992',
#                      '04/08/1992', '05/08/1992', '06/08/1992',
#                      '07/08/1992', '08/08/1992', '09/08/1992'],
#                    [[ 15, 12 ],
#                     [ 25, 8 ],
#                     [ 26, 10 ],
#                     [ 25, 11 ],
#                     [ 19, 10 ],
#                     [ 26, 12 ],
#                     [ 26, 11 ],
#                     [ 26, 11 ],
#                     [ 22, 10 ]))
#      (10.0, 10.5, 11.0)
# 
# **Uporaba zank pri tej podnalogi ni dovoljena. Če podnalogo rešite z zankami,
# lahko dosežete le polovico možnih točk.**
# =============================================================================
def povprecja(nabor):
    datumi, temps = nabor[0], nabor[1]
    tempzrak = temps[:, 0]
    temptla = temps[:, 1]
    maska = (
        (np.roll(tempzrak, 1) <= 24.0)
        * (tempzrak > 24.0)
        * (np.roll(tempzrak, -1) > 24.0)
        * (np.roll(tempzrak, -2) > 24.0)
    )
    indeksi = np.flatnonzero(maska)

    povp1 = np.sum(temptla[indeksi]) / len(indeksi)
    povp2 = np.sum(temptla[indeksi + 1]) / len(indeksi)
    povp3 = np.sum(temptla[indeksi + 2]) / len(indeksi)

    return (povp1, povp2, povp3)

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3. IZPIT 2022/2023:
# Tajni agent Hinko
#
# Tajni agent Hinko je prišel na FMF raziskat primer preprodaje zapiskov. Ker pa 
# je agent res tajen, dogajanje spremlja le preko prisluškovalnih naprav, ki so 
# skrite povsod na FMF (bodite previdni kaj počnete, Hinko posluša!)
# =====================================================================@033019=
# 1. podnaloga
# Ker je Hinko v vas prepoznal zaveznika, se je odločil, da mu boste koristna
# pomoč. Najprej mu napišite funkcijo `dodeli_besedilo`, ki sprejme seznam besedil,
# torej seznam seznamov nizov in vse osebe, ki so bile poslušane. Vrne pa slovar,
# kjer se kot ključ nahaja ime osebe, njegova vrednost pa je besedilo, ki ga je 
# oseba v tem dnevu sproducirala. Hinko vam pove, da vsaka oseba vsaj enkrat 
# omeni svoje ime, ostalih imen pa nikoli ne omenja. Bodite pozorni, saj naprava
# ne zna zaznavati velikih in malih črk, prav tako ne zaznava ločil. 
# 
# Primer:
# 
#       >>> besedila = [
#                  ['aha imam ga', 'ni lahko biti cene sploh če imaš rad ananas'], 
#                  ['kod se obiraš ti ananas', 'jaz sem bine', 'pojdi'],
#                  ['hahaha', 'tole bo pa drago', 'mami me kliče ana prijatelji pa ananas', 'grem']                  
#                      ]
#       >>> osebe = ['Ana', 'Cene', 'Bine']
#       >>> dodeli_besedilo(besedila, osebe)
#       {
#           'Ana': ['hahaha', 'tole bo pa drago', 'mami me kliče ana prijatelji pa ananas', 'grem'], 
#           'Cene': ['aha imam ga', 'ni lahko biti cene sploh če imaš rad ananas'], 
#           'Bine': ['kod se obiraš ti ananas', 'jaz sem bine', 'pojdi']
#       }
# =============================================================================
def dodeli_besedilo(besedila, osebe):
    slovar = {}
    for oseba in osebe:
        for besedilo in besedila:
            for stavek in besedilo:
                if oseba.lower() in stavek.lower().split(" "): # ne pozabiti ločiti vsake besede, da po njih preverjaš
                    slovar[oseba] = besedilo
    return slovar





# =====================================================================@033020=
# 2. podnaloga
# V analizi stavkov Hinko ni opazil ničesar spornega, le da se določene besede
# pojavljajo povsem izven konteksta. Ugotovil je, da so te besede v resnici kode
# za prepovedane zapiske. Prosi vas, da napišete funkcijo `najdi_kodo`, ki bo 
# sprejela slovar, kakršnega vrača zgornja funkcija in bo vrnila domnevno kodo.
# Koda je beseda, ki se v vseh besedilih najpogosteje pojavi.
# 
# Primer: 
# 
#       >>> slovar = {
#           'Ana': ['hahaha', 'tole bo pa drago', 'mami me kliče ana prijatelji pa ananas', 'grem'], 
#           'Cene': ['aha imam ga', 'ni lahko biti cene sploh če imaš rad ananas'], 
#           'Bine': ['kod se obiraš ti ananas', 'jaz sem bine', 'pojdi']
#       }
#       >>> najdi_kodo(slovar)
#       "ananas"
# =============================================================================
def najdi_kodo(slovar):
    pop_besede = {}
    for ime, besedilo in slovar.items():
        for stavek in besedilo:
            for beseda in stavek.lower().split(" "): # ne pozabiti ločiti vsake besede, da po njih preverjaš
                pop_besede[beseda] = pop_besede.get(beseda, 0) + 1
    
    naj_kljuc = max(pop_besede, key=pop_besede.get)
    return naj_kljuc # iščemo ključ/besedo

# če bi ga urejal po št. : urejen = sorted(slovar.items())

# Uradna rešitev:
# def najdi_kodo(slovar):
    frekvenca_besed = {}
    for _, besedila in slovar.items():
        for besedilo in besedila:
            besede = besedilo.lower().split(" ")
            for beseda in besede:
                frekvenca_besed[beseda] = frekvenca_besed.get(beseda, 0) + 1
    return max(frekvenca_besed.items(), key=lambda x: x[1])[0]



# =====================================================================@033021=
# 3. podnaloga
# Hinko se res ni motil in je z vašo pomočjo je našel prepovedane zapiske ter jih 
# predal naprej na disciplinsko komisijo. Da pa bodo lahko študente primerno
# kaznovali, je treba ugotoviti, kako so se preprodaje zapiskov vrstile. 
# Napišite funkcijo `preprodaja`, ki sprejme slovar, kakršnega vrača funkcija
# v prvi podnalogi in vrne vrstni red, torej seznam imen oseb, v kakršnem 
# vrstnem redu so zapiske preprodajali. Prvi je zapiske preprodal tisti, ki je
# prvi uporabil kodo (v prejšnjem primeru ananas), nato tisti, ki je kodo uporabil
# drugi in tako naprej. Stavki (elementi) v seznamu pri vsaki osebi predstavljajo 
# eno časovno enoto. Torej pri Cenetu je bil stavek 'aha imam ga' izrečen v prvi 
# časovni enoti, stavek 'ni lahko biti cene sploh če imaš rad ananas' pa v drugi 
# časovni enoti. Nobeni dve osebi ne uporabita kode v isti časovni enoti. Pav tako
# lahko predpostaviš, da nobena oseba ne uporabi kode v več časovnih enotah.
# 
# Primer:
# 
#       >>> osebe = {
#               'Ana': ['hahaha', 'tole bo pa drago', 'mami me kliče ana prijatelji pa ananas', 'grem'], 
#               'Cene': ['aha imam ga', 'ni lahko biti cene sploh če imaš rad ananas'], 
#               'Bine': ['kod se obiraš ti ananas', 'jaz sem bine', 'pojdi']
#             }
#       >>> preprodaja(osebe)
#       ['Bine', 'Cene', 'Ana']
# =============================================================================
def preprodaja(slovar):
    koda = najdi_kodo(slovar)
    sez = []
    for oseba, besedila in slovar.items():
        for i, besedilo in enumerate(besedila): # for indeks, vrednost in enumerate(seznam):... (indeks predstavlja št.)
            if koda in besedilo.split(" "):
                sez.append((i, oseba))
    sez.sort()
    vrstni_red = []
    for _, oseba in sez:
        vrstni_red.append(oseba)
    return vrstni_red

# Tunel
#
# V državi Tunelostan imajo težave s prehitro vožnjo. Ker je inflacija prizadela tudi njih, 
# si ne morejo privoščiti  radarjev, zato bodo na začetek in konec vseh tunelov namestili senzorje, ki merijo čas, ko vozila vstopijo 
# v tunel in ko iz njega iztopijo. Prekoračitev hitrosti bodo zaznali, če bo povprečna hitrost skozi tunel, izračunana po formuli
# 
# $$ \overline{v} = \frac{s}{t} $$
# 
# večja kot največja dovoljena. V formuli je $s$ dolžina tunela in $t$ čas vozila v tunelu.
# Predpostavite lahko, da je vsako vozilo v tunelu vsaj 1 sekundo in manj kot 1 dan.
# =====================================================================@032998=
# 1. podnaloga
# Sestavite funkcijo `ure`, ki sprejme čas prihoda vozila v tunel in čas izhoda iz njega ter vrne število ur, porabljenih v tunelu, 
# zaokroženih na pet decimalk.
# Čas je predstavljen z nizom `'ure:minute:sekunde'`.
# 
#     >>> ure('15:10:00', '16:40:00')
#     1.5
#     >>> ure('14:40:00', '16:30:30')
#     1.84167
#     >>> ure('23:50:00', '00:00:00')
#     0.16667
# 
# <em>Namig:</em> Časovno razliko lahko izračunate ročno, ali pa uporabite paket [datetime](https://pynative.com/python-get-time-difference/#h-example-calculate-time-difference-in-python).
# =============================================================================
def ure(prihod, odhod):
    h1, m1, s1 = map(int, prihod.split(':'))
    h2, m2, s2 = map(int, odhod.split(':'))

    t1 = h1 * 3600 + m1 * 60 + s1
    t2 = h2 * 3600 + m2 * 60 + s2

    # če je odhod čez polnoč
    if t2 < t1:
        t2 += 24 * 3600

    razlika_v_urah = (t2 - t1) / 3600
    return round(razlika_v_urah, 5)



# Uradna rešitev:
# def ure(str1, str2):
    sez1 = str1.split(':')
    sez2 = str2.split(':')
    cas1 = 0
    cas2 = 0
    for i in range(3):
        cas1 += int(sez1[i]) / (60 ** i)
        cas2 += int(sez2[i]) / (60 ** i)
    razlika = cas2 - cas1
    if razlika > 0:
        return round(razlika, 5)
    else:
        return round(24 - cas1 + cas2, 5)

# =====================================================================@032999=
# 2. podnaloga
# V Tunelostanu za vsak tunel podatke shranjujejo v dve datoteki, v eni se merijo časi, ob katerih vozila pridejo v tunel, 
# v drugi pa časi, ob katerih iz njega izstopijo.
# 
# Za tunel, dolg 10km z omejitvijo hitrosti 100km/h, so vhodni časi shranjeni v `vhod.txt`, izhodni pa v `izhod.txt`.
# 
# `vhod.txt`
# 
#     00:00:00
#     00:12:40
#     00:55:01
# 
# `izhod.txt`
# 
#     00:05:50
#     00:22:02
#     01:00:01
# 
# Predpostavimo, da se vozila v tunelu ne prehitevajo. To pomeni, da je prvo vozilo vstopilo v tunel ob času `00:00:00`
# in izstopilo ob `00:05:50`, drugo je vstopilo ob `00:12:40` in iztopilo ob `00:22:02` in tako naprej.
# 
# Napišite funkcijo `krsitelji`, ki sprejme imeni datotek meritev, dolzino tunela v kilometrih in pa omejitev hitrosti v kilometrih na uro ter naredi 
# novo datoteko `krsitelji.txt`, v kateri je v vsaki vrstici napisano `False`, če vozilo v pripadajoči vrstici ni prekoračilo hitrosti, ali `True`, če je.
# 
# Če bi torej pognali ukaz
# 
#     >>> krsitelji('vhod.txt', 'izhod.txt', 10, 100)
#     
# bi se nam morala ustvariti datoteka `krsitelji.txt` z vsebino
# 
#     True
#     False
#     True
# =============================================================================
def krsitelji(vhod_ime, izhod_ime, dolzina, omejitev):
    with open(vhod_ime, 'r') as vhod:
        vhod_vsebina = vhod.readlines()
    with open(izhod_ime, 'r') as izhod:
        izhod_vsebina = izhod.readlines()
    with open('krsitelji.txt', 'w') as krsitelji:
        for j in range(len(vhod_vsebina)): # oštevilčimo vrstice in po njih gremo
            vhod_cas = vhod_vsebina[j].strip() # .strip() znebimo \n na koncu vrstice, če le-ti so tam
            izhod_cas = izhod_vsebina[j].strip()
            prehitro = (dolzina / ure(vhod_cas, izhod_cas) > omejitev) # vrne true/false
            print(prehitro, file=krsitelji)


# =====================================================================@033000=
# 3. podnaloga
# A v Tunelostanu še niso obupali nad radarji, zato bodo nov sistem uporabili za varčevanje za nakup radarjev.
# Vsako vozilo, ki prekorači omejitev hitrosti za $ x \ \texttt{km/h} $, plača državi kazen $ x * 5 \ \texttt{TSD} $ (tunelostanskih dolarjev), 
# en radar pa stane $ 100 \ \texttt{TSD} $.
# 
# Meritve vhodnih in izhodnih časov so združili v eno datoteko, ki se začne z vrstico `dolžina,omejitev`,
# ki ji sledi nekaj vrstic časov vstopov v tunel in zatem še enako število vrstic časov izstopov iz tunela. 
# Primer take datoteke je `meritve.txt`:
# 
#     10,100
#     00:00:00
#     00:12:40
#     00:55:01 
#     00:05:50
#     00:22:02
#     01:00:01
# 
# Napišite funkcijo `radar`, ki sprejme zgoraj opisano datoteko meritev, ter vrne število radarjev, ki jih je moč kupiti 
# z denarjem, dobljenim iz kazni za vozila, zabeležena v tej datoteki.
# 
#     >>> radar('meritve.txt'):
#     1
# =============================================================================
def radar(ime_meritve):
    with open(ime_meritve, 'r') as meritve:
        vrstice = meritve.readlines()
    vrstica = vrstice.pop(0).strip().split(',') # .pop(0) - odstrani prvo vrstico; Odstrani prvo vrstico iz seznama vrstice in jo shrani v vrstica
    dolzina, omejitev = int(vrstica[0]), int(vrstica[1])
    kazni = 0
    stevilo = int(len(vrstice) / 2) # razdeli podatke na pol
    for i in range(stevilo):
        vhod_cas = vrstice[i].strip()
        izhod_cas = vrstice[i + stevilo].strip()
        v = dolzina / ure(vhod_cas, izhod_cas) # hitrost
        if v > omejitev:
            kazni += (v - omejitev) * 5
    return kazni // 100 # koliko radarjev, če en stane 100

# Hribolazec
#
# Hribolazec Ferdinand se zelo rad sprehaja po gorah. Letos je za rojstni dan 
# dobil zemljevid gorovja, ki si ga letos želi obiskati. 
# 
# Pri tej nalogi je uporaba zank prepovedana. Če nalogo rešite z zankami,
# lahko dosežete le polovico možnih točk.
# =====================================================================@033004=
# 1. podnaloga
# Ker mu je zemljevid podaril njegov prijatel fizik Franc, ga ne razume najbolje,
# saj mu je zemljevid podaril v obliki 2d numpy arraya, kjer so zapisane samo 
# nadmorske višine na posamezni točki. Zmedeni Ferdinant te prosi za pomoč, da 
# mu pomagaš najti vrhove. Napišite funkcijo `vrhovi(zemljevid)`, ki sprejme 
# `zemljevid`, ki je 2d array, ki vsebuje nadmorske višine in vrne indekse kje 
# se nahajajo vrhovi (urejen par, na prvem mestu je array indeksov vrstic, na
# drugem mestu je array indeksov stolpcev). Vrh je točka, ki je višja od vseh 
# svojih sosedov (sever, jug, vzhod, zahod) in je višja od 1200. Če točka v 
# arrayu soseda na kakšni strani nima, naj pogleda le ostale sosede.  
# 
# Primer:
# 
#     Z = np.array([
#       [1201, 300,  400],
#       [900,  2000, 500],
#       [1000, 100,  100]
#     ])
#     >>> vrhovi(Z)
#     (array([0, 1]), array([0, 1]))
# 
# *Namig*: Prav vam lahko pride naloga `iskanje po tabelah` iz sklopa numpy in 
# funkcija `np.nonzero`.
# =============================================================================
import numpy as np
def vrhovi(zemljevid):
    zemljevid = np.pad(zemljevid, ((1, 1), (1, 1)), "minimum")
    zemljevid_sever = np.roll(zemljevid, 1, axis=1) # roll - zavrtiš po axis v obe smeri
    zemljevid_jug = np.roll(zemljevid, -1, axis=1)
    zemljevid_vzhod = np.roll(zemljevid, 1, axis=0)
    zemljevid_zahod = np.roll(zemljevid, -1, axis=0)
    kandidati = (zemljevid > zemljevid_jug) * (zemljevid > zemljevid_sever) * (zemljevid > zemljevid_vzhod) * (zemljevid > zemljevid_zahod)
    return np.nonzero(((zemljevid > 1200) * kandidati)[1:, 1:])



# =====================================================================@033005=
# 2. podnaloga
# Zdaj ko ve, kje so vrhovi in koliko jih je, ga zanima, ali lahko 
# obišče vse v enem kosu. Prijatelj Franc mu je povedal, da po zakonu o 
# ohranitvi energije, ni pomembna pot, ampak le začetno in končno stanje.
# povedal mu je, da se energija, ki jo porabi izračuna po formuli:
# $$ W_p = m * g * \Delta h $$
# Napišite funkcijo `do_kam_pride(zemljevid, m, W)`, ki sprejme `zemljevid`
# tako kot zgoraj, maso Ferdinanda `m` in energijo `W`, ki jo ima Ferdinad
# na dan hribolazenja. Za gravitacijski pospešek `g` uporabite kar točno 
# vrednost $g = \pi^2$. Funkcija naj vrne indeks, do katerega vrha po vrsti 
# lahko pride (če višine uredimo po velikosti). Če ne more priti niti do 
# prvega vrha, naj funkcija ne vrne ničesar. Ferdinand začne na nadmorski 
# višini 0.
# 
# Primer:
# 
#     Z = np.array([
#       [1201, 300,  400],
#       [900,  2000, 500],
#       [1000, 100,  100]
#     ])
#     # Vrhovi po velikosti so: 1201, 2000
#     >>> do_kam_pride(Z, 80, 1000000)
#     0
#     >>> do_kam_pride(Z, 80, 10)
#     None
# 
# *Namig:* Prav vam lahko pride funkcija `np.sort`.
# =============================================================================
import numpy as np
def do_kam_pride(zemljevid, m, W):
    vr = np.sort(zemljevid[vrhovi(zemljevid)]) # najdemo mesta, kjer so vrhovi
    energija = vr * np.pi ** 2 * m
    indeksi = np.flatnonzero(energija < W) # np.flatnonzero() vrne indekse vseh elementov, kjer je pogoj True.
    if len(indeksi):
        return indeksi[-1]


# =====================================================================@033006=
# 3. podnaloga
# Ferdinand je hitro ugotovil, da fizika deluje le v teoriji. Ali pa je samo 
# narobe razumel prijateljev zemljevid? Izkazalo se je, da velja slednje, saj
# mu je prijatelj zaupal, da je zemljevid samo profil gora z njegovega okna, 
# števila pa v resnici predstavljajo višinsko razliko med postojankami na poti.
# Napišite funkcijo `dejansko(zemljevid)`, ki sprejme `zemljevid` tako kot 
# zgoraj, vrne pa višine vseh koč na poti na najvišjo goro. Predpostavite,
# da nista nobeni dve gori enako visoki.
# 
# Primer:
# 
#     Z = np.array([
#       [1201, 300,  400, 1],
#       [900,  2000, 500, 1],
#       [1000, 100,  100, 1]
#     ])
#     >>> dejansko(Z)
#     array([1000, 1900, 3101])
# 
# Dodatna pojasnila: prvi stoplec predstavlja prvo goro, ki ima na višini 1000 
# prvo kočo, na 1900 (= 1000 + 900) drugo kočo in na 3101 (= 1000 + 900 + 1201) 
# vrh, kar je tudi najvišji vrh.
# 
# *Namig:* Uporabne so funkcije `np.flip`, `np.cumsum`, `np.reshape`.
# =============================================================================
import numpy as np

def dejansko(zemljevid):
    zemljevid = np.flip(zemljevid, axis=0) # zamenjamo vrstice stolpce
    visine = np.cumsum(zemljevid, axis=0) # seztejemo po novih vrsticah
    stolpec = np.nonzero(visine == np.max(visine))[1] # stolpec je seznam ali array vseh stolpcev, kjer se pojavi največja vrednost v visine
    pravi = visine[:, stolpec]
    return np.reshape(pravi, (pravi.size,))

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1. IZPIT 2023/24 - 30. 1. 2024:
# Prehrana
#
# Raziskovalci zbirajo podatke o prehrani ljudi. V ta namen so kolegi s FRI 
# razvili program, ki s fotografije embalaže izdelka prebere število kalorij, 
# količino beljakovin, ogljikovih hidratov itd. Program vrne niz s prebranim
# besedilom. Naša naloga je, da iz teh podatkov ugotovimo, koliko hranil je 
# nekdo zaužil.
# =====================================================================@039958=
# 1. podnaloga
# Napišite funkcijo `izdelek(niz)`, ki sprejme niz, ki vsebuje podatke
# o energijski vrednosti izdelka in količini hranil na 100 g izdelka. Pari imen 
# količin in vrednosti so med seboj ločeni s podpičji. Funkcija naj vrne slovar 
# kjer so ključi imena količin, vrednosti pa energija oz. masa hranil.
# 
# **Primera**:
# 
#     >>> izdelek("energijska vrednost - 401 kcal; maščobe - 4 g; ogljikovi hidrati - 83 g; vlaknine - 4 g; beljakovine - 8 g; sol - 1 g")
#     {'energijska vrednost': '401 kcal', 'maščobe': '4 g', 'ogljikovi hidrati': '83 g', 'vlaknine': '4 g', 'beljakovine': '8 g', 'sol': '1 g'}
#     
#     >>> izdelek("energijska vrednost - 401 kcal; vlaknine - 4 g")
#     {'energijska vrednost': '401 kcal', 'vlaknine': '4 g'}
# =============================================================================
def izdelek(niz):
    parov = niz.split("; ")  # Razdelimo niz na posamezne pare, ločene s podpičjem
    rezultat = {}
    for par in parov: # Za vsak par razdelimo na ime hranila in vrednost, ter ju dodamo v slovar
        ime, vrednost = par.split(" - ")
        rezultat[ime] = vrednost
    
    return rezultat



# =====================================================================@039960=
# 2. podnaloga
# Prostovoljci so v raziskavi fotografirali veliko izdelkov. Da bomo lahko
# določili, koliko hranil je nekdo zaužil, bomo najprej pripravili slovar,
# ki vsebuje imena izdelkov in podatke o njih.
# 
# Napišite funkcijo `sestavi_slovar(nizi, imena)`, ki sprejme seznam nizov s
# podatki o izdelkih `nizi` (posamezen niz je tak kot pri prejšnji podnalogi) 
# in seznam pripadajočih imen izdelkov `imena`. Funkcija naj vrne slovar, kjer
# so ključi imena izdelkov, vrednosti pa slovarji s podatki o izdelkih v taki
# obliki kot pri prejšnji podnalogi. V tem slovarju naj bodo količine hranil 
# in energijska vrednost cela števila (tip int). Predpostavite lahko, da so
# vsa števila cela (zaokroževanje ni potrebno). Enote spustimo.
# 
# **Kratek primer**:
# 
#     >>> nizi = ["energijska vrednost - 401 kcal; maščobe - 4 g", 
#                 "energijska vrednost - 64 kcal; maščobe - 3 g"]
#     >>> sestavi_slovar(nizi, ["kosmiči", "mleko"])
#     {'kosmiči': {'energijska vrednost': 401, 'maščobe': 4}, 
#      'mleko': {'energijska vrednost': 64, 'maščobe': 3}}
# =============================================================================
def sestavi_slovar(nizi, imena):
    slovar = {}
    for i, niz in enumerate(nizi):
        podatki = {}
        hranila = niz.split(";") # Razdelimo niz na posamezne hranilne informacije

        for hranilo in hranila: # Razdelimo vsako hranilno informacijo na ime in vrednost
            ime, vrednost = hranilo.split(" - ")
            podatki[ime.strip()] = int(vrednost.strip().split()[0])   # Vrednost pretvorimo v celo število
        slovar[imena[i]] = podatki # Povežemo ime izdelka z njegovimi podatki
    
    return slovar



# =====================================================================@039959=
# 3. podnaloga
# Zanima nas koliko energije in mase hranil je nekdo zaužil v nekem obdobju.
# Sestavi funkcijo `vsota(zauziti_izdelki, kolicine, slovar)`, ki sprejme 
# seznam imen zaužitih izdelkov `zauziti_izdelki`, seznam mas zaužitih izdelkov 
# v gramih `kolicine` in slovar take oblike kot ga vrne prejšnja podnaloga 
# `slovar`. Funkcija naj vrne slovar skupne energijske vrednosti in skupnih mas 
# hranil v zaužitih izdelkih. Predpostavite lahko, da so vsi zaužiti izdelki
# v podanem slovarju. *Pozor*: količina hranil v slovarju je podana na 100 g 
# izdelka.
# 
# **Primer**:
# 
#     >>> vsota(["kosmici", "mleko"], [10, 100], slovar)
#     {'energijska vrednost': 104.1, 'maščobe': 4.4}
# =============================================================================
def vsota(zauziti_izdelki, kolicine, slovar):
    zauzito = {}
    for i, izdelek in enumerate(zauziti_izdelki):
        hranila = slovar[izdelek]  # Poiščemo hranilne vrednosti za trenutni izdelek v slovarju
        kolicina_grami = kolicine[i]  # Količina zaužitega izdelka v gramih
        
        for hranilo, vrednost in hranila.items(): # Če hranilo že obstaja v slovarju zauzito, ga seštejemo, sicer ga dodamo
            if hranilo in zauzito:
                zauzito[hranilo] += vrednost * (kolicina_grami / 100) # Pomnožimo hranila s faktorjem, ki je količina / 100, da dobimo vrednosti za trenutno maso
            else:
                zauzito[hranilo] = vrednost * (kolicina_grami / 100)

    return zauzito


#    zauzito = {}
    for i, izdelek in enumerate(zauziti_izdelki):
        hranila = slovar[izdelek]  # Poiščemo hranilne vrednosti za trenutni izdelek v slovarju
        kolicina_grami = kolicine[i]  # Izračunamo količino hranil glede na maso zaužitega izdelka
        for kol in len(hranila):
            hranila[kol] *= (kolicina_grami / 100)
        zauzito += hranila

    return zauzito

# Množenje
#
# Kolegi pedagogi so naveličani sestavljanja šolskih testov. Radi bi
# avtomatizirali sestavljanje in popravljanje nalog iz množenja števil.
# =====================================================================@039955=
# 1. podnaloga
# Napišite funkcijo `generiraj(pot, prvi_faktorji, drugi_faktorji)`, ki v
# datoteko, ki se nahaja na `pot`, zapiše po en račun v eno vrstico. Računi naj
# bodo produkti dveh celih števil. Prvo število naj bo element iz seznama
# `prvi_faktorji`, drugo število pa element iz seznama `drugi_faktorji` v takem
# vrstnem redu, kot so števila v seznamih. Med
# faktorjema naj bo znak `*` ter po en presledek levo in desno od zvezdice. Desno
# od drugega faktorja naj bo presledek in enačaj.
# 
# **Primer**: Če funkcijo pokličemo z argumenti
# 
#     >>> generiraj("datoteka.txt", [-10, 3, 0], [2, 5, 9])
# 
# naj bo vsebina datoteke `datoteka.txt` enaka
# 
#     -10 * 2 =
#     3 * 5 =
#     0 * 9 =
# =============================================================================
def generiraj(pot, prvi_faktorji, drugi_faktorji):
    with open(pot, 'w', encoding='utf-8') as file:
        for prvi_faktor, drugi_faktor in zip(prvi_faktorji, drugi_faktorji):
            # Oblikujemo račun v obliki "prvi_faktor * drugi_faktor ="
            racun = f"{prvi_faktor} * {drugi_faktor} =\n"
            # Zapišemo račun v datoteko
            file.write(racun)


# =====================================================================@039956=
# 2. podnaloga
# Sedaj moramo še oceniti rešitve učencev. Napišite funkcijo
# `preveri(pot)`, ki sprejme pot do datoteke z rešitvami učenca in vrne seznam
# True/False vrednosti, ki označujejo ali je posamezni račun pravilen.
# 
# **Primer**: Klic funkcije `preveri("datoteka.txt")` naj vrne
# `[False, True, False]`, če je vsebina datoteke `"datoteka.txt"` enaka
# 
#     -10 * 2 = 1
#     3 * 5 = 15
#     0 * 9 = -3
# =============================================================================
def preveri(pot):
    rezultati = []

    with open(pot, 'r', encoding='utf-8') as file:
        for vrstica in file:
            vrstica = vrstica.strip()
            if '*' in vrstica and '=' in vrstica:
                # Razdelimo vrstico na del, ki je pred '=' in del, ki je za '='
                del_izracun, rezultat = vrstica.split('=')
                
                # Razdelimo del izračuna na dve števili pred '*' in za '*' 
                prvi_faktor, drugi_faktor = del_izracun.split('*')
                
                # Očistimo števila od morebitnih presledkov
                prvi_faktor = int(prvi_faktor.strip())
                drugi_faktor = int(drugi_faktor.strip())
                rezultat = int(rezultat.strip())
                
                # Izračunamo pravi rezultat
                if prvi_faktor * drugi_faktor == rezultat:
                    rezultati.append(True)
                else:
                    rezultati.append(False)
    
    return rezultati



# =====================================================================@039957=
# 3. podnaloga
# Vsi učenci so pisali isti test, učitelja pa zanima katere račune so bolj
# uspešno reševali in katere manj. Napišite funkcijo
# `tezavnost(vhodne_poti, izhodna_pot)`, ki sprejme seznam imen datotek z
# rešitvami učencev `vhodne_poti` (npr. `["dat1.txt", "dat2.txt", "dat3.txt"]`).
# Funkcija naj v datoteko, katere ime je podano z `izhodna_pot`,
# zapiše račune urejene po vrsti od najbolje reševanega v prvi vrstici do
# najslabše reševanega v zadnji vrstici.
# 
# Predpostavite lahko, da je število učencev, ki so pravilno rešili posamezni
# račun, različno za vsak račun.
# 
# **Primer:** Vsebina izhodne datoteke po klicu funkcije `tezavnost`:
# 
#     3 * 5 =
#     0 * 9 =
#     -10 * 2 =
# =============================================================================
def preveri(pot):
    rezultati = []
    
    with open(pot, 'r', encoding='utf-8') as file:
        for vrstica in file:
            vrstica = vrstica.strip()
            
            if '*' in vrstica and '=' in vrstica:
                del_izracun, rezultat = vrstica.split('=')
                prvi_faktor, drugi_faktor = del_izracun.split('*')
                
                prvi_faktor = int(prvi_faktor.strip())
                drugi_faktor = int(drugi_faktor.strip())
                rezultat = int(rezultat.strip())
                
                if prvi_faktor * drugi_faktor == rezultat:
                    rezultati.append(True)
                else:
                    rezultati.append(False)
    
    return rezultati

def tezavnost(vhodne_poti, izhodna_pot):
    racuni = {}
    for pot in vhodne_poti:
        rezultati = preveri(pot)  # Preverimo rešitve v datoteki
        
        with open(pot, 'r', encoding='utf-8') as file: # Preberemo račune iz prve datoteke (tudi če so vsi enaki v vseh datotekah)
            for index, vrstica in enumerate(file):
                vrstica = vrstica.strip()
                del_izracun, rezultat = vrstica.split('=')
                del_izracun = del_izracun + '='
                
                if del_izracun not in racuni:
                    racuni[del_izracun] = 0

                if rezultati[index] == True: # Če je odgovor pravilen, povečamo število pravilnih rešitev
                    racuni[del_izracun] += 1
    
    # Urejamo račune glede na število pravih odgovorov (od največ do najmanj)
    urejeni_racuni = sorted(racuni.keys(), key=lambda x: racuni[x], reverse=True)
    
    with open(izhodna_pot, 'w', encoding='utf-8') as file: # Zapisujemo v izhodno datoteko
        for racun in urejeni_racuni:
            file.write(racun + '\n')
# Ocene
#
# Popravljalci izpitov so vas prosili za pomoč pri izračunu ocen.
# 
# POZOR: To nalogo rešujte z numpy. Če pri tej nalogi uporabljate zanke, lahko
# dosežete le polovico možnih točk!
# =====================================================================@039951=
# 1. podnaloga
# Napišite funkcijo `desetke(tocke, imena)`, ki sprejme numpy tabelo točk
# študentov in numpy tabelo njihovih imen. Funkcija naj vrne numpy tabelo
# študentov, ki so dosegli 90 točk ali več.
# 
# Tabela `tocke` je dvodimenzionalna. Posamezna vrstica vsebuje točke študenta
# pri desetih nalogah na izpitu. Prva vrstica ustreza prvemu študentu,
# druga drugemu, itd.
# 
# **Primer**:
# 
#     >>> tocke = np.array([[8, 7, 8, 10, 10, 4, 9, 3, 1, 6],
#                           [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
#                           [10, 9, 8, 7, 6, 5, 4, 3, 2, 5],
#                           [10, 10, 10, 10, 10, 10, 9, 8, 3, 10]])
#     >>> imena = np.array(["Aljaž Algebra", "Maja Metrika", "Nika Nihaj", "Urban Ulom"])
#     >>> desetke(tocke, imena)
#     ['Maja Metrika' 'Urban Ulom']
# =============================================================================
import numpy as np

def desetke(tocke, imena):
    skupne_tocke = tocke.sum(axis=1)
    uspešni_stud = skupne_tocke >= 90
    return imena[uspešni_stud]



# =====================================================================@039954=
# 2. podnaloga
# Ocenjevalci so se odločili, da bodo zadnjima dvema nalogama na izpitu dali manjšo težo.
# Popravljeno število točk `X` bodo izračunali z enačbo
# 
# $$X = 0.9 (a_1 + a_2 + a_3 + a_4 + a_5 + a_5 + a_6 + a_7 + a_8) + 0.1 (a_9 + a_{10}),$$
# 
# kjer je $a_i$ število doseženih točk pri posamezni nalogi kot so podane v tabeli `tocke`.
# 
# Napišite funkcijo `odstopanje(tocke, imena)`, ki sprejme enaki tabeli kot
# pri prejšnji nalogi in vrne ime študenta, ki po številu točk $X$ najbolj
# odstopa od povprečne vrednosti točk $X$. Predpostavite lahko, da je tak le en.
# 
# *Namig:* V pomoč vam bo morda funkcija [argmax](https://numpy.org/doc/stable/reference/generated/numpy.argmax.html)
# =============================================================================
import numpy as np
def odstopanje(tocke, imena):
    popravljenje_tocke = 0.9 * tocke[:, :8].sum(axis=1) + 0.1 * tocke[:, 8:].sum(axis=1)
    povprecje = popravljenje_tocke.mean()
    

    odstopanja = np.abs(popravljenje_tocke - povprecje)
    indeks_max_odstopanja = np.argmax(odstopanja)

    return imena[indeks_max_odstopanja]

    
    
    
#    skupne_tocke = 0
    for i in range(0, 7):
        skupne_tocke += 0.9 * i
    for i in range(8, 9):
        skupne_tocke += 0.1 * i

    uspešni_stud = skupne_tocke >= 90
    return imena[uspešni_stud]



# =====================================================================@039953=
# 3. podnaloga
# Zanima nas še, katere naloge so bile najuspešneje reševane. Napišite funkcijo
# `uspehi(tocke)`, ki sprejme enako tabelo točk kot pri prejšnji nalogi.
# Funkcija naj vrne numpy tabelo zaporednih številk nalog, pri katerih je vsaj
# tretjina študentov dosegla 9 ali 10 točk. Številke nalog se začnejo z 1.
# 
# **Primer**: Če je več kot tretjina študentov dosegla 9 ali 10 točk pri prvi,
# drugi in zadnji nalogi naj funkcija vrne
# 
#     [ 1 2 10]
# =============================================================================
import numpy as np

def uspehi(tocke):
    uspešni = tocke >= 9  # Boolean matrika, kjer je True, če je študent dosegel 9 ali 10
    uspešne_naloge = np.sum(uspešni, axis=0)  # Štetje True vrednosti po stolpcih (nalogah)
    
    # Izračunamo, katere naloge so bile rešene s strani vsaj tretjine študentov
    tretjina_stud = tocke.shape[0] / 3  # Število študentov, ki je potrebno za vsaj tretjino
    uspešne_naloge = np.where(uspešne_naloge >= tretjina_stud)[0] + 1  # Vrni naloge (številke od 1)
    
    return uspešne_naloge

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2. IZPIT 2023/24 - 11. 6. 2024:
# Obdelava besedila
#
# Ker vam študij še ne zagotavlja dovolj obveznosti, si zaželite dodatnega projekta.
# Napisati želite nekaj funkcij za avtomatsko obdelavo besedil.
# =====================================================================@039975=
# 1. podnaloga
# Napišite funkcijo `zamenjaj`, ki sprejme niz in dva seznama, vrne pa nov niz,
# kjer so črke iz prvega seznama zamenjane s črkami iz drugega seznama na istih indeksih.
# Pazite, da menjava velja tako za male kot za velike črke.
# 
#     >>> zamenjaj('Počakaj na Špelo!', ['č', 'ž', 'š'], ['c', 'z', 's'])
#     'Pocakaj na Spelo!'
# 
#     >>> zamenjaj('Obiskujem FDV.', ['d', 'v'], ['m', 'f'])
#     'Obiskujem FMF.'
# =============================================================================
def zamenjaj(niz, sez1, sez2):
    for i in range(len(sez1)):
        niz = niz.replace(sez1[i], sez2[i])
        niz = niz.replace(sez1[i].upper(), sez2[i].upper())
    return niz


# =====================================================================@039976=
# 2. podnaloga
# Napišite funkcijo `povedi`, ki sprejme niz z vsaj eno povedjo. Vsaka poved se konča s končnim
# ločilom: bodisi s piko, vprašajem ali klicajem. Funkcija naj vrne slovar, v katerem so
# ključi končna ločila v nizu, njihove vrednosti pa naj bodo seznami povedi, konec katerih so ta ločila.
# Povedi v seznamu naj bodo podana v takšnem vrstnem redu, kot so nanizana v nizu.
# 
#     >>> povedi('To je prva poved. Ta je DRUGA! Katera pa je ta poved? Haha.')
#     {'.': ['To je prva poved.', 'Haha.'],
#      '!': ['Ta je DRUGA!'],
#      '?': ['Katera pa je ta poved?']}
# 
#     >>> povedi('Vprašanje? Vzklik!')
#     {'?': ['Vprašanje?'],
#      '!': ['Vzklik!']}
# =============================================================================
def povedi(niz):
    slo = {}
    poved = '' # formiramo novo poved iz znakov
    for znak in niz:
        poved += znak
        if znak in ['.', '!', '?']: # ko najdemo ta znak izvedemo dodajanje v slovar
            if znak not in slo:
                slo[znak] = [poved.strip()]
            else:
                slo[znak].append(poved.strip()) # če še ni končno ločilo v slovarju
            poved = ''
    return slo


# =====================================================================@039977=
# 3. podnaloga
# Počasi imate zadosti pisanja nepotrebnih funkcij, a žal opazite, da vam prejšnja funkcija
# ne dela pravilno. Razlog je v tem, da ne razloči med piko kot končnim in nekončnim ločilom.
# Napišite funkcijo `pika`, ki sprejme niz, ki predstavlja odsek besedila. Začne in konča
# se s tremi pikami, vmes pa je natanko ena pika. Funkcija naj vrne `True`, če ta pika predstavlja
# končno ločilo, kar pomeni, da se z njo konča poved, in `False` sicer. Pika je končno ločilo,
# če je prvi naslednji znak, ki ni presledek, velika črka.
# 
#     >>> pika('... tu je konec povedi. Sledi nova poved ...')
#     True
# 
#     >>> pika('... se dobimo zvečer, npr. ob ...')
#     False
# 
#     >>> pika('... moj mail je janeznovak@gmail.com ...')
#     False
# =============================================================================
def pika(odsek):
    odsek = odsek[4:-4] # dobimo relevantno poved
    i = odsek.index('.') # da nam indeks znaka
    for j in range(i + 1, len(odsek)):
        znak = odsek[j] # preverjamo za naslednje znake
        if znak != ' ':
            if znak.isupper(): # iščemo veliko začetnico
                return True
            else:
                return False

# LPP
#
# Zjutraj zaspani na postaji čakate avtobus. Predavanje se vam začne čez 15 minut, avtobusa pa od nikjer.
# Avtobus standardno zamudi, vam prekipi in odločite se stvari vzeti v svoje roke. Odločite se prijaviti na
# delovno mesto vodje logistike na LPP. Do razgovora morate pripraviti naslednje funkcije.
# 
# Funkcije v tej nalogi se bodo preizkušale na spodaj opisani datoteki `linije_test.txt` in na `linije_lpp.txt`,
# kjer so podatki nekaterih LPP linij in ki si jo lahko ogledate na 
# tej [povezavi](https://ucilnica.fmf.uni-lj.si/pluginfile.php/148071/mod_resource/content/3/linije_lpp.txt).
# 
# `linije_test.txt`
# 
#     1
#     Sodisce
#     Knjiznica
#     Trg
#     Park
#     1A
#     Park
#     Trg
#     Gledalisce
#     2
#     Trgovina
#     Muzej
#     Sola
#     Gledalisce
# 
# V datoteki `linije_test.txt` so podatki za tri linije po imenih `1`, `1A` in `2`. Linija `1` ima začetno postajo `Sodisce`,
# naslednja postaja je `Knjiznica`, potem `Trg`, končna postaja pa je `Park`. Potem sledijo podatki za linijo `1A`.
# Predpostavite lahko, da se vsako ime linije začne s številko in da se vsako ime postaje začne s črko.
# Vsaka linija vozi v obe smeri.
# 
# V datoteki `linije_lpp.txt` so podatki nanizani v enaki obliki.
# =====================================================================@039969=
# 1. podnaloga
# Napišite funkcijo `linije`, ki sprejme ime vhodne datoteke in vrne slovar, v katerem so ključi
# linije in vrednosti seznam pripadajočih postaj v vrstnem redu, kot so napisane v vhodni datoteki.
# 
#     >>> linije('linije_test.txt')
# 
#     {'1': ['Sodisce', 'Knjiznica', 'Trg', 'Park'], 
#      '1A': ['Park', 'Trg', 'Gledalisce'], 
#      '2': ['Trgovina', 'Muzej', 'Sola', 'Gledalisce']}
# =============================================================================
def linije(ime_vhodne):
    with open(ime_vhodne, 'r', encoding='utf-8') as dat:
        vrstice = dat.readlines()
    slo = {}
    for vrstica in vrstice:
        vrstica = vrstica.strip() # odstarani končna ločila v datoteki \n...
        if vrstica[0].isnumeric(): # if vrstica[0] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']: 
            linija = vrstica
            slo[linija] = []
        else:
            slo[linija].append(vrstica) # če ni ime linije jo dodamo v seznam
    return slo


# =====================================================================@039970=
# 2. podnaloga
# Podatki v `linije_test.txt` in `linije_lpp.txt` so nekoliko nepregledni. Napišite funckijo `pregledno`, ki sprejme
# slovar oblike kot rezultat prejšnje naloge in ime izhodne datoteke, v katero linije in postajališča izpiše
# preglednejše. Vsaka vrstica naj predstavlja svojo linijo, ki se začne z imenom linije, nato pa naj bodo
# našteta postajališča, ločena s puščico. Zgleduj se po spodnjem primeru.
# 
#     slovar = {'1': ['Sodisce', 'Knjiznica', 'Trg', 'Park'], 
#            '1A': ['Park', 'Trg', 'Gledalisce'], 
#            '2': ['Trgovina', 'Muzej', 'Sola', 'Gledalisce']}
# 
# Po klicu `pregledno(slovar, 'linije_test_pregledno.txt')` naj bo ustvarjena datoteka `linije_test_pregledno.txt`
# z vsebino
# 
#     1: Sodisce -> Knjiznica -> Trg -> Park
#     1A: Park -> Trg -> Gledalisce
#     2: Trgovina -> Muzej -> Sola -> Gledalisce
# =============================================================================
def pregledno(slo, ime_izhoda):
    with open(ime_izhoda, 'w', encoding='utf-8') as dat:
        for (linija, postaje) in slo.items():
            dat.write(linija + ': ')        # dat.write(f'{linija}: ')
            for postaja in postaje[:-1]:
                dat.write(postaja + ' -> ') # dat.write(f'{postaja} -> ')
            dat.write(postaje[-1] + '\n')   # dat.write(f'{postaje[-1]}\n')


# =====================================================================@039971=
# 3. podnaloga
# Napišite funkcijo `obstaja_povezava`, ki sprejme slovar linij, začetno ter končno postajo
# in vrne `True`, če obstaja povezava od začetne do končne postaje z **največ enim** prestopom, sicer `False`.
# Če bodisi začetne ali končne postaje v slovarju ni, naj funkcija vrne `None`.
# 
#     >>> obstaja_povezava(slovar, 'Trgovina', 'Trg')
#     True
# 
#     >>> obstaja_povezava(slovar, 'Sodisce', 'Sola')
#     False
# 
#     >>> obstaja_povezava(slovar, 'Trg', 'Aaaaaa')
#     None
# =============================================================================
def obstaja_povezava(slo, zacetna, koncna):
    vse_postaje = []
    for postaje in slo.values():
        vse_postaje += postaje # zapišeno vse postaje v en seznam
    if (zacetna not in vse_postaje) or (koncna not in vse_postaje): # če postaje ne najdemo
        return None
    for postaje in slo.values():
        if zacetna in postaje:
            for prestopna_postaja in postaje:
                for postaje in slo.values():
                    if (prestopna_postaja in postaje) and (koncna in postaje):
                        return True
    return False

# Finance
#
# Po nekaj mesecih študija opazite, da je stanje na vašem bančnem računu nepričakovano nizko.
# Ker vas zanima, če je krivo pozno nakazilo štipendije ali pa preprosto pestro študijsko 
# življenje, se odločite napisati program za obdelavo financ.
# 
# Podatke o svojih financah hranite v tabeli, kjer je po vrsticah nanizan promet za posamezen
# mesec. Tabela
# 
#     tab = np.array([[-5.14,  5.00, 0     , 0    ], 
#                     [22.30, -0.50, -10.88, 15.00]])
# 
# predstavja promet za dva meseca, januar in februar. Januarja ste najprej porabili `5.14` evrov,
# nato pa `5` evrov dobili. Februarja so vaši prihodki bili `22.30` in `15.00` evrov, odhodki
# pa `0.5` in `10.88` evrov.
# 
# **POZOR**: Ta naloga je namenjena reševanju z modulom numpy. Če boste uporabljali zanke,
# lahko dosežete največ polovico možnih točk.
# =====================================================================@039972=
# 1. podnaloga
# Napišite funkcijo `najboljsi_mesec`, ki vzame tabelo zgornjega formata in vrne par (nabor), 
# kjer je na prvem mestu številka finančno najuspešnejšega meseca (`1` za januar, `2` za februar, ...), 
# na drugem pa stanje tega meseca.
# 
#     >>> najboljsi_mesec(tab)
# 
#     (2, 25.92)
# 
# Torej je bil februar najboljši mesec, ko je bilo stanje `22.30 - 0.50 - 10.88 + 15.00 = 25.92` evrov.
# 
# **Namig**: Prav vam lahko pride funkcija `np.argmax`.
# =============================================================================
import numpy as np
def najboljsi_mesec(tab):
    skupno = np.sum(tab, axis=1)
    najboljsi = np.argmax(skupno) # najboljši predstavlja indeks meseca kot vrstico
    return (najboljsi + 1, skupno[najboljsi]) 


# =====================================================================@039973=
# 2. podnaloga
# Za marec in naslednje mesece bi si želeli podatke avtomatsko dopisovati v tabelo.
# Napišite funkcijo `dodaj`, ki sprejme tabelo in **seznam** prometa za naslednji mesec.
# Vrne naj posodobljeno tabelo, torej z eno vrstico več.
# 
#     >>> dodaj(tab, [7.01, -5.14])
# 
#     [[ -5.14   5.     0.     0.  ]
#      [ 22.3   -0.5  -10.88  15.  ]
#      [  7.01  -5.14   0.     0.  ]]
# 
#     >>> dodaj(tab, [7.01, -5.14, -4.00, 15.00, 100.00])
# 
#     [[ -5.14   5.     0.     0.     0.  ]
#      [ 22.3   -0.5  -10.88  15.     0.  ]
#      [  7.01  -5.14  -4.    15.   100.  ]]
# =============================================================================
import numpy as np
def dodaj(tab, nov_promet):
    (n, m) = np.shape(tab)
    nov_n = n + 1
    nov_m = max(m, len(nov_promet)) # zapišemo nove dimenzije tabele
    tab_nov = np.zeros((nov_n, nov_m)) # ustvarimo prazno novo tabelo
    tab_nov[:-1, :m] = tab # dodamo prejšnjo tabelo v novo, (ker :-1 pomeni vse vrstice razen zadnje)
    tab_nov[-1, :len(nov_promet)] = np.array(nov_promet) # nov znesek damo v zadnjo vrsto
    return tab_nov


# =====================================================================@039974=
# 3. podnaloga
# Napišite še funkcijo `poracun`, ki sprejme tabelo finančnega prometa za `n` mesecev in vrne `(n+1) x 3` tabelo,
# kjer je v prvih `n` vrsticah v drugem stolpcu seštevek prihodkov za pozamezen mesec, v tretjem seštevek odhodkov,
# v prvem stolpcu pa naj bo stanje, torej vsota prihodkov in odhodkov. V zadnji vrstici naj bodo povprečja stanj,
# prihodkov in odhodkov po mesecih.
# 
#     >>> poracun(tab)
# 
#     [[ -0.14   5.    -5.14]
#      [ 25.92  37.3  -11.38]
#      [ 12.89  21.15  -8.26]]
# =============================================================================
import numpy as np
def poracun(tab):
    (n, m) = np.shape(tab)
    prihodki = np.where(tab > 0, tab, 0)
    odhodki = np.where(tab < 0, tab, 0)
    nov_tab = np.zeros((n + 1, 3))
    nov_tab[:-1, 1] = np.sum(prihodki, axis=1)
    nov_tab[:-1, 2] = np.sum(odhodki, axis=1)
    nov_tab[:-1, 0] = np.sum(nov_tab[:-1, 1:], axis=1)
    nov_tab[-1, :] = np.average(nov_tab[:-1, :], axis=0)
    return nov_tab

???%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3. IZPIT 2023/24 - 4. 9. 2024:
# Razgovor
#
# Želite se prijaviti na delovno mesto programerja. Na življenjepisu imate navedeno odlično
# znanje Pythona, zato vas na razgovoru presenetijo z naslednjimi nalogami.
# =====================================================================@040314=
# 1. podnaloga
# Napišite funkcijo `zdruzi_sezname(seznami)`, ki sprejme seznam seznamov ter vrne nov seznam, 
# ki vsebuje vse zaporedne elemente iz seznamov, vendar brez podvojenih vrednosti.
# Vrstni red elementov naj bo enak kot v izvornih seznamih.
# 
# Primer:
# 
#     >>> zdruzi_sezname([[1, 2, 3, 4], [3, 4, 5, 6], [10, 11]])
#     [1, 2, 3, 4, 5, 6, 10, 11]
# 
#     >>> zdruzi_sezname([['a', 'b', 'c'], ['c', 'd'], ['d', 'e']])
#     ['a', 'b', 'c', 'd', 'e']
# 
#     >>> zdruzi_sezname([['a', 'b']])
#     ['a', 'b']
# =============================================================================
def zdruzi_sezname(seznami):
    rezultat = []
    for seznam in seznami: # preverimo vsak seznam
        for element in seznam:
            if element not in rezultat: # če ga še ni notri ga dodaš
                rezultat.append(element)
    return rezultat


# =====================================================================@040315=
# 2. podnaloga
# Napišite funkcijo `prestej_samoglasnike(seznam)`, ki bo sprejela seznam nizov in bo vrnila slovar, kjer so ključi
# samoglasniki (male črke), vrednosti pa število njihovih ponovitev v vseh nizih skupaj. Pazite na
# male in velike črke, štejejo se skupne ponovitve.
# 
#     >>> prestej_samoglasnike(["Hello, world!", "Pozdravljen, svet!"])
#     {'a': 1, 'e': 3, 'i': 0, 'o': 3, 'u': 0}
# 
#     >>> prestej_samoglasnike(["HELLO, WORLD!", "Pozdravljen, svet!"])
#     {'a': 1, 'e': 3, 'i': 0, 'o': 3, 'u': 0}
# 
# **Opomba**: Samoglasniki so a, e, i, o in u.
# =============================================================================
def prestej_samoglasnike(seznami):
    slovar = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0} # predhodno nastavimo slovar
    for niz in seznami:
        for znak in niz.lower(): # vedno niz pretvorimo v male črke
            if znak in slovar:
                slovar[znak] += 1
    return slovar


# =====================================================================@040339=
# 3. podnaloga
# Napišite funkcijo `indeks(seznam, rezine)`, ki sprejme seznam `seznam` in seznam podseznamov `rezine`. 
# Funkcija naj za vsak podseznam poišče indeks, na katerem se ta podseznam začne
# v seznamu `seznam`. Če podseznam v seznamu ne obstaja ali pa je podseznam prazen, naj bo indeks tega podseznama `-1`. 
# Funkcija naj vrne seznam indeksov, ki ustrezajo pozicijam posameznih podseznamov v seznamu `seznam`.
# 
#     >>> indeks([1, 2, 3, 4, 5], [[1, 2], [3, 4, 5]])
#     [0, 2]
# 
#     >>> indeks([1, 2, 3, 4, 5], [[1, 2], [3, 5], [], [5]])
#     [0, -1, -1, 4]
# =============================================================================
def indeks(seznam, rezine):
    
    indeksi = []
    trenutni_indeks = -1
    for rezina in rezine:

        for i in range(len(seznam) - len(rezina) + 1): # kako dolgo iščemo številko
            if seznam[i:(i + len(rezina))] == rezina: # ali se rezina ujema tisti, ki je napisana
                trenutni_indeks = i
        if len(rezina) == 0:
            indeksi.append(-1)
        else:
            indeksi.append(trenutni_indeks)
        trenutni_indeks = -1

    return indeksi

# Drevesna debla
#
# V prečnih presekih debel dreves so vidne temne črte, ki jih imenujemo letnice 
# ([slika](https://commons.wikimedia.org/wiki/File:Tilia_tomentosa_coupe_MHNT.jpg)). 
# Obroči so posledica sprememb v hitrosti rasti.
# Vsaka temna črta praviloma označuje eno leto rasti drevesa. Hitrost rasti
# drevesa je odvisna od vremenskih pogojev, zato nam širina
# obročev podaja informacije o podnebju v preteklosti.
# =====================================================================@040265=
# 1. podnaloga
# Podatki o širini letnic določenega debla so shranjeni v
# datoteki. Primer začetka ene od datotek:
# 
#     2002,1
#     2001,2
#     2000,1
#     1999,3
#     1998,2
# 
# V vsaki vrstici sta leto in pripadajoča širina letnice ločena z vejico.
# Napišite funkcijo `preberi(vhodnapot)`, ki bo prebrala datoteko, ki se
# nahaja na `vhodnapot` in vrnila nabor, kjer je prvi element seznam
# vseh let, drugi element pa seznam pripadajočih širin letnic. Elementi obeh
# seznamov naj bodo cela števila (tip `int`). Primer za zgornjo datoteko:
# 
#     >>> preberi('debla_vhodna_1.txrt')
#     ([2002, 2001, 2000, 1999, 1998], [1, 2, 1, 3, 2])
# =============================================================================
def preberi(vhodnapot):
    leta = []
    sirine = []

    with open(vhodnapot, mode='r', encoding='utf-8') as f:
        for vrstica in f:
            vrednosti = vrstica.strip().split(',')
            leta.append(int(vrednosti[0])) # int, ker je številka; mesto na katerem se nahaja
            sirine.append(int(vrednosti[1]))
    return leta, sirine


# =====================================================================@040270=
# 2. podnaloga
# Arheologe zanima, kje so rasla drevesa, iz katerih so narejene koliščarske
# kolibe. Vzorec lesa iz kolibe bodo primerjali z vzorci lesa s treh
# različnih lokacij. Izmerili so širne letnic vsakega vzorca. Če je les z iste
# lokacije, ima enak vzorec letnic, saj so imela drevesa isto vreme. Da bi
# določili, s katerim od treh vzorcev se najbolj ujema širina kolišcarskih
# letnic, uporabimo enačbo $$r_{xy} = \sqrt{\sum_i (x_i - y_i)^2},$$
# kjer je $x_i$ širina koliščarske letnice v $i$-tem letu in $y_i$ širina
# letnice za primerjavo v $i$-tem letu. Številka $r_{xy}$ opisuje, koliko se
# širine letnic debla $x$ razlikujejo od širin debla $y$. Manjša vrednost 
# $r_{xy}$ pomeni boljše ujemanje.
# 
# Napišite funkcijo `lokacija(koliscarske_sirine, sirine1, sirine2, sirine3)`,
# ki sprejme seznam širin letnic koliščarskega vzorca, seznam širin letnic s 
# prve primerjalne lokacije ter seznam širin z druge in s tretje lokacije. 
# Izračunajte vrednosti $r$ za vsa tri primerjalna debla. Funkcija naj
# vrne številko debla, ki se najbolj ujema s koliščarskim deblom 
# (število 1 ali 2 ali 3). Primer:
# 
#     >>> lokacija([1, 2, 1, 4], [1, 2, 1, 4], [3, 1, 5, 1], [2, 1, 1, 1])
#     1
# =============================================================================
def odstopanje(meritve1, meritve2): # funkcija za računanje r
    vsota = 0
    for i in range(len(meritve1)): # zapis vsote/računa
        vsota += (meritve1[i] - meritve2[i])**2
    return vsota ** 0.5


def lokacija(koliscarske_sirine, sirine1, sirine2, sirine3): # katera je pravilna
    odstopanje1 = odstopanje(koliscarske_sirine, sirine1)
    odstopanje2 = odstopanje(koliscarske_sirine, sirine2)
    odstopanje3 = odstopanje(koliscarske_sirine, sirine3)
    if odstopanje1 < odstopanje2 and odstopanje1 < odstopanje3:
        return 1
    elif odstopanje2 < odstopanje1 and odstopanje2 < odstopanje3:
        return 2
    else:
        return 3


# =====================================================================@040269=
# 3. podnaloga
# Lesarji so določili zvezo med širino letnice in povprečno spomladansko
# temperaturo. Za določeno leto najprej izračunajo povprečje širine letnic treh
# debel z iste lokacije. Nato povprečje pomnožijo s 4 in odštejejo 5. Tako
# dobijo spomladansko temperaturo.
# 
# Napišite funckijo `temperature(izhodnapot, leta, sirine1, sirine2, sirine3)`, 
# ki sprejme pot do izhodne datoteke, seznam let in tri sezname pripadajočih 
# širin letnic treh debel z iste lokacije. Funkcija naj v izhodno datoteko 
# zapiše leto in pripadajočo spomladansko temperaturo ločena z vejico. 
# Temperatura naj bo zaokrožena na celo število. Primer:
# 
#     >>> temperature('temperature_izhodna.txt', 
#                     [2002, 2001, 2000, 1999, 1998], 
#                     [4, 5, 6, 4, 4],
#                     [3, 5, 3, 3, 4],
#                     [2, 3, 4, 2, 4])
# 
# Po zgornjem klicu funkcije naj bo vsebina datoteke `temperature_izhodna.txt` 
# enaka
# 
#     2002,7
#     2001,12
#     2000,12
#     1999,7
#     1998,11
# =============================================================================
def temperature(izhodnapot, leta, sirine1, sirine2, sirine3):
    with open(izhodnapot, mode='w', encoding='utf-8') as f:
        for i in range(len(leta)):
            povprecje = (sirine1[i] + sirine2[i] + sirine3[i]) / 3
            temp = 4 * povprecje - 5
            f.write(str(leta[i]) + ',' + str(round(temp)) + '\n')

# Meritve
#
# Pri enem od fizikalnih praktikumov je prišlo do težav in ker ste tako vdani 
# študiju, da ste še poleti na fakulteti, se za pomoč obrnejo na vas.
# 
# **POZOR**: Ta naloga je namenjena reševanju z modulom numpy. Če boste uporabljali zanke,
# lahko dosežete največ polovico možnih točk.
# =====================================================================@040253=
# 1. podnaloga
# Pri praktikumu se ukvarjajo z odbojem in lomom svetlobe. Asistent ni pripričan,
# če sistem za merjenje kotov deluje pravilno. Vaša naloga je testirati natančnost
# meritev, tako da primerjate meritve odbojnih kotov s pričakovanimi vrednostmi.
# 
# Napišite funkcijo `deluje_pravilno(n, meritve)`, ki sprejme naravno število `n`
# in enodimenzionalno tabelo `meritve`, ki predstavlja izmerjene odbojne kote pri
# `n` vpadnih kotih, enakomerno porazdeljenih med `0` in `90` stopinj. 
# Na primer za `n = 4` so vpadni koti `0`, `30`, `60` in `90` stopinj.
# 
# Funkcija naj vrne `True`, če se nobena od meritev od pričakovane vrednosti ne 
# razlikuje za več kot `1` stopinjo, sicer `False`.
# 
#     >>> deluje_pravilno(4, np.array([0.1, 29.3, 60.9, 89.2]))
#     True
# 
#     >>> deluje_pravilno(7, np.array([0.2, 15.0, 30.2, 44.9, 62.0, 75.0, 90.0]))
#     False
# 
# **Opomba**: Odbojni kot je enak vpadnemu.
# =============================================================================
import numpy as np
def deluje_pravilno(n, meritve):
    pricakovano = np.linspace(0, 90, n)
    odstopanja = np.abs(meritve - pricakovano)
    return np.all(odstopanja <= 1)


# =====================================================================@040254=
# 2. podnaloga
# Ker ne želijo preveriti le točnosti meritev odbojnega, temveč tudi lomnega kota,
# jim pomagajte napisati funkcijo `koti(razmak, kolicnika)`, ki iz podatkov o vpadnih kotih
# izračuna pričakovane odbojne in lomne kote.
# Vpadni koti so tu razporejeni med `30` in `60` stopinjami z razmakom `razmak`. 
# Funkcija naj sprejme tudi seznam dveh vrednosti
# `kolicnika` oblike $[n_1, n_2]$, kjer je $n_1$ lomni količnik prve, $n_2$ pa druge snovi.
# Vrne naj dvodimenzionalno tabelo, kjer so v prvi vrstici vpadni, v drugi in tretji vrstici pa
# pripadajoči odbojni in lomni koti. Odbojni kot je enak vpadnemu, lomni kot $\alpha_2$ se pa
# izračuna po enačbi 
# $$ \frac{\sin(\alpha_1)}{\sin(\alpha_2)} = \frac{n_2}{n_1} $$
# oziroma $ \alpha_2 = \arcsin\bigl( \frac{n_1}{n_2} \sin(\alpha_1) \bigr) $.
# 
#     >>> koti(10, [1, 1.33])
#     [[30.         40.         50.         60.        ]
#      [30.         40.         50.         60.        ]
#      [22.08241319 28.90108454 35.1678191  40.62813065]]
# 
#     >>> koti(15, [1.51, 1.33])
#     [[30.         45.         60.        ]
#      [30.         45.         60.        ]
#      [34.58784951 53.39884378 79.49275287]]
# 
# **Opomba**: Funkcija `np.sin()` sprejme argument v radianih. Za pretvarjanje med radiani
# in stopinjami vam lahko prav prideta funkciji `np.radians()` in `np.degrees()`.
# =============================================================================
import numpy as np
def koti(razmak, kolicnika):
    vpadni = np.arange(30, 60 + razmak, razmak)
    odbojni = vpadni
    [n1, n2] = kolicnika
    lomni = np.arcsin((n1 / n2) * np.sin(np.radians(vpadni)))
    lomni = np.degrees(lomni)
    return np.vstack([vpadni, odbojni, lomni])


# =====================================================================@040313=
# 3. podnaloga
# Po uspešnem izračunu odbojnih in lomnih kotov se asistent odloči, da bi rad podrobneje analiziral rezultate.
# 
# Napišite funkcijo `analiza_meritev(pricakovane_vrednosti, odbojni, lomni)`, kjer argument `pricakovane_vrednosti`
# predstavlja rezultat prejšnje naloge, `odbojni` enodimenzionalno tabelo izmerjenih odbojnih, `lomni` pa
# lomnih kotov. 
# Funkcija naj vrne trojico vrednosti `(minimum, povprecje, maksimum)`, kjer `minimum` predstavlja najmanjše,
# `povprecje` povprečno, `maksimum` pa največje absolutno
# odstopanje meritev od pričakovanih vrednosti, vse troje zaokroženo na 2 decimalni mesti.
# 
#     >>> pricakovane_vrednosti = koti(15, [1.51, 1.33]) 
#     >>> odbojni = np.array([32.1, 45., 67.991])
#     >>> lomni = np.array([33.68, 52.7, 80.])
#     >>> analiza_meritev(pricakovane_vrednosti, odbojni, lomni)
#     (0.0, 2.03, 7.99)
# =============================================================================
import numpy as np
def analiza_meritev(pricakovane_vrednosti, odbojni, lomni):
    razlike_odbojni = abs(pricakovane_vrednosti[1, :] - odbojni)
    razlike_lomni = abs(pricakovane_vrednosti[2, :] - lomni)
    razlike = np.append(razlike_odbojni, razlike_lomni)
    minimum = round(np.min(razlike), 2)
    povprecje = round(np.average(razlike), 2)
    maksimum = round(np.max(razlike), 2)
    return (minimum, povprecje, maksimum)



